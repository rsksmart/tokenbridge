{
  "language": "Solidity",
  "sources": {
    "contracts/Bridge/BridgeV4.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// import \"hardhat/console.sol\";\n// Import base Initializable contract\nimport \"../zeppelin/upgradable/Initializable.sol\";\n// Import interface and library from OpenZeppelin contracts\nimport \"../zeppelin/upgradable/utils/ReentrancyGuard.sol\";\nimport \"../zeppelin/upgradable/lifecycle/UpgradablePausable.sol\";\nimport \"../zeppelin/upgradable/ownership/UpgradableOwnable.sol\";\n\nimport \"../zeppelin/introspection/IERC1820Registry.sol\";\nimport \"../zeppelin/token/ERC777/IERC777Recipient.sol\";\nimport \"../zeppelin/token/ERC20/IERC20.sol\";\nimport \"../zeppelin/token/ERC20/SafeERC20.sol\";\nimport \"../zeppelin/utils/Address.sol\";\nimport \"../zeppelin/math/SafeMath.sol\";\nimport \"../zeppelin/token/ERC777/IERC777.sol\";\n\nimport \"../lib/LibEIP712.sol\";\nimport \"../lib/LibUtils.sol\";\n\nimport \"./IBridgeV4.sol\";\nimport \"../interface/ISideToken.sol\";\nimport \"../interface/ISideTokenFactory.sol\";\nimport \"../interface/IAllowTokens.sol\";\nimport \"../interface/IWrapped.sol\";\n\n\ncontract BridgeV4 is Initializable, IBridgeV4, IERC777Recipient, UpgradablePausable, UpgradableOwnable, ReentrancyGuard {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    using Address for address;\n\n    address constant internal NULL_ADDRESS = address(0);\n    bytes32 constant internal NULL_HASH = bytes32(0);\n    IERC1820Registry constant internal erc1820 = IERC1820Registry(0xdd343Ef491B9520BB5efFC2A7154B133893840Ea);\n\n    address internal federation;\n    uint256 internal feePercentage;\n    string public symbolPrefix;\n    bytes32 public DOMAIN_SEPARATOR; // replaces uint256 internal _depprecatedLastDay;\n    uint256 internal _deprecatedSpentToday;\n    address private feeCollectorAddress = 0x803c3910f339ee570A3fB9dB8a5A8143d284c5c5;\n\n    mapping (address => address) public mappedTokens; // OirignalToken => SideToken\n    mapping (address => address) public originalTokens; // SideToken => OriginalToken\n    mapping (address => bool) public knownTokens; // OriginalToken => true\n    mapping (bytes32 => bool) public claimed; // transactionDataHash => true // previously named processed\n    IAllowTokens public allowTokens;\n    ISideTokenFactory public sideTokenFactory;\n    //Bridge_v1 variables\n    bool public isUpgrading;\n    uint256 constant public feePercentageDivider = 10000; // Porcentage with up to 2 decimals\n    //Bridge_v4 variables\n    bytes32 constant internal _erc777Interface = keccak256(\"ERC777Token\");\n    IWrapped public wrappedCurrency;\n    mapping (bytes32 => bytes32) public transactionsDataHashes; // transactionHash => transactionDataHash\n    mapping (bytes32 => address) public originalTokenAddresses; // transactionHash => originalTokenAddress\n    mapping (bytes32 => address) public senderAddresses; // transactionHash => senderAddress\n\n    // keccak256(\"Claim(address to,uint256 amount,bytes32 transactionHash,address relayer,uint256 fee,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant CLAIM_TYPEHASH = 0xf18ceda3f6355f78c234feba066041a50f6557bfb600201e2a71a89e2dd80433;\n    mapping(address => uint) public nonces;\n\n    event AllowTokensChanged(address _newAllowTokens);\n    event FederationChanged(address _newFederation);\n    event SideTokenFactoryChanged(address _newSideTokenFactory);\n    event Upgrading(bool _isUpgrading);\n    event WrappedCurrencyChanged(address _wrappedCurrency);\n    event FeeCollectorAddressChanged(address indexed sender, address oldAddress, address newAddress);\n\n    function initialize(\n        address _manager,\n        address _federation,\n        address _allowTokens,\n        address _sideTokenFactory,\n        string memory _symbolPrefix\n    ) public initializer {\n        UpgradableOwnable.initialize(_manager);\n        UpgradablePausable.__Pausable_init(_manager);\n        symbolPrefix = _symbolPrefix;\n        allowTokens = IAllowTokens(_allowTokens);\n        sideTokenFactory = ISideTokenFactory(_sideTokenFactory);\n        federation = _federation;\n        //keccak256(\"ERC777TokensRecipient\")\n        erc1820.setInterfaceImplementer(address(this), 0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b, address(this));\n        initDomainSeparator();\n    }\n\n    receive () external payable {\n        // The fallback function is needed to use WRBTC\n        require(_msgSender() == address(wrappedCurrency), \"Bridge: not wrappedCurrency\");\n    }\n\n    function version() override external pure returns (string memory) {\n        return \"v4\";\n    }\n\n    function initDomainSeparator() public {\n        uint chainId;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            chainId := chainid()\n        }\n        DOMAIN_SEPARATOR = LibEIP712.hashEIP712Domain(\n            \"RSK Token Bridge\",\n            \"1\",\n            chainId,\n            address(this)\n        );\n    }\n\n    modifier whenNotUpgrading() {\n        require(!isUpgrading, \"Bridge: Upgrading\");\n        _;\n    }\n\n    function acceptTransfer(\n        address _originalTokenAddress,\n        address payable _from,\n        address payable _to,\n        uint256 _amount,\n        bytes32 _blockHash,\n        bytes32 _transactionHash,\n        uint32 _logIndex\n    ) external whenNotPaused nonReentrant override {\n        require(_msgSender() == federation, \"Bridge: Not Federation\");\n        require(knownTokens[_originalTokenAddress] ||\n            mappedTokens[_originalTokenAddress] != NULL_ADDRESS,\n            \"Bridge: Unknown token\"\n        );\n        require(_to != NULL_ADDRESS, \"Bridge: Null To\");\n        require(_amount > 0, \"Bridge: Amount 0\");\n        require(_blockHash != NULL_HASH, \"Bridge: Null BlockHash\");\n        require(_transactionHash != NULL_HASH, \"Bridge: Null TxHash\");\n        require(transactionsDataHashes[_transactionHash] == bytes32(0), \"Bridge: Already accepted\");\n\n        bytes32 _transactionDataHash = getTransactionDataHash(\n            _to,\n            _amount,\n            _blockHash,\n            _transactionHash,\n            _logIndex\n        );\n        // Do not remove, claimed also has the previously processed using the older bridge version\n        // https://github.com/rsksmart/tokenbridge/blob/TOKENBRIDGE-1.2.0/bridge/contracts/Bridge.sol#L41\n        require(!claimed[_transactionDataHash], \"Bridge: Already claimed\");\n\n        transactionsDataHashes[_transactionHash] = _transactionDataHash;\n        originalTokenAddresses[_transactionHash] = _originalTokenAddress;\n        senderAddresses[_transactionHash] = _from;\n\n        emit AcceptedCrossTransfer(\n            _transactionHash,\n            _originalTokenAddress,\n            _to,\n            _from,\n            _amount,\n            _blockHash,\n            _logIndex\n        );\n    }\n\n    function setFeeCollectorAddress(address _newAddress) public onlyOwner {\n        address oldAddress = feeCollectorAddress;\n        feeCollectorAddress = _newAddress;\n        emit FeeCollectorAddressChanged(_msgSender(), oldAddress, _newAddress);\n    }\n\n    function getFeeCollectorAddress() public view returns(address) {\n        return feeCollectorAddress;\n    }\n\n    function createSideToken(\n        uint256 _typeId,\n        address _originalTokenAddress,\n        uint8 _originalTokenDecimals,\n        string calldata _originalTokenSymbol,\n        string calldata _originalTokenName\n    ) external onlyOwner {\n        require(_originalTokenAddress != NULL_ADDRESS, \"Bridge: Null token\");\n        address sideToken = mappedTokens[_originalTokenAddress];\n        require(sideToken == NULL_ADDRESS, \"Bridge: Already exists\");\n        uint256 granularity = LibUtils.decimalsToGranularity(_originalTokenDecimals);\n        string memory newSymbol = string(abi.encodePacked(symbolPrefix, _originalTokenSymbol));\n\n        // Create side token\n        sideToken = sideTokenFactory.createSideToken(_originalTokenName, newSymbol, granularity);\n\n        mappedTokens[_originalTokenAddress] = sideToken;\n        originalTokens[sideToken] = _originalTokenAddress;\n        allowTokens.setToken(sideToken, _typeId);\n\n        emit NewSideToken(sideToken, _originalTokenAddress, newSymbol, granularity);\n    }\n\n    function claim(ClaimData calldata _claimData)\n    external override returns (uint256 receivedAmount) {\n\n        receivedAmount = _claim(\n            _claimData,\n            _claimData.to,\n            payable(address(0)),\n            0\n        );\n        return receivedAmount;\n    }\n\n    function claimFallback(ClaimData calldata _claimData)\n    external override returns (uint256 receivedAmount) {\n        require(_msgSender() == senderAddresses[_claimData.transactionHash],\"Bridge: invalid sender\");\n        receivedAmount = _claim(\n            _claimData,\n            _msgSender(),\n            payable(address(0)),\n            0\n        );\n        return receivedAmount;\n    }\n\n    function getDigest(\n        ClaimData memory _claimData,\n        address payable _relayer,\n        uint256 _fee,\n        uint256 _deadline\n    ) internal returns (bytes32) {\n        return LibEIP712.hashEIP712Message(\n            DOMAIN_SEPARATOR,\n            keccak256(\n                abi.encode(\n                    CLAIM_TYPEHASH,\n                    _claimData.to,\n                    _claimData.amount,\n                    _claimData.transactionHash,\n                    _relayer,\n                    _fee,\n                    nonces[_claimData.to]++,\n                    _deadline\n                )\n            )\n        );\n    }\n\n    // Inspired by https://github.com/dapphub/ds-dach/blob/master/src/dach.sol\n    function claimGasless(\n        ClaimData calldata _claimData,\n        address payable _relayer,\n        uint256 _fee,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external override returns (uint256 receivedAmount) {\n        require(_deadline >= block.timestamp, \"Bridge: EXPIRED\");\n\n        bytes32 digest = getDigest(_claimData, _relayer, _fee, _deadline);\n        address recoveredAddress = ecrecover(digest, _v, _r, _s);\n        require(_claimData.to != address(0) && recoveredAddress == _claimData.to, \"Bridge: INVALID_SIGNATURE\");\n\n        receivedAmount = _claim(\n            _claimData,\n            _claimData.to,\n            _relayer,\n            _fee\n        );\n        return receivedAmount;\n    }\n\n    function _claim(\n        ClaimData calldata _claimData,\n        address payable _reciever,\n        address payable _relayer,\n        uint256 _fee\n    ) internal nonReentrant returns (uint256 receivedAmount) {\n        address originalTokenAddress = originalTokenAddresses[_claimData.transactionHash];\n        require(originalTokenAddress != NULL_ADDRESS, \"Bridge: Tx not crossed\");\n\n        bytes32 transactionDataHash = getTransactionDataHash(\n            _claimData.to,\n            _claimData.amount,\n            _claimData.blockHash,\n            _claimData.transactionHash,\n            _claimData.logIndex\n        );\n        require(transactionsDataHashes[_claimData.transactionHash] == transactionDataHash, \"Bridge: Wrong transactionDataHash\");\n        require(!claimed[transactionDataHash], \"Bridge: Already claimed\");\n\n        claimed[transactionDataHash] = true;\n        if (knownTokens[originalTokenAddress]) {\n            receivedAmount =_claimCrossBackToToken(\n                originalTokenAddress,\n                _reciever,\n                _claimData.amount,\n                _relayer,\n                _fee\n            );\n        } else {\n            receivedAmount =_claimCrossToSideToken(\n                originalTokenAddress,\n                _reciever,\n                _claimData.amount,\n                _relayer,\n                _fee\n            );\n        }\n        emit Claimed(\n            _claimData.transactionHash,\n            originalTokenAddress,\n            _claimData.to,\n            senderAddresses[_claimData.transactionHash],\n            _claimData.amount,\n            _claimData.blockHash,\n            _claimData.logIndex,\n            _reciever,\n            _relayer,\n            _fee\n        );\n        return receivedAmount;\n    }\n\n    function _claimCrossToSideToken(\n        address _originalTokenAddress,\n        address payable _receiver,\n        uint256 _amount,\n        address payable _relayer,\n        uint256 _fee\n    ) internal returns (uint256 receivedAmount) {\n        address sideToken = mappedTokens[_originalTokenAddress];\n        uint256 granularity = IERC777(sideToken).granularity();\n        uint256 formattedAmount = _amount.mul(granularity);\n        require(_fee <= formattedAmount, \"Bridge: fee too high\");\n        receivedAmount = formattedAmount - _fee;\n        ISideToken(sideToken).mint(_receiver, receivedAmount, \"\", \"\");\n        if(_fee > 0) {\n            ISideToken(sideToken).mint(_relayer, _fee, \"\", \"relayer fee\");\n        }\n        return receivedAmount;\n    }\n\n    function _claimCrossBackToToken(\n        address _originalTokenAddress,\n        address payable _receiver,\n        uint256 _amount,\n        address payable _relayer,\n        uint256 _fee\n    ) internal returns (uint256 receivedAmount) {\n        uint256 decimals = LibUtils.getDecimals(_originalTokenAddress);\n        //As side tokens are ERC777 they will always have 18 decimals\n        uint256 formattedAmount = _amount.div(uint256(10) ** (18 - decimals));\n        require(_fee <= formattedAmount, \"Bridge: fee too high\");\n        receivedAmount = formattedAmount - _fee;\n        if(address(wrappedCurrency) == _originalTokenAddress) {\n            wrappedCurrency.withdraw(formattedAmount);\n            _receiver.transfer(receivedAmount);\n            if(_fee > 0) {\n                _relayer.transfer(_fee);\n            }\n        } else {\n            IERC20(_originalTokenAddress).safeTransfer(_receiver, receivedAmount);\n            if(_fee > 0) {\n                IERC20(_originalTokenAddress).safeTransfer(_relayer, _fee);\n            }\n        }\n        return receivedAmount;\n    }\n\n    /**\n     * ERC-20 tokens approve and transferFrom pattern\n     * See https://eips.ethereum.org/EIPS/eip-20#transferfrom\n     */\n    function receiveTokensTo(address tokenToUse, address to, uint256 amount) override public {\n        address sender = _msgSender();\n        //Transfer the tokens on IERC20, they should be already Approved for the bridge Address to use them\n        IERC20(tokenToUse).safeTransferFrom(sender, address(this), amount);\n        crossTokens(tokenToUse, sender, to, amount, \"\");\n    }\n\n    /**\n     * Use network currency and cross it.\n     */\n    function depositTo(address to) override external payable {\n        address sender = _msgSender();\n        require(address(wrappedCurrency) != NULL_ADDRESS, \"Bridge: wrappedCurrency empty\");\n        wrappedCurrency.deposit{ value: msg.value }();\n        crossTokens(address(wrappedCurrency), sender, to, msg.value, \"\");\n    }\n\n    /**\n     * ERC-777 tokensReceived hook allows to send tokens to a contract and notify it in a single transaction\n     * See https://eips.ethereum.org/EIPS/eip-777#motivation for details\n     */\n    function tokensReceived (\n        address operator,\n        address from,\n        address to,\n        uint amount,\n        bytes calldata userData,\n        bytes calldata\n    ) external override(IBridgeV4, IERC777Recipient){\n        //Hook from ERC777address\n        if(operator == address(this)) return; // Avoid loop from bridge calling to ERC77transferFrom\n        require(to == address(this), \"Bridge: Not to this address\");\n        address tokenToUse = _msgSender();\n        require(erc1820.getInterfaceImplementer(tokenToUse, _erc777Interface) != NULL_ADDRESS, \"Bridge: Not ERC777 token\");\n        require(userData.length != 0 || !from.isContract(), \"Bridge: Specify receiver address in data\");\n        address receiver = userData.length == 0 ? from : LibUtils.bytesToAddress(userData);\n        crossTokens(tokenToUse, from, receiver, amount, userData);\n    }\n\n    function crossTokens(address tokenToUse, address from, address to, uint256 amount, bytes memory userData)\n    internal whenNotUpgrading whenNotPaused nonReentrant {\n        knownTokens[tokenToUse] = true;\n        uint256 fee = amount.mul(feePercentage).div(feePercentageDivider);\n        uint256 amountMinusFees = amount.sub(fee);\n        uint8 decimals = LibUtils.getDecimals(tokenToUse);\n        uint formattedAmount = amount;\n        if(decimals != 18) {\n            formattedAmount = amount.mul(uint256(10)**(18-decimals));\n        }\n        // We consider the amount before fees converted to 18 decimals to check the limits\n        // updateTokenTransfer revert if token not allowed\n        allowTokens.updateTokenTransfer(tokenToUse, formattedAmount);\n        address originalTokenAddress = tokenToUse;\n        if (originalTokens[tokenToUse] != NULL_ADDRESS) {\n            //Side Token Crossing\n            originalTokenAddress = originalTokens[tokenToUse];\n            uint256 granularity = LibUtils.getGranularity(tokenToUse);\n            uint256 modulo = amountMinusFees.mod(granularity);\n            fee = fee.add(modulo);\n            amountMinusFees = amountMinusFees.sub(modulo);\n            IERC777(tokenToUse).burn(amountMinusFees, userData);\n        }\n\n        emit Cross(\n            originalTokenAddress,\n            from,\n            to,\n            amountMinusFees,\n            userData\n        );\n\n        if (fee > 0) {\n            //Send the payment to the MultiSig of the Federation\n            IERC20(tokenToUse).safeTransfer(payable(feeCollectorAddress), fee);\n        }\n    }\n\n    function getTransactionDataHash(\n        address _to,\n        uint256 _amount,\n        bytes32 _blockHash,\n        bytes32 _transactionHash,\n        uint32 _logIndex\n    )\n        public pure override returns(bytes32)\n    {\n        return keccak256(abi.encodePacked(_blockHash, _transactionHash, _to, _amount, _logIndex));\n    }\n\n    function setFeePercentage(uint amount) external onlyOwner {\n        require(amount < (feePercentageDivider/10), \"Bridge: bigger than 10%\");\n        feePercentage = amount;\n        emit FeePercentageChanged(feePercentage);\n    }\n\n    function getFeePercentage() external view override returns(uint) {\n        return feePercentage;\n    }\n\n    function changeFederation(address newFederation) external onlyOwner {\n        require(newFederation != NULL_ADDRESS, \"Bridge: Federation is empty\");\n        federation = newFederation;\n        emit FederationChanged(federation);\n    }\n\n\n    function changeAllowTokens(address newAllowTokens) external onlyOwner {\n        require(newAllowTokens != NULL_ADDRESS, \"Bridge: AllowTokens is empty\");\n        allowTokens = IAllowTokens(newAllowTokens);\n        emit AllowTokensChanged(newAllowTokens);\n    }\n\n    function getFederation() external view returns(address) {\n        return federation;\n    }\n\n    function changeSideTokenFactory(address newSideTokenFactory) external onlyOwner {\n        require(newSideTokenFactory != NULL_ADDRESS, \"Bridge: SideTokenFactory is empty\");\n        sideTokenFactory = ISideTokenFactory(newSideTokenFactory);\n        emit SideTokenFactoryChanged(newSideTokenFactory);\n    }\n\n    function setUpgrading(bool _isUpgrading) external onlyOwner {\n        isUpgrading = _isUpgrading;\n        emit Upgrading(isUpgrading);\n    }\n\n    function setWrappedCurrency(address _wrappedCurrency) external onlyOwner {\n        require(_wrappedCurrency != NULL_ADDRESS, \"Bridge: wrapp is empty\");\n        wrappedCurrency = IWrapped(_wrappedCurrency);\n        emit WrappedCurrencyChanged(_wrappedCurrency);\n    }\n\n    function hasCrossed(bytes32 transactionHash) public view returns (bool) {\n        return transactionsDataHashes[transactionHash] != bytes32(0);\n    }\n\n    function hasBeenClaimed(bytes32 transactionHash) public view returns (bool) {\n        return claimed[transactionsDataHashes[transactionHash]];\n    }\n\n}\n"
    },
    "contracts/Bridge/IBridgeV4.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IBridgeV4 {\n\n    struct ClaimData {\n        address payable to;\n        uint256 amount;\n        bytes32 blockHash;\n        bytes32 transactionHash;\n        uint32 logIndex;\n    }\n\n    function version() external pure returns (string memory);\n\n    function getFeePercentage() external view returns(uint);\n\n    /**\n     * ERC-20 tokens approve and transferFrom pattern\n     * See https://eips.ethereum.org/EIPS/eip-20#transferfrom\n     */\n    function receiveTokensTo(address tokenToUse, address to, uint256 amount) external;\n\n    /**\n     * Use network currency and cross it.\n     */\n    function depositTo(address to) external payable;\n\n    /**\n     * ERC-777 tokensReceived hook allows to send tokens to a contract and notify it in a single transaction\n     * See https://eips.ethereum.org/EIPS/eip-777#motivation for details\n     */\n    function tokensReceived (\n        address operator,\n        address from,\n        address to,\n        uint amount,\n        bytes calldata userData,\n        bytes calldata operatorData\n    ) external;\n\n    /**\n     * Accepts the transaction from the other chain that was voted and sent by the Federation contract\n     */\n    function acceptTransfer(\n        address _originalTokenAddress,\n        address payable _from,\n        address payable _to,\n        uint256 _amount,\n        bytes32 _blockHash,\n        bytes32 _transactionHash,\n        uint32 _logIndex\n    ) external;\n\n    /**\n     * Claims the crossed transaction using the hash, this sends the funds to the address indicated in\n     */\n    function claim(ClaimData calldata _claimData) external returns (uint256 receivedAmount);\n\n    function claimFallback(ClaimData calldata _claimData) external returns (uint256 receivedAmount);\n\n    function claimGasless(\n        ClaimData calldata _claimData,\n        address payable _relayer,\n        uint256 _fee,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external returns (uint256 receivedAmount);\n\n    function getTransactionDataHash(\n        address _to,\n        uint256 _amount,\n        bytes32 _blockHash,\n        bytes32 _transactionHash,\n        uint32 _logIndex\n    ) external returns(bytes32);\n\n    event Cross(\n        address indexed _tokenAddress,\n        address indexed _from,\n        address indexed _to,\n        uint256 _amount,\n        bytes _userData\n    );\n    event NewSideToken(\n        address indexed _newSideTokenAddress,\n        address indexed _originalTokenAddress,\n        string _newSymbol,\n        uint256 _granularity\n    );\n    event AcceptedCrossTransfer(\n        bytes32 indexed _transactionHash,\n        address indexed _originalTokenAddress,\n        address indexed _to,\n        address  _from,\n        uint256 _amount,\n        bytes32 _blockHash,\n        uint256 _logIndex\n    );\n    event FeePercentageChanged(uint256 _amount);\n    event Claimed(\n        bytes32 indexed _transactionHash,\n        address indexed _originalTokenAddress,\n        address indexed _to,\n        address _sender,\n        uint256 _amount,\n        bytes32 _blockHash,\n        uint256 _logIndex,\n        address _reciever,\n        address _relayer,\n        uint256 _fee\n    );\n}\n"
    },
    "contracts/interface/IAllowTokens.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma abicoder v2;\ninterface IAllowTokens {\n\n\tstruct Limits {\n\t\tuint256 min;\n\t\tuint256 max;\n\t\tuint256 daily;\n\t\tuint256 mediumAmount;\n\t\tuint256 largeAmount;\n\t}\n\n\tstruct TokenInfo {\n\t\tbool allowed;\n\t\tuint256 typeId;\n\t\tuint256 spentToday;\n\t\tuint256 lastDay;\n\t}\n\n\tstruct TypeInfo {\n\t\tstring description;\n\t\tLimits limits;\n\t}\n\n\tstruct TokensAndType {\n\t\taddress token;\n\t\tuint256 typeId;\n\t}\n\n\tfunction version() external pure returns (string memory);\n\n\tfunction getInfoAndLimits(address token) external view returns (TokenInfo memory info, Limits memory limit);\n\n\tfunction calcMaxWithdraw(address token) external view returns (uint256 maxWithdraw);\n\n\tfunction getTypesLimits() external view returns(Limits[] memory limits);\n\n\tfunction getTypeDescriptionsLength() external view returns(uint256);\n\n\tfunction getTypeDescriptions() external view returns(string[] memory descriptions);\n\n\tfunction setToken(address token, uint256 typeId) external;\n\n\tfunction getConfirmations() external view returns (uint256 smallAmount, uint256 mediumAmount, uint256 largeAmount);\n\n\tfunction isTokenAllowed(address token) external view returns (bool);\n\n\tfunction updateTokenTransfer(address token, uint256 amount) external;\n}"
    },
    "contracts/interface/ISideToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma abicoder v2;\n\ninterface ISideToken {\n    function mint(address account, uint256 amount, bytes calldata userData, bytes calldata operatorData) external;\n}"
    },
    "contracts/interface/ISideTokenFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma abicoder v2;\n\ninterface ISideTokenFactory {\n\n    function createSideToken(string calldata name, string calldata symbol, uint256 granularity) external returns(address);\n\n    event SideTokenCreated(address indexed sideToken, string symbol, uint256 granularity);\n}"
    },
    "contracts/interface/IWrapped.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma abicoder v2;\ninterface IWrapped {\n    function balanceOf(address) external returns(uint);\n\n    function deposit() external payable;\n\n    function withdraw(uint wad) external;\n\n    function totalSupply() external view returns (uint);\n\n    function approve(address guy, uint wad) external returns (bool);\n\n    function transfer(address dst, uint wad) external returns (bool);\n\n    function transferFrom(address src, address dst, uint wad)\n        external\n        returns (bool);\n}"
    },
    "contracts/lib/LibEIP712.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma abicoder v2;\n\n// https://github.com/0xProject/0x-monorepo/blob/development/contracts/utils/contracts/src/LibEIP712.sol\nlibrary LibEIP712 {\n\n    // Hash of the EIP712 Domain Separator Schema\n    // keccak256(abi.encodePacked(\n    //     \"EIP712Domain(\",\n    //     \"string name,\",\n    //     \"string version,\",\n    //     \"uint256 chainId,\",\n    //     \"address verifyingContract\",\n    //     \")\"\n    // ))\n    bytes32 constant internal _EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\n\n    /// @dev Calculates a EIP712 domain separator.\n    /// @param name The EIP712 domain name.\n    /// @param version The EIP712 domain version.\n    /// @param verifyingContract The EIP712 verifying contract.\n    /// @return result EIP712 domain separator.\n    function hashEIP712Domain(\n        string memory name,\n        string memory version,\n        uint256 chainId,\n        address verifyingContract\n    )\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        bytes32 schemaHash = _EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH;\n\n        // Assembly for more efficient computing:\n        // keccak256(abi.encodePacked(\n        //     _EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH,\n        //     keccak256(bytes(name)),\n        //     keccak256(bytes(version)),\n        //     chainId,\n        //     uint256(verifyingContract)\n        // ))\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            // Calculate hashes of dynamic data\n            let nameHash := keccak256(add(name, 32), mload(name))\n            let versionHash := keccak256(add(version, 32), mload(version))\n\n            // Load free memory pointer\n            let memPtr := mload(64)\n\n            // Store params in memory\n            mstore(memPtr, schemaHash)\n            mstore(add(memPtr, 32), nameHash)\n            mstore(add(memPtr, 64), versionHash)\n            mstore(add(memPtr, 96), chainId)\n            mstore(add(memPtr, 128), verifyingContract)\n\n            // Compute hash\n            result := keccak256(memPtr, 160)\n        }\n        return result;\n    }\n\n    /// @dev Calculates EIP712 encoding for a hash struct with a given domain hash.\n    /// @param eip712DomainHash Hash of the domain domain separator data, computed\n    ///                         with getDomainHash().\n    /// @param hashStruct The EIP712 hash struct.\n    /// @return result EIP712 hash applied to the given EIP712 Domain.\n    function hashEIP712Message(bytes32 eip712DomainHash, bytes32 hashStruct)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        // Assembly for more efficient computing:\n        // keccak256(abi.encodePacked(\n        //     EIP191_HEADER,\n        //     EIP712_DOMAIN_HASH,\n        //     hashStruct\n        // ));\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            // Load free memory pointer\n            let memPtr := mload(64)\n\n            mstore(memPtr, 0x1901000000000000000000000000000000000000000000000000000000000000)  // EIP191 header\n            mstore(add(memPtr, 2), eip712DomainHash)                                            // EIP712 domain hash\n            mstore(add(memPtr, 34), hashStruct)                                                 // Hash of struct\n\n            // Compute hash\n            result := keccak256(memPtr, 66)\n        }\n        return result;\n    }\n}"
    },
    "contracts/lib/LibUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma abicoder v2;\n\nlibrary LibUtils {\n\n    function decimalsToGranularity(uint8 decimals) internal pure returns (uint256) {\n        require(decimals <= 18, \"LibUtils: Decimals not <= 18\");\n        return uint256(10)**(18-decimals);\n    }\n\n    function getDecimals(address tokenToUse) internal view returns (uint8) {\n        //support decimals as uint256 or uint8\n        (bool success, bytes memory data) = tokenToUse.staticcall(abi.encodeWithSignature(\"decimals()\"));\n        require(success, \"LibUtils: No decimals\");\n        // uint<M>: enc(X) is the big-endian encoding of X,\n        //padded on the higher-order (left) side with zero-bytes such that the length is 32 bytes.\n        return uint8(abi.decode(data, (uint256)));\n    }\n\n    function getGranularity(address tokenToUse) internal view returns (uint256) {\n        //support granularity if ERC777\n        (bool success, bytes memory data) = tokenToUse.staticcall(abi.encodeWithSignature(\"granularity()\"));\n        require(success, \"LibUtils: No granularity\");\n\n        return abi.decode(data, (uint256));\n    }\n\n    function bytesToAddress(bytes memory bys) internal pure returns (address addr) {\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            addr := mload(add(bys,20))\n        }\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_bytes.length >= _start + 20, \"LibUtils: toAddress_outOfBounds\");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\n        require(_bytes.length >= _start + 16, \"LibUtils: toUint128_outOfBounds\");\n        uint128 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x10), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\n\t\trequire(_bytes.length >= _start + 32, \"LibUtils: toUint256_outOfBounds\");\n\t\tuint256 tempUint;\n\n        // solium-disable-next-line security/no-inline-assembly\n\t\tassembly {\n\t\t\ttempUint := mload(add(add(_bytes, 0x20), _start))\n\t\t}\n\n\t\treturn tempUint;\n\t}\n}\n"
    },
    "contracts/zeppelin/access/Roles.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma abicoder v2;\n\n/**\n * @title Roles\n * @dev Library for managing addresses assigned to a Role.\n */\nlibrary Roles {\n    struct Role {\n        mapping (address => bool) bearer;\n    }\n\n    /**\n     * @dev Give an account access to this role.\n     */\n    function add(Role storage role, address account) internal {\n        require(!has(role, account), \"Roles: account already has role\");\n        role.bearer[account] = true;\n    }\n\n    /**\n     * @dev Remove an account's access to this role.\n     */\n    function remove(Role storage role, address account) internal {\n        require(has(role, account), \"Roles: account doesn't have role\");\n        role.bearer[account] = false;\n    }\n\n    /**\n     * @dev Check if an account has this role.\n     * @return bool\n     */\n    function has(Role storage role, address account) internal view returns (bool) {\n        require(account != address(0), \"Roles: account is the zero address\");\n        return role.bearer[account];\n    }\n}\n"
    },
    "contracts/zeppelin/GSN/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma abicoder v2;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract  Context {\n\n    function _msgSender() internal view returns (address payable) {\n        return payable(msg.sender);\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "contracts/zeppelin/introspection/IERC1820Registry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma abicoder v2;\n\n/**\n * @dev Interface of the global ERC1820 Registry, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1820[EIP]. Accounts may register\n * implementers for interfaces in this registry, as well as query support.\n *\n * Implementers may be shared by multiple accounts, and can also implement more\n * than a single interface for each account. Contracts can implement interfaces\n * for themselves, but externally-owned accounts (EOA) must delegate this to a\n * contract.\n *\n * {IERC165} interfaces can also be queried via the registry.\n *\n * For an in-depth explanation and source code analysis, see the EIP text.\n */\ninterface IERC1820Registry {\n    /**\n     * @dev Sets `newManager` as the manager for `account`. A manager of an\n     * account is able to set interface implementers for it.\n     *\n     * By default, each account is its own manager. Passing a value of `0x0` in\n     * `newManager` will reset the manager to this initial state.\n     *\n     * Emits a {ManagerChanged} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the current manager for `account`.\n     */\n    function setManager(address account, address newManager) external;\n\n    /**\n     * @dev Returns the manager for `account`.\n     *\n     * See {setManager}.\n     */\n    function getManager(address account) external view returns (address);\n\n    /**\n     * @dev Sets the `implementer` contract as `account`'s implementer for\n     * `interfaceHash`.\n     *\n     * `account` being the zero address is an alias for the caller's address.\n     * The zero address can also be used in `implementer` to remove an old one.\n     *\n     * See {interfaceHash} to learn how these are created.\n     *\n     * Emits an {InterfaceImplementerSet} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the current manager for `_account`.\n     * - `_interfaceHash` must not be an {IERC165} interface id (i.e. it must not\n     * end in 28 zeroes).\n     * - `_implementer` must implement {IERC1820Implementer} and return true when\n     * queried for support, unless `implementer` is the caller. See\n     * {IERC1820Implementer-canImplementInterfaceForAddress}.\n     */\n    function setInterfaceImplementer(address _account, bytes32 _interfaceHash, address _implementer) external;\n\n    /**\n     * @dev Returns the implementer of `_interfaceHash` for `_account`. If no such\n     * implementer is registered, returns the zero address.\n     *\n     * If `_interfaceHash` is an {IERC165} interface id (i.e. it ends with 28\n     * zeroes), `_account` will be queried for support of it.\n     *\n     * `account` being the zero address is an alias for the caller's address.\n     */\n    function getInterfaceImplementer(address _account, bytes32 _interfaceHash) external view returns (address);\n\n    /**\n     * @dev Returns the interface hash for an `interfaceName`, as defined in the\n     * corresponding\n     * https://eips.ethereum.org/EIPS/eip-1820#interface-name[section of the EIP].\n     */\n    function interfaceHash(string calldata interfaceName) external pure returns (bytes32);\n\n    /**\n     *  @notice Updates the cache with whether the contract implements an ERC165 interface or not.\n     *  @param account Address of the contract for which to update the cache.\n     *  @param interfaceId ERC165 interface for which to update the cache.\n     */\n    function updateERC165Cache(address account, bytes4 interfaceId) external;\n\n    /**\n     *  @notice Checks whether a contract implements an ERC165 interface or not.\n     *  If the result is not cached a direct lookup on the contract address is performed.\n     *  If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling\n     *  {updateERC165Cache} with the contract address.\n     *  @param account Address of the contract to check.\n     *  @param interfaceId ERC165 interface to check.\n     *  @return True if `account` implements `interfaceId`, false otherwise.\n     */\n    function implementsERC165Interface(address account, bytes4 interfaceId) external view returns (bool);\n\n    /**\n     *  @notice Checks whether a contract implements an ERC165 interface or not without using nor updating the cache.\n     *  @param account Address of the contract to check.\n     *  @param interfaceId ERC165 interface to check.\n     *  @return True if `account` implements `interfaceId`, false otherwise.\n     */\n    function implementsERC165InterfaceNoCache(address account, bytes4 interfaceId) external view returns (bool);\n\n    event InterfaceImplementerSet(address indexed account, bytes32 indexed interfaceHash, address indexed implementer);\n\n    event ManagerChanged(address indexed account, address indexed newManager);\n}\n"
    },
    "contracts/zeppelin/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma abicoder v2;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/zeppelin/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma abicoder v2;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/zeppelin/token/ERC20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma abicoder v2;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve non-zero to non-zero allowance\"\n        );\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves.\n\n        // A Solidity high level call has three parts:\n        //  1. The target address is checked to verify it contains contract code\n        //  2. The call itself is made, and success asserted\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\n        // solhint-disable-next-line max-line-length\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/zeppelin/token/ERC777/IERC777.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma abicoder v2;\n\n/**\n * @dev Interface of the ERC777Token standard as defined in the EIP.\n *\n * This contract uses the\n * [ERC1820 registry standard](https://eips.ethereum.org/EIPS/eip-1820) to let\n * token holders and recipients react to token movements by using setting implementers\n * for the associated interfaces in said registry. See `IERC1820Registry` and\n * `ERC1820Implementer`.\n */\ninterface IERC777 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the smallest part of the token that is not divisible. This\n     * means all token operations (creation, movement and destruction) must have\n     * amounts that are a multiple of this number.\n     *\n     * For most token contracts, this value will equal 1.\n     */\n    function granularity() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by an account (`owner`).\n     */\n    function balanceOf(address owner) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * If send or receive hooks are registered for the caller and `recipient`,\n     * the corresponding functions will be called with `data` and empty\n     * `operatorData`. See `IERC777Sender` and `IERC777Recipient`.\n     *\n     * Emits a `Sent` event.\n     *\n     * Requirements\n     *\n     * - the caller must have at least `amount` tokens.\n     * - `recipient` cannot be the zero address.\n     * - if `recipient` is a contract, it must implement the `tokensReceived`\n     * interface.\n     */\n    function send(address recipient, uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev Destroys `amount` tokens from the caller's account, reducing the\n     * total supply.\n     *\n     * If a send hook is registered for the caller, the corresponding function\n     * will be called with `data` and empty `operatorData`. See `IERC777Sender`.\n     *\n     * Emits a `Burned` event.\n     *\n     * Requirements\n     *\n     * - the caller must have at least `amount` tokens.\n     */\n    function burn(uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev Returns true if an account is an operator of `tokenHolder`.\n     * Operators can send and burn tokens on behalf of their owners. All\n     * accounts are their own operator.\n     *\n     * See `operatorSend` and `operatorBurn`.\n     */\n    function isOperatorFor(address operator, address tokenHolder) external view returns (bool);\n\n    /**\n     * @dev Make an account an operator of the caller.\n     *\n     * See `isOperatorFor`.\n     *\n     * Emits an `AuthorizedOperator` event.\n     *\n     * Requirements\n     *\n     * - `operator` cannot be calling address.\n     */\n    function authorizeOperator(address operator) external;\n\n    /**\n     * @dev Make an account an operator of the caller.\n     *\n     * See `isOperatorFor` and `defaultOperators`.\n     *\n     * Emits a `RevokedOperator` event.\n     *\n     * Requirements\n     *\n     * - `operator` cannot be calling address.\n     */\n    function revokeOperator(address operator) external;\n\n    /**\n     * @dev Returns the list of default operators. These accounts are operators\n     * for all token holders, even if `authorizeOperator` was never called on\n     * them.\n     *\n     * This list is immutable, but individual holders may revoke these via\n     * `revokeOperator`, in which case `isOperatorFor` will return false.\n     */\n    function defaultOperators() external view returns (address[] memory);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient`. The caller must\n     * be an operator of `sender`.\n     *\n     * If send or receive hooks are registered for `sender` and `recipient`,\n     * the corresponding functions will be called with `data` and\n     * `operatorData`. See `IERC777Sender` and `IERC777Recipient`.\n     *\n     * Emits a `Sent` event.\n     *\n     * Requirements\n     *\n     * - `sender` cannot be the zero address.\n     * - `sender` must have at least `amount` tokens.\n     * - the caller must be an operator for `sender`.\n     * - `recipient` cannot be the zero address.\n     * - if `recipient` is a contract, it must implement the `tokensReceived`\n     * interface.\n     */\n    function operatorSend(\n        address sender,\n        address recipient,\n        uint256 amount,\n        bytes calldata data,\n        bytes calldata operatorData\n    ) external;\n\n    /**\n     * @dev Destoys `amount` tokens from `account`, reducing the total supply.\n     * The caller must be an operator of `account`.\n     *\n     * If a send hook is registered for `account`, the corresponding function\n     * will be called with `data` and `operatorData`. See `IERC777Sender`.\n     *\n     * Emits a `Burned` event.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     * - the caller must be an operator for `account`.\n     */\n    function operatorBurn(\n        address account,\n        uint256 amount,\n        bytes calldata data,\n        bytes calldata operatorData\n    ) external;\n\n    event Sent(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        bytes data,\n        bytes operatorData\n    );\n\n    function decimals() external returns (uint8);\n\n    event Minted(address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData);\n\n    event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);\n\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\n\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\n}\n"
    },
    "contracts/zeppelin/token/ERC777/IERC777Recipient.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma abicoder v2;\n\n/**\n * @dev Interface of the ERC777TokensRecipient standard as defined in the EIP.\n *\n * Accounts can be notified of `IERC777` tokens being sent to them by having a\n * contract implement this interface (contract holders can be their own\n * implementer) and registering it on the\n * [ERC1820 global registry](https://eips.ethereum.org/EIPS/eip-1820).\n *\n * See `IERC1820Registry` and `ERC1820Implementer`.\n */\ninterface IERC777Recipient {\n    /**\n     * @dev Called by an `IERC777` token contract whenever tokens are being\n     * moved or created into a registered account (`to`). The type of operation\n     * is conveyed by `from` being the zero address or not.\n     *\n     * This call occurs _after_ the token contract's state is updated, so\n     * `IERC777.balanceOf`, etc., can be used to query the post-operation state.\n     *\n     * This function may revert to prevent the operation from being executed.\n     */\n    function tokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint amount,\n        bytes calldata userData,\n        bytes calldata operatorData\n    ) external;\n}\n"
    },
    "contracts/zeppelin/upgradable/access/roles/UpgradablePauserRole.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma abicoder v2;\n\nimport \"../../Initializable.sol\";\n\nimport \"../../../GSN/Context.sol\";\nimport \"../../../access/Roles.sol\";\n\ncontract UpgradablePauserRole is Initializable, Context {\n    using Roles for Roles.Role;\n\n    event PauserAdded(address indexed account);\n    event PauserRemoved(address indexed account);\n\n    Roles.Role private _pausers;\n\n    function __PauserRol_init(address sender) public initializer {\n        if (!isPauser(sender)) {\n            _addPauser(sender);\n        }\n    }\n\n    modifier onlyPauser() {\n        require(isPauser(_msgSender()), \"PauserRole: caller doesn't have the role\");\n        _;\n    }\n\n    function isPauser(address account) public view returns (bool) {\n        return _pausers.has(account);\n    }\n\n    function addPauser(address account) public onlyPauser {\n        _addPauser(account);\n    }\n\n    function renouncePauser() public {\n        _removePauser(_msgSender());\n    }\n\n    function _addPauser(address account) internal {\n        _pausers.add(account);\n        emit PauserAdded(account);\n    }\n\n    function _removePauser(address account) internal {\n        _pausers.remove(account);\n        emit PauserRemoved(account);\n    }\n}\n"
    },
    "contracts/zeppelin/upgradable/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma abicoder v2;\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || !initialized, \"Contract instance is already initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}"
    },
    "contracts/zeppelin/upgradable/lifecycle/UpgradablePausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma abicoder v2;\n\nimport \"../Initializable.sol\";\n\nimport \"../../GSN/Context.sol\";\nimport \"../access/roles/UpgradablePauserRole.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\ncontract UpgradablePausable is Initializable, Context, UpgradablePauserRole {\n    /**\n     * @dev Emitted when the pause is triggered by a pauser (`account`).\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by a pauser (`account`).\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state. Assigns the Pauser role\n     * to the deployer.\n     */\n    function __Pausable_init(address sender) public initializer {\n        UpgradablePauserRole.__PauserRol_init(sender);\n\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     */\n    modifier whenNotPaused() {\n        require(!_paused, \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     */\n    modifier whenPaused() {\n        require(_paused, \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Called by a pauser to pause, triggers stopped state.\n     */\n    function pause() public onlyPauser whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Called by a pauser to unpause, returns to normal state.\n     */\n    function unpause() public onlyPauser whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "contracts/zeppelin/upgradable/ownership/UpgradableOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma abicoder v2;\n\nimport \"../Initializable.sol\";\n\nimport \"../../GSN/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\n * the owner.\n */\ncontract UpgradableOwnable is Initializable, Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function initialize(address sender) public initializer {\n        _owner = sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * > Note: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n\n}\n"
    },
    "contracts/zeppelin/upgradable/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma abicoder v2;\n\nimport \"../Initializable.sol\";\n\n/**\n * @title Helps contracts guard against reentrancy attacks.\n * @author Remco Bloemen <remco@2.com>, Eenae <alexey@mixbytes.io>\n * @dev If you mark a function `nonReentrant`, you should also\n * mark it `external`.\n */\ncontract ReentrancyGuard is Initializable {\n    /// @dev counter to allow mutex lock with only one SSTORE operation\n    uint256 private _guardCounter;\n\n    function initialize() public initializer {\n        // The counter starts at one to prevent changing it from zero to a non-zero\n        // value, which is a more expensive operation.\n        _guardCounter = 1;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _guardCounter += 1;\n        uint256 localCounter = _guardCounter;\n        _;\n        require(localCounter == _guardCounter, \"ReentrancyGuard: no reentrant allowed\");\n    }\n}"
    },
    "contracts/zeppelin/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma abicoder v2;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "evmVersion": "istanbul",
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}