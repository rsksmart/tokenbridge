{
  "language": "Solidity",
  "sources": {
    "contracts/AllowTokens/AllowTokens.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\npragma abicoder v2;\r\n\r\nimport \"../zeppelin/math/SafeMath.sol\";\r\n// Upgradables\r\nimport \"../zeppelin/upgradable/Initializable.sol\";\r\nimport \"../zeppelin/upgradable/ownership/UpgradableOwnable.sol\";\r\nimport \"../zeppelin/upgradable/ownership/UpgradableSecondary.sol\";\r\n\r\nimport \"../interface/IAllowTokens.sol\";\r\n\r\ncontract AllowTokens is Initializable, UpgradableOwnable, UpgradableSecondary, IAllowTokens {\r\n    using SafeMath for uint256;\r\n\r\n    address constant private NULL_ADDRESS = address(0);\r\n    uint256 constant public MAX_TYPES = 250;\r\n    mapping (address => TokenInfo) public allowedTokens;\r\n    mapping (uint256 => Limits) public typeLimits;\r\n    uint256 public smallAmountConfirmations;\r\n    uint256 public mediumAmountConfirmations;\r\n    uint256 public largeAmountConfirmations;\r\n    string[] public typeDescriptions;\r\n\r\n    event SetToken(address indexed _tokenAddress, uint256 _typeId);\r\n    event AllowedTokenRemoved(address indexed _tokenAddress);\r\n    event TokenTypeAdded(uint256 indexed _typeId, string _typeDescription);\r\n    event TypeLimitsChanged(uint256 indexed _typeId, Limits limits);\r\n    event UpdateTokensTransfered(address indexed _tokenAddress, uint256 _lastDay, uint256 _spentToday);\r\n    event ConfirmationsChanged(uint256 _smallAmountConfirmations, uint256 _mediumAmountConfirmations, uint256 _largeAmountConfirmations);\r\n\r\n\r\n    modifier notNull(address _address) {\r\n        require(_address != NULL_ADDRESS, \"AllowTokens: Null Address\");\r\n        _;\r\n    }\r\n\r\n    function initialize(\r\n        address _manager,\r\n        address _primary,\r\n        uint256 _smallAmountConfirmations,\r\n        uint256 _mediumAmountConfirmations,\r\n        uint256 _largeAmountConfirmations,\r\n        TypeInfo[] memory typesInfo) public initializer {\r\n        UpgradableOwnable.initialize(_manager);\r\n        UpgradableSecondary.__Secondary_init(_primary);\r\n        _setConfirmations(_smallAmountConfirmations, _mediumAmountConfirmations, _largeAmountConfirmations);\r\n        for(uint i = 0; i < typesInfo.length; i = i + 1) {\r\n            _addTokenType(typesInfo[i].description, typesInfo[i].limits);\r\n        }\r\n    }\r\n\r\n    function version() override external pure returns (string memory) {\r\n        return \"v1\";\r\n    }\r\n\r\n    function getInfoAndLimits(address token) override public view\r\n    returns (TokenInfo memory info, Limits memory limit) {\r\n        info = allowedTokens[token];\r\n        limit = typeLimits[info.typeId];\r\n        return (info, limit);\r\n    }\r\n    function calcMaxWithdraw(address token) override public view returns (uint256 maxWithdraw) {\r\n        (TokenInfo memory info, Limits memory limits) = getInfoAndLimits(token);\r\n        return _calcMaxWithdraw(info, limits);\r\n    }\r\n\r\n    function _calcMaxWithdraw(TokenInfo memory info, Limits memory limits) private view returns (uint256 maxWithdraw) {\r\n        // solium-disable-next-line security/no-block-members\r\n        if (block.timestamp > info.lastDay + 24 hours) { // solhint-disable-line not-rely-on-time\r\n            info.spentToday = 0;\r\n        }\r\n        if (limits.daily <= info.spentToday)\r\n            return 0;\r\n        maxWithdraw = limits.daily - info.spentToday;\r\n        if(maxWithdraw > limits.max)\r\n            maxWithdraw = limits.max;\r\n        return maxWithdraw;\r\n    }\r\n\r\n    // solium-disable-next-line max-len\r\n    function updateTokenTransfer(address token, uint256 amount) override external onlyPrimary {\r\n        (TokenInfo memory info, Limits memory limit) = getInfoAndLimits(token);\r\n        require(isTokenAllowed(token), \"AllowTokens: Not whitelisted\");\r\n        require(amount >= limit.min, \"AllowTokens: Lower than limit\");\r\n\r\n        // solium-disable-next-line security/no-block-members\r\n        if (block.timestamp > info.lastDay + 24 hours) { // solhint-disable-line not-rely-on-time\r\n            // solium-disable-next-line security/no-block-members\r\n            info.lastDay = block.timestamp; // solhint-disable-line not-rely-on-time\r\n            info.spentToday = 0;\r\n        }\r\n        uint maxWithdraw = _calcMaxWithdraw(info, limit);\r\n        require(amount <= maxWithdraw, \"AllowTokens: Exceeded limit\");\r\n        info.spentToday = info.spentToday.add(amount);\r\n        allowedTokens[token] = info;\r\n\r\n        emit UpdateTokensTransfered(token, info.lastDay, info.spentToday);\r\n    }\r\n\r\n    function _addTokenType(string memory description, Limits memory limits) private returns(uint256 len) {\r\n        require(bytes(description).length > 0, \"AllowTokens: Empty description\");\r\n        len = typeDescriptions.length;\r\n        require(len + 1 <= MAX_TYPES, \"AllowTokens: Reached MAX_TYPES\");\r\n        typeDescriptions.push(description);\r\n        _setTypeLimits(len, limits);\r\n        emit TokenTypeAdded(len, description);\r\n        return len;\r\n    }\r\n\r\n    function addTokenType(string calldata description, Limits calldata limits) external onlyOwner returns(uint256 len) {\r\n        return _addTokenType(description, limits);\r\n    }\r\n\r\n    function _setTypeLimits(uint256 typeId, Limits memory limits) private {\r\n        require(typeId < typeDescriptions.length, \"AllowTokens: bigger than typeDescriptions\");\r\n        require(limits.max >= limits.min, \"AllowTokens: maxTokens smaller than minTokens\");\r\n        require(limits.daily >= limits.max, \"AllowTokens: dailyLimit smaller than maxTokens\");\r\n        require(limits.mediumAmount > limits.min, \"AllowTokens: limits.mediumAmount smaller than min\");\r\n        require(limits.largeAmount > limits.mediumAmount, \"AllowTokens: limits.largeAmount smaller than mediumAmount\");\r\n        typeLimits[typeId] = limits;\r\n        emit TypeLimitsChanged(typeId, limits);\r\n    }\r\n\r\n    function setTypeLimits(uint256 typeId, Limits memory limits) public onlyOwner {\r\n        _setTypeLimits(typeId, limits);\r\n    }\r\n\r\n    function getTypesLimits() external view override returns(Limits[] memory limits) {\r\n        limits = new Limits[](typeDescriptions.length);\r\n        for (uint256 i = 0; i < typeDescriptions.length; i++) {\r\n            limits[i] = typeLimits[i];\r\n        }\r\n        return limits;\r\n    }\r\n\r\n    function getTypeDescriptionsLength() external view override returns(uint256) {\r\n        return typeDescriptions.length;\r\n    }\r\n\r\n    function getTypeDescriptions() external view override returns(string[] memory descriptions) {\r\n        descriptions = new string[](typeDescriptions.length);\r\n        for (uint256 i = 0; i < typeDescriptions.length; i++) {\r\n            descriptions[i] = typeDescriptions[i];\r\n        }\r\n        return descriptions;\r\n    }\r\n\r\n    function isTokenAllowed(address token) public view notNull(token) override returns (bool) {\r\n        return allowedTokens[token].allowed;\r\n    }\r\n\r\n    function setToken(address token, uint256 typeId) override public notNull(token) {\r\n        require(isOwner() || _msgSender() == primary(), \"AllowTokens: unauthorized sender\");\r\n        require(typeId < typeDescriptions.length, \"AllowTokens: typeId does not exist\");\r\n        TokenInfo memory info = allowedTokens[token];\r\n        info.allowed = true;\r\n        info.typeId = typeId;\r\n        allowedTokens[token] = info;\r\n        emit SetToken(token, typeId);\r\n    }\r\n\r\n    function setMultipleTokens(TokensAndType[] calldata tokensAndTypes) external onlyOwner {\r\n        require(tokensAndTypes.length > 0, \"AllowTokens: empty tokens\");\r\n        for(uint256 i = 0; i < tokensAndTypes.length; i = i + 1) {\r\n            setToken(tokensAndTypes[i].token, tokensAndTypes[i].typeId);\r\n        }\r\n    }\r\n\r\n    function removeAllowedToken(address token) external notNull(token) onlyOwner {\r\n        TokenInfo memory info = allowedTokens[token];\r\n        require(info.allowed, \"AllowTokens: Not Allowed\");\r\n        info.allowed = false;\r\n        allowedTokens[token] = info;\r\n        emit AllowedTokenRemoved(token);\r\n    }\r\n\r\n    function setConfirmations(\r\n        uint256 _smallAmountConfirmations,\r\n        uint256 _mediumAmountConfirmations,\r\n        uint256 _largeAmountConfirmations) external onlyOwner {\r\n        _setConfirmations(_smallAmountConfirmations, _mediumAmountConfirmations, _largeAmountConfirmations);\r\n    }\r\n\r\n    function _setConfirmations(\r\n        uint256 _smallAmountConfirmations,\r\n        uint256 _mediumAmountConfirmations,\r\n        uint256 _largeAmountConfirmations) private {\r\n        require(_smallAmountConfirmations <= _mediumAmountConfirmations, \"AllowTokens: small bigger than medium confirmations\");\r\n        require(_mediumAmountConfirmations <= _largeAmountConfirmations, \"AllowTokens: medium bigger than large confirmations\");\r\n        smallAmountConfirmations = _smallAmountConfirmations;\r\n        mediumAmountConfirmations = _mediumAmountConfirmations;\r\n        largeAmountConfirmations = _largeAmountConfirmations;\r\n        emit ConfirmationsChanged(_smallAmountConfirmations, _mediumAmountConfirmations, _largeAmountConfirmations);\r\n    }\r\n\r\n    function getConfirmations() external view override\r\n    returns (uint256 smallAmount, uint256 mediumAmount, uint256 largeAmount) {\r\n        return (smallAmountConfirmations, mediumAmountConfirmations, largeAmountConfirmations);\r\n    }\r\n\r\n}\r\n"
    },
    "contracts/zeppelin/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\npragma abicoder v2;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n"
    },
    "contracts/zeppelin/upgradable/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\npragma abicoder v2;\r\n\r\n/**\r\n * @title Initializable\r\n *\r\n * @dev Helper contract to support initializer functions. To use it, replace\r\n * the constructor with a function that has the `initializer` modifier.\r\n * WARNING: Unlike constructors, initializer functions must be manually\r\n * invoked. This applies both to deploying an Initializable contract, as well\r\n * as extending an Initializable contract via inheritance.\r\n * WARNING: When used with inheritance, manual care must be taken to not invoke\r\n * a parent initializer twice, or ensure that all initializers are idempotent,\r\n * because this is not dealt with automatically as with constructors.\r\n */\r\ncontract Initializable {\r\n\r\n  /**\r\n   * @dev Indicates that the contract has been initialized.\r\n   */\r\n  bool private initialized;\r\n\r\n  /**\r\n   * @dev Indicates that the contract is in the process of being initialized.\r\n   */\r\n  bool private initializing;\r\n\r\n  /**\r\n   * @dev Modifier to use in the initializer function of a contract.\r\n   */\r\n  modifier initializer() {\r\n    require(initializing || !initialized, \"Contract instance is already initialized\");\r\n\r\n    bool isTopLevelCall = !initializing;\r\n    if (isTopLevelCall) {\r\n      initializing = true;\r\n      initialized = true;\r\n    }\r\n\r\n    _;\r\n\r\n    if (isTopLevelCall) {\r\n      initializing = false;\r\n    }\r\n  }\r\n\r\n  // Reserved storage space to allow for layout changes in the future.\r\n  uint256[50] private ______gap;\r\n}"
    },
    "contracts/zeppelin/upgradable/ownership/UpgradableOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\npragma abicoder v2;\r\n\r\nimport \"../Initializable.sol\";\r\n\r\nimport \"../../GSN/Context.sol\";\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract UpgradableOwnable is Initializable, Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    function initialize(address sender) public initializer {\r\n        _owner = sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return _msgSender() == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * > Note: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n\r\n}\r\n"
    },
    "contracts/zeppelin/upgradable/ownership/UpgradableSecondary.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\npragma abicoder v2;\r\n\r\nimport \"../Initializable.sol\";\r\n\r\nimport \"../../GSN/Context.sol\";\r\n\r\n/**\r\n * @dev A Secondary contract can only be used by its primary account (the one that created it).\r\n */\r\ncontract UpgradableSecondary is Initializable, Context {\r\n    address private _primary;\r\n\r\n    /**\r\n     * @dev Emitted when the primary contract changes.\r\n     */\r\n    event PrimaryTransferred(\r\n        address recipient\r\n    );\r\n\r\n    /**\r\n     * @dev Sets the primary account to the one that is creating the Secondary contract.\r\n     */\r\n    function __Secondary_init(address sender) public initializer {\r\n        _primary = sender;\r\n        emit PrimaryTransferred(_primary);\r\n    }\r\n\r\n    /**\r\n     * @dev Reverts if called from any account other than the primary.\r\n     */\r\n    modifier onlyPrimary() {\r\n        require(_msgSender() == _primary, \"Secondary: caller is not the primary account\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return the address of the primary.\r\n     */\r\n    function primary() public view returns (address) {\r\n        return _primary;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers contract to a new primary.\r\n     * @param recipient The address of new primary.\r\n     */\r\n    function transferPrimary(address recipient) public onlyPrimary {\r\n        require(recipient != address(0), \"Secondary: new primary is the zero address\");\r\n        _primary = recipient;\r\n        emit PrimaryTransferred(recipient);\r\n    }\r\n\r\n}"
    },
    "contracts/interface/IAllowTokens.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\npragma abicoder v2;\r\ninterface IAllowTokens {\r\n\r\n    struct Limits {\r\n        uint256 min;\r\n        uint256 max;\r\n        uint256 daily;\r\n        uint256 mediumAmount;\r\n        uint256 largeAmount;\r\n    }\r\n\r\n    struct TokenInfo {\r\n        bool allowed;\r\n        uint256 typeId;\r\n        uint256 spentToday;\r\n        uint256 lastDay;\r\n    }\r\n\r\n    struct TypeInfo {\r\n        string description;\r\n        Limits limits;\r\n    }\r\n\r\n    struct TokensAndType {\r\n        address token;\r\n        uint256 typeId;\r\n    }\r\n\r\n    function version() external pure returns (string memory);\r\n\r\n    function getInfoAndLimits(address token) external view returns (TokenInfo memory info, Limits memory limit);\r\n\r\n    function calcMaxWithdraw(address token) external view returns (uint256 maxWithdraw);\r\n\r\n    function getTypesLimits() external view returns(Limits[] memory limits);\r\n\r\n    function getTypeDescriptionsLength() external view returns(uint256);\r\n\r\n    function getTypeDescriptions() external view returns(string[] memory descriptions);\r\n\r\n    function setToken(address token, uint256 typeId) external;\r\n\r\n    function getConfirmations() external view returns (uint256 smallAmount, uint256 mediumAmount, uint256 largeAmount);\r\n\r\n    function isTokenAllowed(address token) external view returns (bool);\r\n\r\n    function updateTokenTransfer(address token, uint256 amount) external;\r\n}"
    },
    "contracts/zeppelin/GSN/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\npragma abicoder v2;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract  Context {\r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n"
    },
    "contracts/nftbridge/NFTBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\npragma abicoder v2;\r\n\r\n// Import base Initializable contract\r\nimport \"../zeppelin/upgradable/Initializable.sol\";\r\n// Import interface and library from OpenZeppelin contracts\r\nimport \"../zeppelin/upgradable/utils/ReentrancyGuard.sol\";\r\nimport \"../zeppelin/upgradable/lifecycle/UpgradablePausable.sol\";\r\nimport \"../zeppelin/upgradable/ownership/UpgradableOwnable.sol\";\r\n\r\nimport \"../zeppelin/introspection/IERC1820Registry.sol\";\r\nimport \"../zeppelin/token/ERC20/IERC20.sol\";\r\nimport \"../zeppelin/token/ERC20/SafeERC20.sol\";\r\nimport \"../zeppelin/token/ERC721/IERC721.sol\";\r\nimport \"../zeppelin/token/ERC721/IERC721Metadata.sol\";\r\nimport \"../zeppelin/token/ERC721/IERC721Enumerable.sol\";\r\nimport \"../zeppelin/token/ERC721/IERC721Receiver.sol\";\r\nimport \"../zeppelin/token/ERC721/ERC721Burnable.sol\";\r\nimport \"../zeppelin/utils/Address.sol\";\r\nimport \"../zeppelin/math/SafeMath.sol\";\r\n\r\nimport \"../lib/LibEIP712.sol\";\r\nimport \"../lib/LibUtils.sol\";\r\n\r\nimport \"./INFTBridge.sol\";\r\nimport \"./ISideNFTToken.sol\";\r\nimport \"./ISideNFTTokenFactory.sol\";\r\nimport \"../interface/IAllowTokens.sol\";\r\nimport \"../interface/IWrapped.sol\";\r\n\r\n// solhint-disable-next-line max-states-count\r\ncontract NFTBridge is\r\n  Initializable,\r\n  INFTBridge,\r\n  UpgradablePausable,\r\n  UpgradableOwnable,\r\n  ReentrancyGuard,\r\n  IERC721Receiver {\r\n  using SafeMath for uint256;\r\n  using SafeERC20 for IERC20;\r\n  using Address for address;\r\n\r\n  address internal constant NULL_ADDRESS = address(0);\r\n  bytes32 internal constant NULL_HASH = bytes32(0);\r\n  IERC1820Registry internal constant ERC1820 =\r\n      IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\r\n\r\n  address payable internal federation;\r\n  uint256 internal fixedFee;\r\n  string public symbolPrefix;\r\n\r\n  mapping(address => address) public sideTokenAddressByOriginalTokenAddress;\r\n  mapping(address => address) public originalTokenAddressBySideTokenAddress;\r\n  mapping(address => bool) public isAddressFromCrossedOriginalToken; // address => returns true if it's an original token address crossed previously (whether it comes from main or side chain)\r\n  mapping(bytes32 => bool) public claimed; // transactionDataHash => true // previously named processed\r\n  IAllowTokens public allowTokens;\r\n  ISideNFTTokenFactory public sideTokenFactory;\r\n  bool public isUpgrading;\r\n  mapping(bytes32 => bytes32) public transactionDataHashes; // transactionHash => transactionDataHash\r\n\r\n  event AllowTokensChanged(address _newAllowTokens);\r\n  event FederationChanged(address _newFederation);\r\n  event SideTokenFactoryChanged(address _newSideNFTTokenFactory);\r\n  event Upgrading(bool _isUpgrading);\r\n\r\n  function initialize(\r\n    address _manager,\r\n    address payable _federation,\r\n    address _allowTokens,\r\n    address _sideTokenFactory,\r\n    string memory _symbolPrefix\r\n  ) public initializer {\r\n    UpgradableOwnable.initialize(_manager);\r\n    UpgradablePausable.__Pausable_init(_manager);\r\n    symbolPrefix = _symbolPrefix;\r\n    allowTokens = IAllowTokens(_allowTokens);\r\n    sideTokenFactory = ISideNFTTokenFactory(_sideTokenFactory);\r\n    federation = _federation;\r\n    ERC1820.setInterfaceImplementer(\r\n      address(this),\r\n      0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b,\r\n      address(this)\r\n    );\r\n  }\r\n\r\n  function version() external pure override returns (string memory) {\r\n    return \"v1\";\r\n  }\r\n\r\n  modifier whenNotUpgrading() {\r\n    require(!isUpgrading, \"Bridge: Upgrading\");\r\n    _;\r\n  }\r\n\r\n  function acceptTransfer(\r\n    address _tokenAddress,\r\n    address payable _from,\r\n    address payable _to,\r\n    uint256 _tokenId,\r\n    bytes32 _blockHash,\r\n    bytes32 _transactionHash,\r\n    uint32 _logIndex\r\n  ) external whenNotPaused nonReentrant override {\r\n    require(_msgSender() == federation, \"NFTBridge: Not Federation\");\r\n    require(\r\n      isAddressFromCrossedOriginalToken[_tokenAddress] ||\r\n          sideTokenAddressByOriginalTokenAddress[_tokenAddress] != NULL_ADDRESS,\r\n      \"NFTBridge: Unknown token\"\r\n    );\r\n    require(_to != NULL_ADDRESS, \"NFTBridge: Null To\");\r\n    require(_from != NULL_ADDRESS, \"NFTBridge: Null From\");\r\n    require(_blockHash != NULL_HASH, \"NFTBridge: Null BlockHash\");\r\n    require(_transactionHash != NULL_HASH, \"NFTBridge: Null TxHash\");\r\n    require(\r\n      transactionDataHashes[_transactionHash] == bytes32(0),\r\n      \"NFTBridge: Already accepted\"\r\n    );\r\n\r\n    bytes32 _transactionDataHash = getTransactionDataHash(\r\n      _to,\r\n      _from,\r\n      _tokenId,\r\n      _tokenAddress,\r\n      _blockHash,\r\n      _transactionHash,\r\n      _logIndex\r\n    );\r\n    // Do not remove, claimed will also have transactions previously processed using older bridge versions\r\n    require(!claimed[_transactionDataHash], \"NFTBridge: Already claimed\");\r\n\r\n    transactionDataHashes[_transactionHash] = _transactionDataHash;\r\n//    tokenAddressByTransactionHash[_transactionHash] = _tokenAddress;\r\n//    senderAddresses[_transactionHash] = _from;\r\n\r\n    emit AcceptedNFTCrossTransfer(\r\n      _transactionHash,\r\n      _tokenAddress,\r\n      _to,\r\n      _from,\r\n      _tokenId,\r\n      _blockHash,\r\n      _logIndex\r\n    );\r\n  }\r\n\r\n  function createSideNFTToken(\r\n    address _originalTokenAddress,\r\n    string calldata _originalTokenSymbol,\r\n    string calldata _originalTokenName,\r\n    string calldata _baseURI,\r\n    string calldata _contractURI\r\n  ) external onlyOwner {\r\n    require(_originalTokenAddress != NULL_ADDRESS, \"NFTBridge: Null original token address\");\r\n    address sideTokenAddress = sideTokenAddressByOriginalTokenAddress[_originalTokenAddress];\r\n    require(sideTokenAddress == NULL_ADDRESS, \"NFTBridge: Side token already exists\");\r\n    string memory sideTokenSymbol = string(abi.encodePacked(symbolPrefix, _originalTokenSymbol));\r\n\r\n    // Create side token\r\n    sideTokenAddress = sideTokenFactory.createSideNFTToken(_originalTokenName, sideTokenSymbol, _baseURI, _contractURI);\r\n\r\n    sideTokenAddressByOriginalTokenAddress[_originalTokenAddress] = sideTokenAddress;\r\n    originalTokenAddressBySideTokenAddress[sideTokenAddress] = _originalTokenAddress;\r\n    emit NewSideNFTToken(sideTokenAddress, _originalTokenAddress, sideTokenSymbol);\r\n  }\r\n\r\n  function claim(NFTClaimData calldata _claimData) external override {\r\n    _claim(_claimData, _claimData.to);\r\n  }\r\n\r\n  function claimFallback(NFTClaimData calldata _claimData) external override {\r\n    require(_msgSender() == _claimData.from, \"NFTBridge: invalid sender\");\r\n    _claim(_claimData, _msgSender());\r\n  }\r\n\r\n  function _claim(\r\n    NFTClaimData calldata _claimData,\r\n    address payable _receiver\r\n  ) internal {\r\n    address tokenAddress = _claimData.tokenAddress;\r\n    uint256 tokenId = _claimData.tokenId;\r\n\r\n    bytes32 transactionDataHash = getTransactionDataHash(\r\n      _claimData.to,\r\n      _claimData.from,\r\n      tokenId,\r\n      tokenAddress,\r\n      _claimData.blockHash,\r\n      _claimData.transactionHash,\r\n      _claimData.logIndex\r\n    );\r\n    require(\r\n      transactionDataHashes[_claimData.transactionHash] == transactionDataHash,\r\n      \"NFTBridge: Wrong txDataHash\"\r\n    );\r\n    require(!claimed[transactionDataHash], \"NFTBridge: Already claimed\");\r\n\r\n    claimed[transactionDataHash] = true;\r\n    bool isClaimBeingRequestedInMainChain = isAddressFromCrossedOriginalToken[tokenAddress];\r\n    if (isClaimBeingRequestedInMainChain) {\r\n      IERC721(tokenAddress).safeTransferFrom(address(this), _receiver, tokenId);\r\n    } else {\r\n      address sideTokenAddress = sideTokenAddressByOriginalTokenAddress[tokenAddress];\r\n      ISideNFTToken(sideTokenAddress).mint(_receiver, tokenId);\r\n    }\r\n\r\n    emit ClaimedNFTToken(\r\n      _claimData.transactionHash,\r\n      tokenAddress,\r\n      _claimData.to,\r\n      _claimData.from,\r\n      _claimData.tokenId,\r\n      _claimData.blockHash,\r\n      _claimData.logIndex,\r\n      _receiver\r\n    );\r\n  }\r\n\r\n  function getTokenCreator(address tokenAddress, uint256 tokenId) public view returns (address) {\r\n    (bool success, bytes memory data) = tokenAddress.staticcall(abi.encodeWithSignature(\"creator()\"));\r\n    if (success) {\r\n      return abi.decode(data, (address));\r\n    }\r\n\r\n    return IERC721(tokenAddress).ownerOf(tokenId);\r\n  }\r\n\r\n  /**\r\n    * ERC-20 tokens approve and transferFrom pattern\r\n    * See https://eips.ethereum.org/EIPS/eip-20#transferfrom\r\n    */\r\n  function receiveTokensTo(\r\n    address tokenAddress,\r\n    address to,\r\n    uint256 tokenId\r\n  ) public payable override {\r\n    address tokenCreator = getTokenCreator(tokenAddress, tokenId);\r\n\r\n    address payable sender = _msgSender();\r\n    // Transfer the tokens on IERC721, they should be already Approved for the bridge Address to use them\r\n    IERC721(tokenAddress).transferFrom(sender, address(this), tokenId);\r\n\r\n    crossTokens(tokenAddress, to, tokenCreator, \"\", tokenId);\r\n\r\n    if (fixedFee > 0) {\r\n      require(msg.value >= fixedFee, \"NFTBridge: value is smaller than fixed fee\");\r\n\r\n      // Send the payment to the MultiSig of the Federation\r\n      federation.transfer(fixedFee);\r\n      if (msg.value > fixedFee) { // refund of unused value\r\n        sender.transfer(msg.value.sub(fixedFee));\r\n      }\r\n    }\r\n  }\r\n\r\n  function crossTokens(\r\n    address tokenAddress,\r\n    address to,\r\n    address tokenCreator,\r\n    bytes memory userData,\r\n    uint256 tokenId\r\n  ) internal whenNotUpgrading whenNotPaused nonReentrant {\r\n    isAddressFromCrossedOriginalToken[tokenAddress] = true;\r\n\r\n    IERC721Enumerable enumerable = IERC721Enumerable(tokenAddress);\r\n    IERC721Metadata metadataIERC = IERC721Metadata(tokenAddress);\r\n    string memory tokenURI = metadataIERC.tokenURI(tokenId);\r\n\r\n    address originalTokenAddress = tokenAddress;\r\n    if (originalTokenAddressBySideTokenAddress[tokenAddress] != NULL_ADDRESS) {\r\n      originalTokenAddress = originalTokenAddressBySideTokenAddress[tokenAddress];\r\n      ERC721Burnable(tokenAddress).burn(tokenId);\r\n    }\r\n\r\n    emit Cross(\r\n      originalTokenAddress,\r\n      _msgSender(),\r\n      to,\r\n      tokenCreator,\r\n      userData,\r\n      enumerable.totalSupply(),\r\n      tokenId,\r\n      tokenURI\r\n    );\r\n  }\r\n\r\n  function getTransactionDataHash(\r\n    address _to,\r\n    address _from,\r\n    uint256 _tokenId,\r\n    address _tokenAddress,\r\n    bytes32 _blockHash,\r\n    bytes32 _transactionHash,\r\n    uint32 _logIndex\r\n  ) public pure override returns (bytes32) {\r\n    return keccak256(\r\n      abi.encodePacked(\r\n        _blockHash,\r\n        _transactionHash,\r\n        _to,\r\n        _from,\r\n        _tokenId,\r\n        _tokenAddress,\r\n        _logIndex\r\n      )\r\n    );\r\n  }\r\n\r\n  function setFixedFee(uint256 amount) external onlyOwner {\r\n    fixedFee = amount;\r\n    emit FixedFeeNFTChanged(fixedFee);\r\n  }\r\n\r\n  function getFixedFee() external view override returns (uint256) {\r\n    return fixedFee;\r\n  }\r\n\r\n  function changeFederation(address payable newFederation) external onlyOwner {\r\n    require(newFederation != NULL_ADDRESS, \"NFTBridge: Federation is empty\");\r\n    federation = newFederation;\r\n    emit FederationChanged(federation);\r\n  }\r\n\r\n  function changeAllowTokens(address newAllowTokens) external onlyOwner {\r\n    require(newAllowTokens != NULL_ADDRESS, \"NFTBridge: AllowTokens is empty\");\r\n    allowTokens = IAllowTokens(newAllowTokens);\r\n    emit AllowTokensChanged(newAllowTokens);\r\n  }\r\n\r\n  function getFederation() external view returns (address) {\r\n    return federation;\r\n  }\r\n\r\n  function changeSideTokenFactory(address newSideNFTTokenFactory) external onlyOwner {\r\n    require(\r\n      newSideNFTTokenFactory != NULL_ADDRESS,\r\n      \"NFTBridge: empty SideTokenFactory\"\r\n    );\r\n    sideTokenFactory = ISideNFTTokenFactory(newSideNFTTokenFactory);\r\n    emit SideTokenFactoryChanged(newSideNFTTokenFactory);\r\n  }\r\n\r\n  function setUpgrading(bool _isUpgrading) external onlyOwner {\r\n    isUpgrading = _isUpgrading;\r\n    emit Upgrading(isUpgrading);\r\n  }\r\n\r\n  function hasCrossed(bytes32 transactionHash) public view returns (bool) {\r\n    return transactionDataHashes[transactionHash] != bytes32(0);\r\n  }\r\n\r\n  function hasBeenClaimed(bytes32 transactionHash) public view returns (bool) {\r\n    return claimed[transactionDataHashes[transactionHash]];\r\n  }\r\n\r\n  /**\r\n    * Always returns `IERC721Receiver.onERC721Received.selector`.\r\n    */\r\n  function onERC721Received(\r\n    address,\r\n    address,\r\n    uint256,\r\n    bytes memory\r\n  ) public virtual override returns (bytes4) {\r\n    return this.onERC721Received.selector;\r\n  }\r\n\r\n}\r\n"
    },
    "contracts/zeppelin/upgradable/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\npragma abicoder v2;\r\n\r\nimport \"../Initializable.sol\";\r\n\r\n/**\r\n * @title Helps contracts guard against reentrancy attacks.\r\n * @author Remco Bloemen <remco@2π.com>, Eenae <alexey@mixbytes.io>\r\n * @dev If you mark a function `nonReentrant`, you should also\r\n * mark it `external`.\r\n */\r\ncontract ReentrancyGuard is Initializable {\r\n    /// @dev counter to allow mutex lock with only one SSTORE operation\r\n    uint256 private _guardCounter;\r\n\r\n    function initialize() public initializer {\r\n        // The counter starts at one to prevent changing it from zero to a non-zero\r\n        // value, which is a more expensive operation.\r\n        _guardCounter = 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _guardCounter += 1;\r\n        uint256 localCounter = _guardCounter;\r\n        _;\r\n        require(localCounter == _guardCounter, \"ReentrancyGuard: no reentrant allowed\");\r\n    }\r\n}"
    },
    "contracts/zeppelin/upgradable/lifecycle/UpgradablePausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\npragma abicoder v2;\r\n\r\nimport \"../Initializable.sol\";\r\n\r\nimport \"../../GSN/Context.sol\";\r\nimport \"../access/roles/UpgradablePauserRole.sol\";\r\n\r\n/**\r\n * @dev Contract module which allows children to implement an emergency stop\r\n * mechanism that can be triggered by an authorized account.\r\n *\r\n * This module is used through inheritance. It will make available the\r\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\r\n * the functions of your contract. Note that they will not be pausable by\r\n * simply including this module, only once the modifiers are put in place.\r\n */\r\ncontract UpgradablePausable is Initializable, Context, UpgradablePauserRole {\r\n    /**\r\n     * @dev Emitted when the pause is triggered by a pauser (`account`).\r\n     */\r\n    event Paused(address account);\r\n\r\n    /**\r\n     * @dev Emitted when the pause is lifted by a pauser (`account`).\r\n     */\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    /**\r\n     * @dev Initializes the contract in unpaused state. Assigns the Pauser role\r\n     * to the deployer.\r\n     */\r\n    function __Pausable_init(address sender) public initializer {\r\n        UpgradablePauserRole.__PauserRol_init(sender);\r\n\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the contract is paused, and false otherwise.\r\n     */\r\n    function paused() public view returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!_paused, \"Pausable: paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     */\r\n    modifier whenPaused() {\r\n        require(_paused, \"Pausable: not paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Called by a pauser to pause, triggers stopped state.\r\n     */\r\n    function pause() public onlyPauser whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Called by a pauser to unpause, returns to normal state.\r\n     */\r\n    function unpause() public onlyPauser whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(_msgSender());\r\n    }\r\n}\r\n"
    },
    "contracts/zeppelin/introspection/IERC1820Registry.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\npragma abicoder v2;\r\n\r\n/**\r\n * @dev Interface of the global ERC1820 Registry, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-1820[EIP]. Accounts may register\r\n * implementers for interfaces in this registry, as well as query support.\r\n *\r\n * Implementers may be shared by multiple accounts, and can also implement more\r\n * than a single interface for each account. Contracts can implement interfaces\r\n * for themselves, but externally-owned accounts (EOA) must delegate this to a\r\n * contract.\r\n *\r\n * {IERC165} interfaces can also be queried via the registry.\r\n *\r\n * For an in-depth explanation and source code analysis, see the EIP text.\r\n */\r\ninterface IERC1820Registry {\r\n    /**\r\n     * @dev Sets `newManager` as the manager for `account`. A manager of an\r\n     * account is able to set interface implementers for it.\r\n     *\r\n     * By default, each account is its own manager. Passing a value of `0x0` in\r\n     * `newManager` will reset the manager to this initial state.\r\n     *\r\n     * Emits a {ManagerChanged} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must be the current manager for `account`.\r\n     */\r\n    function setManager(address account, address newManager) external;\r\n\r\n    /**\r\n     * @dev Returns the manager for `account`.\r\n     *\r\n     * See {setManager}.\r\n     */\r\n    function getManager(address account) external view returns (address);\r\n\r\n    /**\r\n     * @dev Sets the `implementer` contract as `account`'s implementer for\r\n     * `interfaceHash`.\r\n     *\r\n     * `account` being the zero address is an alias for the caller's address.\r\n     * The zero address can also be used in `implementer` to remove an old one.\r\n     *\r\n     * See {interfaceHash} to learn how these are created.\r\n     *\r\n     * Emits an {InterfaceImplementerSet} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must be the current manager for `_account`.\r\n     * - `_interfaceHash` must not be an {IERC165} interface id (i.e. it must not\r\n     * end in 28 zeroes).\r\n     * - `_implementer` must implement {IERC1820Implementer} and return true when\r\n     * queried for support, unless `implementer` is the caller. See\r\n     * {IERC1820Implementer-canImplementInterfaceForAddress}.\r\n     */\r\n    function setInterfaceImplementer(address _account, bytes32 _interfaceHash, address _implementer) external;\r\n\r\n    /**\r\n     * @dev Returns the implementer of `_interfaceHash` for `_account`. If no such\r\n     * implementer is registered, returns the zero address.\r\n     *\r\n     * If `_interfaceHash` is an {IERC165} interface id (i.e. it ends with 28\r\n     * zeroes), `_account` will be queried for support of it.\r\n     *\r\n     * `account` being the zero address is an alias for the caller's address.\r\n     */\r\n    function getInterfaceImplementer(address _account, bytes32 _interfaceHash) external view returns (address);\r\n\r\n    /**\r\n     * @dev Returns the interface hash for an `interfaceName`, as defined in the\r\n     * corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-1820#interface-name[section of the EIP].\r\n     */\r\n    function interfaceHash(string calldata interfaceName) external pure returns (bytes32);\r\n\r\n    /**\r\n     *  @notice Updates the cache with whether the contract implements an ERC165 interface or not.\r\n     *  @param account Address of the contract for which to update the cache.\r\n     *  @param interfaceId ERC165 interface for which to update the cache.\r\n     */\r\n    function updateERC165Cache(address account, bytes4 interfaceId) external;\r\n\r\n    /**\r\n     *  @notice Checks whether a contract implements an ERC165 interface or not.\r\n     *  If the result is not cached a direct lookup on the contract address is performed.\r\n     *  If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling\r\n     *  {updateERC165Cache} with the contract address.\r\n     *  @param account Address of the contract to check.\r\n     *  @param interfaceId ERC165 interface to check.\r\n     *  @return True if `account` implements `interfaceId`, false otherwise.\r\n     */\r\n    function implementsERC165Interface(address account, bytes4 interfaceId) external view returns (bool);\r\n\r\n    /**\r\n     *  @notice Checks whether a contract implements an ERC165 interface or not without using nor updating the cache.\r\n     *  @param account Address of the contract to check.\r\n     *  @param interfaceId ERC165 interface to check.\r\n     *  @return True if `account` implements `interfaceId`, false otherwise.\r\n     */\r\n    function implementsERC165InterfaceNoCache(address account, bytes4 interfaceId) external view returns (bool);\r\n\r\n    event InterfaceImplementerSet(address indexed account, bytes32 indexed interfaceHash, address indexed implementer);\r\n\r\n    event ManagerChanged(address indexed account, address indexed newManager);\r\n}\r\n"
    },
    "contracts/zeppelin/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\npragma abicoder v2;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n"
    },
    "contracts/zeppelin/token/ERC20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\npragma abicoder v2;\r\n\r\nimport \"./IERC20.sol\";\r\nimport \"../../math/SafeMath.sol\";\r\nimport \"../../utils/Address.sol\";\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n        // solhint-disable-next-line max-line-length\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/zeppelin/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\n\r\nimport \"../../introspection/IERC165.sol\";\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n     */\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n     */\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in ``owner``'s account.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}\r\n     */\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n    /**\r\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n      *\r\n      * Requirements:\r\n      *\r\n      * - `from` cannot be the zero address.\r\n      * - `to` cannot be the zero address.\r\n      * - `tokenId` token must exist and be owned by `from`.\r\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n      *\r\n      * Emits a {Transfer} event.\r\n      */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\r\n}\r\n"
    },
    "contracts/zeppelin/token/ERC721/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\n\r\nimport \"./IERC721.sol\";\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ninterface IERC721Metadata is IERC721 {\r\n\r\n    /**\r\n     * @dev Returns the token collection name.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the token collection symbol.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\r\n     */\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n"
    },
    "contracts/zeppelin/token/ERC721/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\n\r\nimport \"./IERC721.sol\";\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ninterface IERC721Enumerable is IERC721 {\r\n\r\n    /**\r\n     * @dev Returns the total amount of tokens stored by the contract.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\r\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\r\n     */\r\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\r\n\r\n    /**\r\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\r\n     * Use along with {totalSupply} to enumerate all tokens.\r\n     */\r\n    function tokenByIndex(uint256 index) external view returns (uint256);\r\n}\r\n"
    },
    "contracts/zeppelin/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ninterface IERC721Receiver {\r\n    /**\r\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\r\n     * by `operator` from `from`, this function is called.\r\n     *\r\n     * It must return its Solidity selector to confirm the token transfer.\r\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\r\n     *\r\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\r\n     */\r\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\r\n}\r\n"
    },
    "contracts/zeppelin/token/ERC721/ERC721Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\n\r\nimport \"../../GSN/Context.sol\";\r\nimport \"./ERC721.sol\";\r\n\r\n/**\r\n * @title ERC721 Burnable Token\r\n * @dev ERC721 Token that can be irreversibly burned (destroyed).\r\n */\r\nabstract contract ERC721Burnable is Context, ERC721 {\r\n    /**\r\n     * @dev Burns `tokenId`. See {ERC721-_burn}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own `tokenId` or be an approved operator.\r\n     */\r\n    function burn(uint256 tokenId) public virtual {\r\n        //solhint-disable-next-line max-line-length\r\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721Burnable: caller is not owner nor approved\");\r\n        _burn(tokenId);\r\n    }\r\n}\r\n"
    },
    "contracts/zeppelin/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\npragma abicoder v2;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/lib/LibEIP712.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\npragma abicoder v2;\r\n\r\n// https://github.com/0xProject/0x-monorepo/blob/development/contracts/utils/contracts/src/LibEIP712.sol\r\nlibrary LibEIP712 {\r\n\r\n    // Hash of the EIP712 Domain Separator Schema\r\n    // keccak256(abi.encodePacked(\r\n    //     \"EIP712Domain(\",\r\n    //     \"string name,\",\r\n    //     \"string version,\",\r\n    //     \"uint256 chainId,\",\r\n    //     \"address verifyingContract\",\r\n    //     \")\"\r\n    // ))\r\n    bytes32 constant internal _EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\r\n\r\n    /// @dev Calculates a EIP712 domain separator.\r\n    /// @param name The EIP712 domain name.\r\n    /// @param version The EIP712 domain version.\r\n    /// @param verifyingContract The EIP712 verifying contract.\r\n    /// @return result EIP712 domain separator.\r\n    function hashEIP712Domain(\r\n        string memory name,\r\n        string memory version,\r\n        uint256 chainId,\r\n        address verifyingContract\r\n    )\r\n        internal\r\n        pure\r\n        returns (bytes32 result)\r\n    {\r\n        bytes32 schemaHash = _EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH;\r\n\r\n        // Assembly for more efficient computing:\r\n        // keccak256(abi.encodePacked(\r\n        //     _EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH,\r\n        //     keccak256(bytes(name)),\r\n        //     keccak256(bytes(version)),\r\n        //     chainId,\r\n        //     uint256(verifyingContract)\r\n        // ))\r\n\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            // Calculate hashes of dynamic data\r\n            let nameHash := keccak256(add(name, 32), mload(name))\r\n            let versionHash := keccak256(add(version, 32), mload(version))\r\n\r\n            // Load free memory pointer\r\n            let memPtr := mload(64)\r\n\r\n            // Store params in memory\r\n            mstore(memPtr, schemaHash)\r\n            mstore(add(memPtr, 32), nameHash)\r\n            mstore(add(memPtr, 64), versionHash)\r\n            mstore(add(memPtr, 96), chainId)\r\n            mstore(add(memPtr, 128), verifyingContract)\r\n\r\n            // Compute hash\r\n            result := keccak256(memPtr, 160)\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /// @dev Calculates EIP712 encoding for a hash struct with a given domain hash.\r\n    /// @param eip712DomainHash Hash of the domain domain separator data, computed\r\n    ///                         with getDomainHash().\r\n    /// @param hashStruct The EIP712 hash struct.\r\n    /// @return result EIP712 hash applied to the given EIP712 Domain.\r\n    function hashEIP712Message(bytes32 eip712DomainHash, bytes32 hashStruct)\r\n        internal\r\n        pure\r\n        returns (bytes32 result)\r\n    {\r\n        // Assembly for more efficient computing:\r\n        // keccak256(abi.encodePacked(\r\n        //     EIP191_HEADER,\r\n        //     EIP712_DOMAIN_HASH,\r\n        //     hashStruct\r\n        // ));\r\n\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            // Load free memory pointer\r\n            let memPtr := mload(64)\r\n\r\n            mstore(memPtr, 0x1901000000000000000000000000000000000000000000000000000000000000)  // EIP191 header\r\n            mstore(add(memPtr, 2), eip712DomainHash)                                            // EIP712 domain hash\r\n            mstore(add(memPtr, 34), hashStruct)                                                 // Hash of struct\r\n\r\n            // Compute hash\r\n            result := keccak256(memPtr, 66)\r\n        }\r\n        return result;\r\n    }\r\n}"
    },
    "contracts/lib/LibUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\npragma abicoder v2;\r\n\r\nlibrary LibUtils {\r\n\r\n    function decimalsToGranularity(uint8 decimals) internal pure returns (uint256) {\r\n        require(decimals <= 18, \"LibUtils: Decimals not <= 18\");\r\n        return uint256(10)**(18-decimals);\r\n    }\r\n\r\n    function getDecimals(address tokenToUse) internal view returns (uint8) {\r\n        //support decimals as uint256 or uint8\r\n        (bool success, bytes memory data) = tokenToUse.staticcall(abi.encodeWithSignature(\"decimals()\"));\r\n        require(success, \"LibUtils: No decimals\");\r\n        // uint<M>: enc(X) is the big-endian encoding of X,\r\n        //padded on the higher-order (left) side with zero-bytes such that the length is 32 bytes.\r\n        return uint8(abi.decode(data, (uint256)));\r\n    }\r\n\r\n    function getGranularity(address tokenToUse) internal view returns (uint256) {\r\n        //support granularity if ERC777\r\n        (bool success, bytes memory data) = tokenToUse.staticcall(abi.encodeWithSignature(\"granularity()\"));\r\n        require(success, \"LibUtils: No granularity\");\r\n\r\n        return abi.decode(data, (uint256));\r\n    }\r\n\r\n    function bytesToAddress(bytes memory bys) internal pure returns (address addr) {\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            addr := mload(add(bys,20))\r\n        }\r\n    }\r\n\r\n}\r\n"
    },
    "contracts/nftbridge/INFTBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\npragma abicoder v2;\r\n\r\ninterface INFTBridge {\r\n  struct NFTClaimData {\r\n    address payable to;\r\n    address from;\r\n    uint256 tokenId;\r\n    address tokenAddress;\r\n    bytes32 blockHash;\r\n    bytes32 transactionHash;\r\n    uint32 logIndex;\r\n  }\r\n\r\n  function version() external pure returns (string memory);\r\n\r\n  function getFixedFee() external view returns (uint256);\r\n\r\n  function receiveTokensTo(\r\n    address tokenAddress,\r\n    address to,\r\n    uint256 tokenId\r\n  ) external payable;\r\n\r\n  /**\r\n    * Accepts the transaction from the other chain that was voted and sent by the Federation contract\r\n    */\r\n  function acceptTransfer(\r\n    address _originalTokenAddress,\r\n    address payable _from,\r\n    address payable _to,\r\n    uint256 _tokenId,\r\n    bytes32 _blockHash,\r\n    bytes32 _transactionHash,\r\n    uint32 _logIndex\r\n  ) external;\r\n\r\n  /**\r\n    * Claims the crossed transaction using the hash, this sends the token to the address specified in the claim data\r\n    */\r\n  function claim(NFTClaimData calldata _claimData) external;\r\n\r\n  function claimFallback(NFTClaimData calldata _claimData) external;\r\n\r\n  function getTransactionDataHash(\r\n    address _to,\r\n    address _from,\r\n    uint256 _tokenId,\r\n    address _tokenAddress,\r\n    bytes32 _blockHash,\r\n    bytes32 _transactionHash,\r\n    uint32 _logIndex\r\n  ) external returns (bytes32);\r\n\r\n  event Cross(\r\n    address indexed _originalTokenAddress,\r\n    address indexed _from,\r\n    address indexed _to,\r\n    address _tokenCreator,\r\n    bytes _userData,\r\n    uint256 _totalSupply,\r\n    uint256 _tokenId,\r\n    string _tokenURI\r\n  );\r\n  event NewSideNFTToken(\r\n    address indexed _newSideNFTTokenAddress,\r\n    address indexed _originalTokenAddress,\r\n    string _newSymbol\r\n  );\r\n  event AcceptedNFTCrossTransfer(\r\n    bytes32 indexed _transactionHash,\r\n    address indexed _originalTokenAddress,\r\n    address indexed _to,\r\n    address _from,\r\n    uint256 _tokenId,\r\n    bytes32 _blockHash,\r\n    uint256 _logIndex\r\n  );\r\n  event FixedFeeNFTChanged(uint256 _amount);\r\n  event ClaimedNFTToken(\r\n    bytes32 indexed _transactionHash,\r\n    address indexed _originalTokenAddress,\r\n    address indexed _to,\r\n    address _sender,\r\n    uint256 _tokenId,\r\n    bytes32 _blockHash,\r\n    uint256 _logIndex,\r\n    address _receiver\r\n  );\r\n}\r\n"
    },
    "contracts/nftbridge/ISideNFTToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\npragma abicoder v2;\r\n\r\ninterface ISideNFTToken {\r\n  function mint(address account, uint256 tokenId) external;\r\n}"
    },
    "contracts/nftbridge/ISideNFTTokenFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\npragma abicoder v2;\r\n\r\ninterface ISideNFTTokenFactory {\r\n\r\n    function createSideNFTToken(string calldata name, string calldata symbol, string calldata baseURI,\r\n        string calldata contractURI) external returns(address);\r\n\r\n    event SideNFTTokenCreated(address indexed sideTokenAddress, string symbol, string baseURI, string contractURI);\r\n}"
    },
    "contracts/interface/IWrapped.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\npragma abicoder v2;\r\ninterface IWrapped {\r\n    function balanceOf(address) external returns(uint);\r\n\r\n    function deposit() external payable;\r\n\r\n    function withdraw(uint wad) external;\r\n\r\n    function totalSupply() external view returns (uint);\r\n\r\n    function approve(address guy, uint wad) external returns (bool);\r\n\r\n    function transfer(address dst, uint wad) external returns (bool);\r\n\r\n    function transferFrom(address src, address dst, uint wad)\r\n        external\r\n        returns (bool);\r\n}"
    },
    "contracts/zeppelin/upgradable/access/roles/UpgradablePauserRole.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\npragma abicoder v2;\r\n\r\nimport \"../../Initializable.sol\";\r\n\r\nimport \"../../../GSN/Context.sol\";\r\nimport \"../../../access/Roles.sol\";\r\n\r\ncontract UpgradablePauserRole is Initializable, Context {\r\n    using Roles for Roles.Role;\r\n\r\n    event PauserAdded(address indexed account);\r\n    event PauserRemoved(address indexed account);\r\n\r\n    Roles.Role private _pausers;\r\n\r\n    function __PauserRol_init(address sender) public initializer {\r\n        if (!isPauser(sender)) {\r\n            _addPauser(sender);\r\n        }\r\n    }\r\n\r\n    modifier onlyPauser() {\r\n        require(isPauser(_msgSender()), \"PauserRole: caller doesn't have the role\");\r\n        _;\r\n    }\r\n\r\n    function isPauser(address account) public view returns (bool) {\r\n        return _pausers.has(account);\r\n    }\r\n\r\n    function addPauser(address account) public onlyPauser {\r\n        _addPauser(account);\r\n    }\r\n\r\n    function renouncePauser() public {\r\n        _removePauser(_msgSender());\r\n    }\r\n\r\n    function _addPauser(address account) internal {\r\n        _pausers.add(account);\r\n        emit PauserAdded(account);\r\n    }\r\n\r\n    function _removePauser(address account) internal {\r\n        _pausers.remove(account);\r\n        emit PauserRemoved(account);\r\n    }\r\n}\r\n"
    },
    "contracts/zeppelin/access/Roles.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\npragma abicoder v2;\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n    struct Role {\r\n        mapping (address => bool) bearer;\r\n    }\r\n\r\n    /**\r\n     * @dev Give an account access to this role.\r\n     */\r\n    function add(Role storage role, address account) internal {\r\n        require(!has(role, account), \"Roles: account already has role\");\r\n        role.bearer[account] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Remove an account's access to this role.\r\n     */\r\n    function remove(Role storage role, address account) internal {\r\n        require(has(role, account), \"Roles: account doesn't have role\");\r\n        role.bearer[account] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Check if an account has this role.\r\n     * @return bool\r\n     */\r\n    function has(Role storage role, address account) internal view returns (bool) {\r\n        require(account != address(0), \"Roles: account is the zero address\");\r\n        return role.bearer[account];\r\n    }\r\n}\r\n"
    },
    "contracts/zeppelin/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n"
    },
    "contracts/zeppelin/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\n\r\nimport \"../../GSN/Context.sol\";\r\nimport \"./IERC721.sol\";\r\nimport \"./IERC721Metadata.sol\";\r\nimport \"./IERC721Enumerable.sol\";\r\nimport \"./IERC721Receiver.sol\";\r\nimport \"../../introspection/ERC165.sol\";\r\nimport \"../../math/SafeMath.sol\";\r\nimport \"../../utils/Address.sol\";\r\nimport \"../../utils/EnumerableSet.sol\";\r\nimport \"../../utils/EnumerableMap.sol\";\r\nimport \"../../utils/Strings.sol\";\r\n\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard basic implementation\r\n * @dev see https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata, IERC721Enumerable {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n    using EnumerableSet for EnumerableSet.UintSet;\r\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\r\n    using Strings for uint256;\r\n\r\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\r\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\r\n\r\n    // Mapping from holder address to their (enumerable) set of owned tokens\r\n    mapping (address => EnumerableSet.UintSet) private _holderTokens;\r\n\r\n    // Enumerable mapping from token ids to their owners\r\n    EnumerableMap.UintToAddressMap private _tokenOwners;\r\n\r\n    // Mapping from token ID to approved address\r\n    mapping (uint256 => address) private _tokenApprovals;\r\n\r\n    // Mapping from owner to operator approvals\r\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\r\n\r\n    // Token name\r\n    string private _name;\r\n\r\n    // Token symbol\r\n    string private _symbol;\r\n\r\n    // Optional mapping for token URIs\r\n    mapping (uint256 => string) private _tokenURIs;\r\n\r\n    // Base URI\r\n    string private _baseURI;\r\n\r\n    /*\r\n     *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231\r\n     *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e\r\n     *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3\r\n     *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc\r\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\r\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\r\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd\r\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e\r\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde\r\n     *\r\n     *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\r\n     *        0xa22cb465 ^ 0xe985e9c5 ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\r\n     */\r\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\r\n\r\n    /*\r\n     *     bytes4(keccak256('name()')) == 0x06fdde03\r\n     *     bytes4(keccak256('symbol()')) == 0x95d89b41\r\n     *     bytes4(keccak256('tokenURI(uint256)')) == 0xc87b56dd\r\n     *\r\n     *     => 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f\r\n     */\r\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\r\n\r\n    /*\r\n     *     bytes4(keccak256('totalSupply()')) == 0x18160ddd\r\n     *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) == 0x2f745c59\r\n     *     bytes4(keccak256('tokenByIndex(uint256)')) == 0x4f6ccce7\r\n     *\r\n     *     => 0x18160ddd ^ 0x2f745c59 ^ 0x4f6ccce7 == 0x780e9d63\r\n     */\r\n    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\r\n\r\n    /**\r\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\r\n     */\r\n    constructor (string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n\r\n        // register the supported interfaces to conform to ERC721 via ERC165\r\n        _registerInterface(_INTERFACE_ID_ERC721);\r\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\r\n        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-balanceOf}.\r\n     */\r\n    function balanceOf(address owner) public view virtual override returns (uint256) {\r\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\r\n        return _holderTokens[owner].length();\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-ownerOf}.\r\n     */\r\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\r\n        return _tokenOwners.get(tokenId, \"ERC721: owner query for nonexistent token\");\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Metadata-name}.\r\n     */\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Metadata-symbol}.\r\n     */\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Metadata-tokenURI}.\r\n     */\r\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\r\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\r\n\r\n        string memory _tokenURI = _tokenURIs[tokenId];\r\n        string memory base = baseURI();\r\n\r\n        // If there is no base URI, return the token URI.\r\n        if (bytes(base).length == 0) {\r\n            return _tokenURI;\r\n        }\r\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\r\n        if (bytes(_tokenURI).length > 0) {\r\n            return string(abi.encodePacked(base, _tokenURI));\r\n        }\r\n        // If there is a baseURI but no tokenURI, concatenate the tokenID to the baseURI.\r\n        return string(abi.encodePacked(base, tokenId.toString()));\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the base URI set via {_setBaseURI}. This will be\r\n    * automatically added as a prefix in {tokenURI} to each token's URI, or\r\n    * to the token ID if no specific URI is set for that token ID.\r\n    */\r\n    function baseURI() public view virtual returns (string memory) {\r\n        return _baseURI;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\r\n     */\r\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\r\n        return _holderTokens[owner].at(index);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Enumerable-totalSupply}.\r\n     */\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        // _tokenOwners are indexed by tokenIds, so .length() returns the number of tokenIds\r\n        return _tokenOwners.length();\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Enumerable-tokenByIndex}.\r\n     */\r\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\r\n        (uint256 tokenId, ) = _tokenOwners.at(index);\r\n        return tokenId;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-approve}.\r\n     */\r\n    function approve(address to, uint256 tokenId) public virtual override {\r\n        address owner = ERC721.ownerOf(tokenId);\r\n        require(to != owner, \"ERC721: approval to current owner\");\r\n\r\n        require(_msgSender() == owner || ERC721.isApprovedForAll(owner, _msgSender()),\r\n            \"ERC721: approve caller is not owner nor approved for all\"\r\n        );\r\n\r\n        _approve(to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-getApproved}.\r\n     */\r\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\r\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\r\n\r\n        return _tokenApprovals[tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-setApprovalForAll}.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) public virtual override {\r\n        require(operator != _msgSender(), \"ERC721: approve to caller\");\r\n\r\n        _operatorApprovals[_msgSender()][operator] = approved;\r\n        emit ApprovalForAll(_msgSender(), operator, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-isApprovedForAll}.\r\n     */\r\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\r\n        return _operatorApprovals[owner][operator];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-transferFrom}.\r\n     */\r\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\r\n        //solhint-disable-next-line max-line-length\r\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\r\n\r\n        _transfer(from, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-safeTransferFrom}.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\r\n        safeTransferFrom(from, to, tokenId, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-safeTransferFrom}.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\r\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\r\n        _safeTransfer(from, to, tokenId, _data);\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\r\n     *\r\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\r\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\r\n        _transfer(from, to, tokenId);\r\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether `tokenId` exists.\r\n     *\r\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\r\n     *\r\n     * Tokens start existing when they are minted (`_mint`),\r\n     * and stop existing when they are burned (`_burn`).\r\n     */\r\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\r\n        return _tokenOwners.contains(tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\r\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\r\n        address owner = ERC721.ownerOf(tokenId);\r\n        return (spender == owner || getApproved(tokenId) == spender || ERC721.isApprovedForAll(owner, spender));\r\n    }\r\n\r\n    /**\r\n     * @dev Safely mints `tokenId` and transfers it to `to`.\r\n     *\r\n     * Requirements:\r\n     d*\r\n     * - `tokenId` must not exist.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _safeMint(address to, uint256 tokenId) internal virtual {\r\n        _safeMint(to, tokenId, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\r\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\r\n     */\r\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {\r\n        _mint(to, tokenId);\r\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\r\n    }\r\n\r\n    /**\r\n     * @dev Mints `tokenId` and transfers it to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must not exist.\r\n     * - `to` cannot be the zero address.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _mint(address to, uint256 tokenId) internal virtual {\r\n        require(to != address(0), \"ERC721: mint to the zero address\");\r\n        require(!_exists(tokenId), \"ERC721: token already minted\");\r\n\r\n        _beforeTokenTransfer(address(0), to, tokenId);\r\n\r\n        _holderTokens[to].add(tokenId);\r\n\r\n        _tokenOwners.set(tokenId, to);\r\n\r\n        emit Transfer(address(0), to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `tokenId`.\r\n     * The approval is cleared when the token is burned.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _burn(uint256 tokenId) internal virtual {\r\n        address owner = ERC721.ownerOf(tokenId); // internal owner\r\n\r\n        _beforeTokenTransfer(owner, address(0), tokenId);\r\n\r\n        // Clear approvals\r\n        _approve(address(0), tokenId);\r\n\r\n        // Clear metadata (if any)\r\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\r\n            delete _tokenURIs[tokenId];\r\n        }\r\n\r\n        _holderTokens[owner].remove(tokenId);\r\n\r\n        _tokenOwners.remove(tokenId);\r\n\r\n        emit Transfer(owner, address(0), tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` from `from` to `to`.\r\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\r\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\"); // internal owner\r\n        require(to != address(0), \"ERC721: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(from, to, tokenId);\r\n\r\n        // Clear approvals from the previous owner\r\n        _approve(address(0), tokenId);\r\n\r\n        _holderTokens[from].remove(tokenId);\r\n        _holderTokens[to].add(tokenId);\r\n\r\n        _tokenOwners.set(tokenId, to);\r\n\r\n        emit Transfer(from, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\r\n        require(_exists(tokenId), \"ERC721Metadata: URI set of nonexistent token\");\r\n        _tokenURIs[tokenId] = _tokenURI;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to set the base URI for all token IDs. It is\r\n     * automatically added as a prefix to the value returned in {tokenURI},\r\n     * or to the token ID if {tokenURI} is empty.\r\n     */\r\n    function _setBaseURI(string memory baseURI_) internal virtual {\r\n        _baseURI = baseURI_;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\r\n     * The call is not executed if the target address is not a contract.\r\n     *\r\n     * @param from address representing the previous owner of the given token ID\r\n     * @param to target address that will receive the tokens\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @param _data bytes optional data to send along with the call\r\n     * @return bool whether the call correctly returned the expected magic value\r\n     */\r\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\r\n        private returns (bool)\r\n    {\r\n        if (!to.isContract()) {\r\n            return true;\r\n        }\r\n        bytes memory returndata = to.functionCall(abi.encodeWithSelector(\r\n            IERC721Receiver(to).onERC721Received.selector,\r\n            _msgSender(),\r\n            from,\r\n            tokenId,\r\n            _data\r\n        ), \"ERC721: transfer to non ERC721Receiver implementer\");\r\n        bytes4 retval = abi.decode(returndata, (bytes4));\r\n        return (retval == _ERC721_RECEIVED);\r\n    }\r\n\r\n    function _approve(address to, uint256 tokenId) private {\r\n        _tokenApprovals[tokenId] = to;\r\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId); // internal owner\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any token transfer. This includes minting\r\n     * and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\r\n     * transferred to `to`.\r\n     * - When `from` is zero, `tokenId` will be minted for `to`.\r\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual { }\r\n}\r\n"
    },
    "contracts/zeppelin/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\n\r\nimport \"./IERC165.sol\";\r\n\r\n/**\r\n * @dev Implementation of the {IERC165} interface.\r\n *\r\n * Contracts may inherit from this and call {_registerInterface} to declare\r\n * their support of an interface.\r\n */\r\nabstract contract ERC165 is IERC165 {\r\n    /*\r\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\r\n     */\r\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\r\n\r\n    /**\r\n     * @dev Mapping of interface ids to whether or not it's supported.\r\n     */\r\n    mapping(bytes4 => bool) private _supportedInterfaces;\r\n\r\n    constructor () {\r\n        // Derived contracts need only register support for their own interfaces,\r\n        // we register support for ERC165 itself here\r\n        _registerInterface(_INTERFACE_ID_ERC165);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     *\r\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return _supportedInterfaces[interfaceId];\r\n    }\r\n\r\n    /**\r\n     * @dev Registers the contract as an implementer of the interface defined by\r\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\r\n     * registering its interface id is not required.\r\n     *\r\n     * See {IERC165-supportsInterface}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\r\n     */\r\n    function _registerInterface(bytes4 interfaceId) internal virtual {\r\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\r\n        _supportedInterfaces[interfaceId] = true;\r\n    }\r\n}\r\n"
    },
    "contracts/zeppelin/utils/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\n\r\n/**\r\n * @dev Library for managing\r\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\r\n * types.\r\n *\r\n * Sets have the following properties:\r\n *\r\n * - Elements are added, removed, and checked for existence in constant time\r\n * (O(1)).\r\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\r\n *\r\n * ```\r\n * contract Example {\r\n *     // Add the library methods\r\n *     using EnumerableSet for EnumerableSet.AddressSet;\r\n *\r\n *     // Declare a set state variable\r\n *     EnumerableSet.AddressSet private mySet;\r\n * }\r\n * ```\r\n *\r\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\r\n * and `uint256` (`UintSet`) are supported.\r\n */\r\nlibrary EnumerableSet {\r\n    // To implement this library for multiple types with as little code\r\n    // repetition as possible, we write it in terms of a generic Set type with\r\n    // bytes32 values.\r\n    // The Set implementation uses private functions, and user-facing\r\n    // implementations (such as AddressSet) are just wrappers around the\r\n    // underlying Set.\r\n    // This means that we can only create new EnumerableSets for types that fit\r\n    // in bytes32.\r\n\r\n    struct Set {\r\n        // Storage of set values\r\n        bytes32[] _values;\r\n\r\n        // Position of the value in the `values` array, plus 1 because index 0\r\n        // means a value is not in the set.\r\n        mapping (bytes32 => uint256) _indexes;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function _add(Set storage set, bytes32 value) private returns (bool) {\r\n        if (!_contains(set, value)) {\r\n            set._values.push(value);\r\n            // The value is stored at length-1, but we add 1 to all indexes\r\n            // and use 0 as a sentinel value\r\n            set._indexes[value] = set._values.length;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\r\n        // We read and store the value's index to prevent multiple reads from the same storage slot\r\n        uint256 valueIndex = set._indexes[value];\r\n\r\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\r\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\r\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\r\n            // This modifies the order of the array, as noted in {at}.\r\n\r\n            uint256 toDeleteIndex = valueIndex - 1;\r\n            uint256 lastIndex = set._values.length - 1;\r\n\r\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\r\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\r\n\r\n            bytes32 lastvalue = set._values[lastIndex];\r\n\r\n            // Move the last value to the index where the value to delete is\r\n            set._values[toDeleteIndex] = lastvalue;\r\n            // Update the index for the moved value\r\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\r\n\r\n            // Delete the slot where the moved value was stored\r\n            set._values.pop();\r\n\r\n            // Delete the index for the deleted slot\r\n            delete set._indexes[value];\r\n\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\r\n        return set._indexes[value] != 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values on the set. O(1).\r\n     */\r\n    function _length(Set storage set) private view returns (uint256) {\r\n        return set._values.length;\r\n    }\r\n\r\n   /**\r\n    * @dev Returns the value stored at position `index` in the set. O(1).\r\n    *\r\n    * Note that there are no guarantees on the ordering of values inside the\r\n    * array, and it may change when more values are added or removed.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `index` must be strictly less than {length}.\r\n    */\r\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\r\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\r\n        return set._values[index];\r\n    }\r\n\r\n    // Bytes32Set\r\n\r\n    struct Bytes32Set {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n        return _add(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n        return _remove(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\r\n        return _contains(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(Bytes32Set storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n   /**\r\n    * @dev Returns the value stored at position `index` in the set. O(1).\r\n    *\r\n    * Note that there are no guarantees on the ordering of values inside the\r\n    * array, and it may change when more values are added or removed.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `index` must be strictly less than {length}.\r\n    */\r\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\r\n        return _at(set._inner, index);\r\n    }\r\n\r\n    // AddressSet\r\n\r\n    struct AddressSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(AddressSet storage set, address value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(AddressSet storage set, address value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(AddressSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n   /**\r\n    * @dev Returns the value stored at position `index` in the set. O(1).\r\n    *\r\n    * Note that there are no guarantees on the ordering of values inside the\r\n    * array, and it may change when more values are added or removed.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `index` must be strictly less than {length}.\r\n    */\r\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\r\n        return address(uint160(uint256(_at(set._inner, index))));\r\n    }\r\n\r\n\r\n    // UintSet\r\n\r\n    struct UintSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values on the set. O(1).\r\n     */\r\n    function length(UintSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n   /**\r\n    * @dev Returns the value stored at position `index` in the set. O(1).\r\n    *\r\n    * Note that there are no guarantees on the ordering of values inside the\r\n    * array, and it may change when more values are added or removed.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `index` must be strictly less than {length}.\r\n    */\r\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\r\n        return uint256(_at(set._inner, index));\r\n    }\r\n}\r\n"
    },
    "contracts/zeppelin/utils/EnumerableMap.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\n\r\n/**\r\n * @dev Library for managing an enumerable variant of Solidity's\r\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\r\n * type.\r\n *\r\n * Maps have the following properties:\r\n *\r\n * - Entries are added, removed, and checked for existence in constant time\r\n * (O(1)).\r\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\r\n *\r\n * ```\r\n * contract Example {\r\n *     // Add the library methods\r\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\r\n *\r\n *     // Declare a set state variable\r\n *     EnumerableMap.UintToAddressMap private myMap;\r\n * }\r\n * ```\r\n *\r\n * As of v3.0.0, only maps of type `uint256 -> address` (`UintToAddressMap`) are\r\n * supported.\r\n */\r\nlibrary EnumerableMap {\r\n    // To implement this library for multiple types with as little code\r\n    // repetition as possible, we write it in terms of a generic Map type with\r\n    // bytes32 keys and values.\r\n    // The Map implementation uses private functions, and user-facing\r\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\r\n    // the underlying Map.\r\n    // This means that we can only create new EnumerableMaps for types that fit\r\n    // in bytes32.\r\n\r\n    struct MapEntry {\r\n        bytes32 _key;\r\n        bytes32 _value;\r\n    }\r\n\r\n    struct Map {\r\n        // Storage of map keys and values\r\n        MapEntry[] _entries;\r\n\r\n        // Position of the entry defined by a key in the `entries` array, plus 1\r\n        // because index 0 means a key is not in the map.\r\n        mapping (bytes32 => uint256) _indexes;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\r\n     * key. O(1).\r\n     *\r\n     * Returns true if the key was added to the map, that is if it was not\r\n     * already present.\r\n     */\r\n    function _set(Map storage map, bytes32 key, bytes32 value) private returns (bool) {\r\n        // We read and store the key's index to prevent multiple reads from the same storage slot\r\n        uint256 keyIndex = map._indexes[key];\r\n\r\n        if (keyIndex == 0) { // Equivalent to !contains(map, key)\r\n            map._entries.push(MapEntry({ _key: key, _value: value }));\r\n            // The entry is stored at length-1, but we add 1 to all indexes\r\n            // and use 0 as a sentinel value\r\n            map._indexes[key] = map._entries.length;\r\n            return true;\r\n        } else {\r\n            map._entries[keyIndex - 1]._value = value;\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a key-value pair from a map. O(1).\r\n     *\r\n     * Returns true if the key was removed from the map, that is if it was present.\r\n     */\r\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\r\n        // We read and store the key's index to prevent multiple reads from the same storage slot\r\n        uint256 keyIndex = map._indexes[key];\r\n\r\n        if (keyIndex != 0) { // Equivalent to contains(map, key)\r\n            // To delete a key-value pair from the _entries array in O(1), we swap the entry to delete with the last one\r\n            // in the array, and then remove the last entry (sometimes called as 'swap and pop').\r\n            // This modifies the order of the array, as noted in {at}.\r\n\r\n            uint256 toDeleteIndex = keyIndex - 1;\r\n            uint256 lastIndex = map._entries.length - 1;\r\n\r\n            // When the entry to delete is the last one, the swap operation is unnecessary. However, since this occurs\r\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\r\n\r\n            MapEntry storage lastEntry = map._entries[lastIndex];\r\n\r\n            // Move the last entry to the index where the entry to delete is\r\n            map._entries[toDeleteIndex] = lastEntry;\r\n            // Update the index for the moved entry\r\n            map._indexes[lastEntry._key] = toDeleteIndex + 1; // All indexes are 1-based\r\n\r\n            // Delete the slot where the moved entry was stored\r\n            map._entries.pop();\r\n\r\n            // Delete the index for the deleted slot\r\n            delete map._indexes[key];\r\n\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the key is in the map. O(1).\r\n     */\r\n    function _contains(Map storage map, bytes32 key) private view returns (bool) {\r\n        return map._indexes[key] != 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of key-value pairs in the map. O(1).\r\n     */\r\n    function _length(Map storage map) private view returns (uint256) {\r\n        return map._entries.length;\r\n    }\r\n\r\n   /**\r\n    * @dev Returns the key-value pair stored at position `index` in the map. O(1).\r\n    *\r\n    * Note that there are no guarantees on the ordering of entries inside the\r\n    * array, and it may change when more entries are added or removed.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `index` must be strictly less than {length}.\r\n    */\r\n    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {\r\n        require(map._entries.length > index, \"EnumerableMap: index out of bounds\");\r\n\r\n        MapEntry storage entry = map._entries[index];\r\n        return (entry._key, entry._value);\r\n    }\r\n\r\n    /**\r\n     * @dev Tries to returns the value associated with `key`.  O(1).\r\n     * Does not revert if `key` is not in the map.\r\n     */\r\n    function _tryGet(Map storage map, bytes32 key) private view returns (bool, bytes32) {\r\n        uint256 keyIndex = map._indexes[key];\r\n        if (keyIndex == 0) return (false, 0); // Equivalent to contains(map, key)\r\n        return (true, map._entries[keyIndex - 1]._value); // All indexes are 1-based\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value associated with `key`.  O(1).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `key` must be in the map.\r\n     */\r\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\r\n        uint256 keyIndex = map._indexes[key];\r\n        require(keyIndex != 0, \"EnumerableMap: nonexistent key\"); // Equivalent to contains(map, key)\r\n        return map._entries[keyIndex - 1]._value; // All indexes are 1-based\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {_tryGet}.\r\n     */\r\n    function _get(Map storage map, bytes32 key, string memory errorMessage) private view returns (bytes32) {\r\n        uint256 keyIndex = map._indexes[key];\r\n        require(keyIndex != 0, errorMessage); // Equivalent to contains(map, key)\r\n        return map._entries[keyIndex - 1]._value; // All indexes are 1-based\r\n    }\r\n\r\n    // UintToAddressMap\r\n\r\n    struct UintToAddressMap {\r\n        Map _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\r\n     * key. O(1).\r\n     *\r\n     * Returns true if the key was added to the map, that is if it was not\r\n     * already present.\r\n     */\r\n    function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\r\n        return _set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the key was removed from the map, that is if it was present.\r\n     */\r\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\r\n        return _remove(map._inner, bytes32(key));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the key is in the map. O(1).\r\n     */\r\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\r\n        return _contains(map._inner, bytes32(key));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of elements in the map. O(1).\r\n     */\r\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\r\n        return _length(map._inner);\r\n    }\r\n\r\n   /**\r\n    * @dev Returns the element stored at position `index` in the set. O(1).\r\n    * Note that there are no guarantees on the ordering of values inside the\r\n    * array, and it may change when more values are added or removed.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `index` must be strictly less than {length}.\r\n    */\r\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\r\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\r\n        return (uint256(key), address(uint160(uint256(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Tries to returns the value associated with `key`.  O(1).\r\n     * Does not revert if `key` is not in the map.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\r\n        (bool success, bytes32 value) = _tryGet(map._inner, bytes32(key));\r\n        return (success, address(uint160(uint256(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value associated with `key`.  O(1).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `key` must be in the map.\r\n     */\r\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\r\n        return address(uint160(uint256(_get(map._inner, bytes32(key)))));\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryGet}.\r\n     */\r\n    function get(UintToAddressMap storage map, uint256 key, string memory errorMessage) internal view returns (address) {\r\n        return address(uint160(uint256(_get(map._inner, bytes32(key), errorMessage))));\r\n    }\r\n}\r\n"
    },
    "contracts/zeppelin/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` representation.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        // Inspired by OraclizeAPI's implementation - MIT licence\r\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        uint256 index = digits - 1;\r\n        temp = value;\r\n        while (temp != 0) {\r\n            buffer[index--] = bytes1(uint8(48 + temp % 10));\r\n            temp /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n}\r\n"
    },
    "contracts/test/WRBTC.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\n\r\nimport \"../interface/IWrapped.sol\";\r\n\r\ncontract WRBTC is IWrapped {\r\n    string public name     = \"Wrapped RBTC\";\r\n    string public symbol   = \"WRBTC\";\r\n    uint8  public decimals = 18;\r\n\r\n    event  Approval(address indexed src, address indexed guy, uint wad);\r\n    event  Transfer(address indexed src, address indexed dst, uint wad);\r\n    event  Deposit(address indexed dst, uint wad);\r\n    event  Withdrawal(address indexed src, uint wad);\r\n\r\n    mapping (address => uint) override public balanceOf;\r\n    mapping (address => mapping (address => uint)) public allowance;\r\n\r\n    receive () external payable {\r\n        deposit();\r\n    }\r\n    function deposit() override public payable {\r\n        balanceOf[msg.sender] += msg.value;\r\n        emit Deposit(msg.sender, msg.value);\r\n    }\r\n    function withdraw(uint wad) override public {\r\n        require(balanceOf[msg.sender] >= wad, \"WRBTC: Balance less than wad\");\r\n        balanceOf[msg.sender] -= wad;\r\n        msg.sender.transfer(wad);\r\n        emit Withdrawal(msg.sender, wad);\r\n    }\r\n\r\n    function totalSupply() override public view returns (uint) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    function approve(address guy, uint wad) override public returns (bool) {\r\n        allowance[msg.sender][guy] = wad;\r\n        emit Approval(msg.sender, guy, wad);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address dst, uint wad) override public returns (bool) {\r\n        return transferFrom(msg.sender, dst, wad);\r\n    }\r\n\r\n    function transferFrom(address src, address dst, uint wad)\r\n        override public\r\n        returns (bool)\r\n    {\r\n        require(balanceOf[src] >= wad, \"WRBTC: Balance less than wad\");\r\n\r\n        if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {\r\n            require(allowance[src][msg.sender] >= wad, \"WRBTC: Allowance less than wad\");\r\n            allowance[src][msg.sender] -= wad;\r\n        }\r\n\r\n        balanceOf[src] -= wad;\r\n        balanceOf[dst] += wad;\r\n\r\n        emit Transfer(src, dst, wad);\r\n\r\n        return true;\r\n    }\r\n}"
    },
    "contracts/Bridge/Bridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\npragma abicoder v2;\r\n\r\n// Import base Initializable contract\r\nimport \"../zeppelin/upgradable/Initializable.sol\";\r\n// Import interface and library from OpenZeppelin contracts\r\nimport \"../zeppelin/upgradable/utils/ReentrancyGuard.sol\";\r\nimport \"../zeppelin/upgradable/lifecycle/UpgradablePausable.sol\";\r\nimport \"../zeppelin/upgradable/ownership/UpgradableOwnable.sol\";\r\n\r\nimport \"../zeppelin/introspection/IERC1820Registry.sol\";\r\nimport \"../zeppelin/token/ERC777/IERC777Recipient.sol\";\r\nimport \"../zeppelin/token/ERC20/IERC20.sol\";\r\nimport \"../zeppelin/token/ERC20/SafeERC20.sol\";\r\nimport \"../zeppelin/utils/Address.sol\";\r\nimport \"../zeppelin/math/SafeMath.sol\";\r\nimport \"../zeppelin/token/ERC777/IERC777.sol\";\r\n\r\nimport \"../lib/LibEIP712.sol\";\r\nimport \"../lib/LibUtils.sol\";\r\n\r\nimport \"../interface/IBridge.sol\";\r\nimport \"../interface/ISideToken.sol\";\r\nimport \"../interface/ISideTokenFactory.sol\";\r\nimport \"../interface/IAllowTokens.sol\";\r\nimport \"../interface/IWrapped.sol\";\r\n\r\n// solhint-disable-next-line max-states-count\r\ncontract Bridge is Initializable, IBridge, IERC777Recipient, UpgradablePausable, UpgradableOwnable, ReentrancyGuard {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n    using Address for address;\r\n\r\n    address constant internal NULL_ADDRESS = address(0);\r\n    bytes32 constant internal NULL_HASH = bytes32(0);\r\n    IERC1820Registry constant internal ERC1820 = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\r\n\r\n    address internal federation;\r\n    uint256 internal feePercentage;\r\n    string public symbolPrefix;\r\n    // replaces uint256 internal _depprecatedLastDay;\r\n    bytes32 public domainSeparator;\r\n    uint256 internal _deprecatedSpentToday;\r\n\r\n    mapping (address => address) public mappedTokens; // OirignalToken => SideToken\r\n    mapping (address => address) public originalTokens; // SideToken => OriginalToken\r\n    mapping (address => bool) public knownTokens; // OriginalToken => true\r\n    mapping (bytes32 => bool) public claimed; // transactionDataHash => true // previously named processed\r\n    IAllowTokens public allowTokens;\r\n    ISideTokenFactory public sideTokenFactory;\r\n    //Bridge_v1 variables\r\n    bool public isUpgrading;\r\n    // Percentage with up to 2 decimals\r\n    uint256 constant public feePercentageDivider = 10000; // solhint-disable-line const-name-snakecase\r\n    //Bridge_v3 variables\r\n    bytes32 constant internal _erc777Interface = keccak256(\"ERC777Token\"); // solhint-disable-line const-name-snakecase\r\n    IWrapped public wrappedCurrency;\r\n    mapping (bytes32 => bytes32) public transactionsDataHashes; // transactionHash => transactionDataHash\r\n    mapping (bytes32 => address) public originalTokenAddresses; // transactionHash => originalTokenAddress\r\n    mapping (bytes32 => address) public senderAddresses; // transactionHash => senderAddress\r\n\r\n    // keccak256(\"Claim(address to,uint256 amount,bytes32 transactionHash,address relayer,uint256 fee,uint256 nonce,uint256 deadline)\");\r\n    bytes32 public constant CLAIM_TYPEHASH = 0xf18ceda3f6355f78c234feba066041a50f6557bfb600201e2a71a89e2dd80433;\r\n    mapping(address => uint) public nonces;\r\n\r\n    event AllowTokensChanged(address _newAllowTokens);\r\n    event FederationChanged(address _newFederation);\r\n    event SideTokenFactoryChanged(address _newSideTokenFactory);\r\n    event Upgrading(bool _isUpgrading);\r\n    event WrappedCurrencyChanged(address _wrappedCurrency);\r\n\r\n    function initialize(\r\n        address _manager,\r\n        address _federation,\r\n        address _allowTokens,\r\n        address _sideTokenFactory,\r\n        string memory _symbolPrefix\r\n    ) public initializer {\r\n        UpgradableOwnable.initialize(_manager);\r\n        UpgradablePausable.__Pausable_init(_manager);\r\n        symbolPrefix = _symbolPrefix;\r\n        allowTokens = IAllowTokens(_allowTokens);\r\n        sideTokenFactory = ISideTokenFactory(_sideTokenFactory);\r\n        federation = _federation;\r\n        //keccak256(\"ERC777TokensRecipient\")\r\n        ERC1820.setInterfaceImplementer(address(this), 0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b, address(this));\r\n        initDomainSeparator();\r\n    }\r\n\r\n    receive () external payable {\r\n        // The fallback function is needed to use WRBTC\r\n        require(_msgSender() == address(wrappedCurrency), \"Bridge: not wrappedCurrency\");\r\n    }\r\n\r\n    function version() override external pure returns (string memory) {\r\n        return \"v3\";\r\n    }\r\n\r\n    function initDomainSeparator() public {\r\n        uint chainId;\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            chainId := chainid()\r\n        }\r\n        domainSeparator = LibEIP712.hashEIP712Domain(\r\n            \"RSK Token Bridge\",\r\n            \"1\",\r\n            chainId,\r\n            address(this)\r\n        );\r\n    }\r\n\r\n    modifier whenNotUpgrading() {\r\n        require(!isUpgrading, \"Bridge: Upgrading\");\r\n        _;\r\n    }\r\n\r\n    function acceptTransfer(\r\n        address _originalTokenAddress,\r\n        address payable _from,\r\n        address payable _to,\r\n        uint256 _amount,\r\n        bytes32 _blockHash,\r\n        bytes32 _transactionHash,\r\n        uint32 _logIndex\r\n    ) external whenNotPaused nonReentrant override {\r\n        require(_msgSender() == federation, \"Bridge: Not Federation\");\r\n        require(knownTokens[_originalTokenAddress] ||\r\n            mappedTokens[_originalTokenAddress] != NULL_ADDRESS,\r\n            \"Bridge: Unknown token\"\r\n        );\r\n        require(_to != NULL_ADDRESS, \"Bridge: Null To\");\r\n        require(_amount > 0, \"Bridge: Amount 0\");\r\n        require(_blockHash != NULL_HASH, \"Bridge: Null BlockHash\");\r\n        require(_transactionHash != NULL_HASH, \"Bridge: Null TxHash\");\r\n        require(transactionsDataHashes[_transactionHash] == bytes32(0), \"Bridge: Already accepted\");\r\n\r\n        bytes32 _transactionDataHash = getTransactionDataHash(\r\n            _to,\r\n            _amount,\r\n            _blockHash,\r\n            _transactionHash,\r\n            _logIndex\r\n        );\r\n        // Do not remove, claimed also has the previously processed using the older bridge version\r\n        // https://github.com/rsksmart/tokenbridge/blob/TOKENBRIDGE-1.2.0/bridge/contracts/Bridge.sol#L41\r\n        require(!claimed[_transactionDataHash], \"Bridge: Already claimed\");\r\n\r\n        transactionsDataHashes[_transactionHash] = _transactionDataHash;\r\n        originalTokenAddresses[_transactionHash] = _originalTokenAddress;\r\n        senderAddresses[_transactionHash] = _from;\r\n\r\n        emit AcceptedCrossTransfer(\r\n            _transactionHash,\r\n            _originalTokenAddress,\r\n            _to,\r\n            _from,\r\n            _amount,\r\n            _blockHash,\r\n            _logIndex\r\n        );\r\n    }\r\n\r\n\r\n    function createSideToken(\r\n        uint256 _typeId,\r\n        address _originalTokenAddress,\r\n        uint8 _originalTokenDecimals,\r\n        string calldata _originalTokenSymbol,\r\n        string calldata _originalTokenName\r\n    ) external onlyOwner {\r\n        require(_originalTokenAddress != NULL_ADDRESS, \"Bridge: Null token\");\r\n        address sideToken = mappedTokens[_originalTokenAddress];\r\n        require(sideToken == NULL_ADDRESS, \"Bridge: Already exists\");\r\n        uint256 granularity = LibUtils.decimalsToGranularity(_originalTokenDecimals);\r\n        string memory newSymbol = string(abi.encodePacked(symbolPrefix, _originalTokenSymbol));\r\n\r\n        // Create side token\r\n        sideToken = sideTokenFactory.createSideToken(_originalTokenName, newSymbol, granularity);\r\n\r\n        mappedTokens[_originalTokenAddress] = sideToken;\r\n        originalTokens[sideToken] = _originalTokenAddress;\r\n        allowTokens.setToken(sideToken, _typeId);\r\n\r\n        emit NewSideToken(sideToken, _originalTokenAddress, newSymbol, granularity);\r\n    }\r\n\r\n    function claim(ClaimData calldata _claimData)\r\n    external override returns (uint256 receivedAmount) {\r\n\r\n        receivedAmount = _claim(\r\n            _claimData,\r\n            _claimData.to,\r\n            payable(address(0)),\r\n            0\r\n        );\r\n        return receivedAmount;\r\n    }\r\n\r\n    function claimFallback(ClaimData calldata _claimData)\r\n    external override returns (uint256 receivedAmount) {\r\n        require(_msgSender() == senderAddresses[_claimData.transactionHash],\"Bridge: invalid sender\");\r\n        receivedAmount = _claim(\r\n            _claimData,\r\n            _msgSender(),\r\n            payable(address(0)),\r\n            0\r\n        );\r\n        return receivedAmount;\r\n    }\r\n\r\n    function getDigest(\r\n        ClaimData memory _claimData,\r\n        address payable _relayer,\r\n        uint256 _fee,\r\n        uint256 _deadline\r\n    ) internal returns (bytes32) {\r\n        return LibEIP712.hashEIP712Message(\r\n            domainSeparator,\r\n            keccak256(\r\n                abi.encode(\r\n                    CLAIM_TYPEHASH,\r\n                    _claimData.to,\r\n                    _claimData.amount,\r\n                    _claimData.transactionHash,\r\n                    _relayer,\r\n                    _fee,\r\n                    nonces[_claimData.to]++,\r\n                    _deadline\r\n                )\r\n            )\r\n        );\r\n    }\r\n\r\n    // Inspired by https://github.com/dapphub/ds-dach/blob/master/src/dach.sol\r\n    function claimGasless(\r\n        ClaimData calldata _claimData,\r\n        address payable _relayer,\r\n        uint256 _fee,\r\n        uint256 _deadline,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) external override returns (uint256 receivedAmount) {\r\n        require(_deadline >= block.timestamp, \"Bridge: EXPIRED\"); // solhint-disable-line not-rely-on-time\r\n\r\n        bytes32 digest = getDigest(_claimData, _relayer, _fee, _deadline);\r\n        address recoveredAddress = ecrecover(digest, _v, _r, _s);\r\n        require(_claimData.to != address(0) && recoveredAddress == _claimData.to, \"Bridge: INVALID_SIGNATURE\");\r\n\r\n        receivedAmount = _claim(\r\n            _claimData,\r\n            _claimData.to,\r\n            _relayer,\r\n            _fee\r\n        );\r\n        return receivedAmount;\r\n    }\r\n\r\n    function _claim(\r\n        ClaimData calldata _claimData,\r\n        address payable _reciever,\r\n        address payable _relayer,\r\n        uint256 _fee\r\n    ) internal nonReentrant returns (uint256 receivedAmount) {\r\n        address originalTokenAddress = originalTokenAddresses[_claimData.transactionHash];\r\n        require(originalTokenAddress != NULL_ADDRESS, \"Bridge: Tx not crossed\");\r\n\r\n        bytes32 transactionDataHash = getTransactionDataHash(\r\n            _claimData.to,\r\n            _claimData.amount,\r\n            _claimData.blockHash,\r\n            _claimData.transactionHash,\r\n            _claimData.logIndex\r\n        );\r\n        require(transactionsDataHashes[_claimData.transactionHash] == transactionDataHash, \"Bridge: Wrong transactionDataHash\");\r\n        require(!claimed[transactionDataHash], \"Bridge: Already claimed\");\r\n\r\n        claimed[transactionDataHash] = true;\r\n        if (knownTokens[originalTokenAddress]) {\r\n            receivedAmount =_claimCrossBackToToken(\r\n                originalTokenAddress,\r\n                _reciever,\r\n                _claimData.amount,\r\n                _relayer,\r\n                _fee\r\n            );\r\n        } else {\r\n            receivedAmount =_claimCrossToSideToken(\r\n                originalTokenAddress,\r\n                _reciever,\r\n                _claimData.amount,\r\n                _relayer,\r\n                _fee\r\n            );\r\n        }\r\n        emit Claimed(\r\n            _claimData.transactionHash,\r\n            originalTokenAddress,\r\n            _claimData.to,\r\n            senderAddresses[_claimData.transactionHash],\r\n            _claimData.amount,\r\n            _claimData.blockHash,\r\n            _claimData.logIndex,\r\n            _reciever,\r\n            _relayer,\r\n            _fee\r\n        );\r\n        return receivedAmount;\r\n    }\r\n\r\n    function _claimCrossToSideToken(\r\n        address _originalTokenAddress,\r\n        address payable _receiver,\r\n        uint256 _amount,\r\n        address payable _relayer,\r\n        uint256 _fee\r\n    ) internal returns (uint256 receivedAmount) {\r\n        address sideToken = mappedTokens[_originalTokenAddress];\r\n        uint256 granularity = IERC777(sideToken).granularity();\r\n        uint256 formattedAmount = _amount.mul(granularity);\r\n        require(_fee <= formattedAmount, \"Bridge: fee too high\");\r\n        receivedAmount = formattedAmount - _fee;\r\n        ISideToken(sideToken).mint(_receiver, receivedAmount, \"\", \"\");\r\n        if(_fee > 0) {\r\n            ISideToken(sideToken).mint(_relayer, _fee, \"\", \"relayer fee\");\r\n        }\r\n        return receivedAmount;\r\n    }\r\n\r\n    function _claimCrossBackToToken(\r\n        address _originalTokenAddress,\r\n        address payable _receiver,\r\n        uint256 _amount,\r\n        address payable _relayer,\r\n        uint256 _fee\r\n    ) internal returns (uint256 receivedAmount) {\r\n        uint256 decimals = LibUtils.getDecimals(_originalTokenAddress);\r\n        //As side tokens are ERC777 they will always have 18 decimals\r\n        uint256 formattedAmount = _amount.div(uint256(10) ** (18 - decimals));\r\n        require(_fee <= formattedAmount, \"Bridge: fee too high\");\r\n        receivedAmount = formattedAmount - _fee;\r\n        if(address(wrappedCurrency) == _originalTokenAddress) {\r\n            wrappedCurrency.withdraw(formattedAmount);\r\n            _receiver.transfer(receivedAmount);\r\n            if(_fee > 0) {\r\n                _relayer.transfer(_fee);\r\n            }\r\n        } else {\r\n            IERC20(_originalTokenAddress).safeTransfer(_receiver, receivedAmount);\r\n            if(_fee > 0) {\r\n                IERC20(_originalTokenAddress).safeTransfer(_relayer, _fee);\r\n            }\r\n        }\r\n        return receivedAmount;\r\n    }\r\n\r\n    /**\r\n     * ERC-20 tokens approve and transferFrom pattern\r\n     * See https://eips.ethereum.org/EIPS/eip-20#transferfrom\r\n     */\r\n    function receiveTokensTo(address tokenToUse, address to, uint256 amount) override public {\r\n        address sender = _msgSender();\r\n        //Transfer the tokens on IERC20, they should be already Approved for the bridge Address to use them\r\n        IERC20(tokenToUse).safeTransferFrom(sender, address(this), amount);\r\n        crossTokens(tokenToUse, sender, to, amount, \"\");\r\n    }\r\n\r\n    /**\r\n     * Use network currency and cross it.\r\n     */\r\n    function depositTo(address to) override external payable {\r\n        address sender = _msgSender();\r\n        require(address(wrappedCurrency) != NULL_ADDRESS, \"Bridge: wrappedCurrency empty\");\r\n        wrappedCurrency.deposit{ value: msg.value }();\r\n        crossTokens(address(wrappedCurrency), sender, to, msg.value, \"\");\r\n    }\r\n\r\n    /**\r\n     * ERC-777 tokensReceived hook allows to send tokens to a contract and notify it in a single transaction\r\n     * See https://eips.ethereum.org/EIPS/eip-777#motivation for details\r\n     */\r\n    function tokensReceived (\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint amount,\r\n        bytes calldata userData,\r\n        bytes calldata\r\n    ) external override(IBridge, IERC777Recipient){\r\n        //Hook from ERC777address\r\n        if(operator == address(this)) return; // Avoid loop from bridge calling to ERC77transferFrom\r\n        require(to == address(this), \"Bridge: Not to this address\");\r\n        address tokenToUse = _msgSender();\r\n        require(ERC1820.getInterfaceImplementer(tokenToUse, _erc777Interface) != NULL_ADDRESS, \"Bridge: Not ERC777 token\");\r\n        require(userData.length != 0 || !from.isContract(), \"Bridge: Specify receiver address in data\");\r\n        address receiver = userData.length == 0 ? from : LibUtils.bytesToAddress(userData);\r\n        crossTokens(tokenToUse, from, receiver, amount, userData);\r\n    }\r\n\r\n    function crossTokens(address tokenToUse, address from, address to, uint256 amount, bytes memory userData)\r\n    internal whenNotUpgrading whenNotPaused nonReentrant {\r\n        knownTokens[tokenToUse] = true;\r\n        uint256 fee = amount.mul(feePercentage).div(feePercentageDivider);\r\n        uint256 amountMinusFees = amount.sub(fee);\r\n        uint8 decimals = LibUtils.getDecimals(tokenToUse);\r\n        uint formattedAmount = amount;\r\n        if(decimals != 18) {\r\n            formattedAmount = amount.mul(uint256(10)**(18-decimals));\r\n        }\r\n        // We consider the amount before fees converted to 18 decimals to check the limits\r\n        // updateTokenTransfer revert if token not allowed\r\n        allowTokens.updateTokenTransfer(tokenToUse, formattedAmount);\r\n        address originalTokenAddress = tokenToUse;\r\n        if (originalTokens[tokenToUse] != NULL_ADDRESS) {\r\n            //Side Token Crossing\r\n            originalTokenAddress = originalTokens[tokenToUse];\r\n            uint256 granularity = LibUtils.getGranularity(tokenToUse);\r\n            uint256 modulo = amountMinusFees.mod(granularity);\r\n            fee = fee.add(modulo);\r\n            amountMinusFees = amountMinusFees.sub(modulo);\r\n            IERC777(tokenToUse).burn(amountMinusFees, userData);\r\n        }\r\n\r\n        emit Cross(\r\n            originalTokenAddress,\r\n            from,\r\n            to,\r\n            amountMinusFees,\r\n            userData\r\n        );\r\n\r\n        if (fee > 0) {\r\n            //Send the payment to the MultiSig of the Federation\r\n            IERC20(tokenToUse).safeTransfer(owner(), fee);\r\n        }\r\n    }\r\n\r\n    function getTransactionDataHash(\r\n        address _to,\r\n        uint256 _amount,\r\n        bytes32 _blockHash,\r\n        bytes32 _transactionHash,\r\n        uint32 _logIndex\r\n    )\r\n        public pure override returns(bytes32)\r\n    {\r\n        return keccak256(abi.encodePacked(_blockHash, _transactionHash, _to, _amount, _logIndex));\r\n    }\r\n\r\n    function setFeePercentage(uint amount) external onlyOwner {\r\n        require(amount < (feePercentageDivider/10), \"Bridge: bigger than 10%\");\r\n        feePercentage = amount;\r\n        emit FeePercentageChanged(feePercentage);\r\n    }\r\n\r\n    function getFeePercentage() external view override returns(uint) {\r\n        return feePercentage;\r\n    }\r\n\r\n    function changeFederation(address newFederation) external onlyOwner {\r\n        require(newFederation != NULL_ADDRESS, \"Bridge: Federation is empty\");\r\n        federation = newFederation;\r\n        emit FederationChanged(federation);\r\n    }\r\n\r\n\r\n    function changeAllowTokens(address newAllowTokens) external onlyOwner {\r\n        require(newAllowTokens != NULL_ADDRESS, \"Bridge: AllowTokens is empty\");\r\n        allowTokens = IAllowTokens(newAllowTokens);\r\n        emit AllowTokensChanged(newAllowTokens);\r\n    }\r\n\r\n    function getFederation() external view returns(address) {\r\n        return federation;\r\n    }\r\n\r\n    function changeSideTokenFactory(address newSideTokenFactory) external onlyOwner {\r\n        require(newSideTokenFactory != NULL_ADDRESS, \"Bridge: SideTokenFactory is empty\");\r\n        sideTokenFactory = ISideTokenFactory(newSideTokenFactory);\r\n        emit SideTokenFactoryChanged(newSideTokenFactory);\r\n    }\r\n\r\n    function setUpgrading(bool _isUpgrading) external onlyOwner {\r\n        isUpgrading = _isUpgrading;\r\n        emit Upgrading(isUpgrading);\r\n    }\r\n\r\n    function setWrappedCurrency(address _wrappedCurrency) external onlyOwner {\r\n        require(_wrappedCurrency != NULL_ADDRESS, \"Bridge: wrapp is empty\");\r\n        wrappedCurrency = IWrapped(_wrappedCurrency);\r\n        emit WrappedCurrencyChanged(_wrappedCurrency);\r\n    }\r\n\r\n    function hasCrossed(bytes32 transactionHash) public view returns (bool) {\r\n        return transactionsDataHashes[transactionHash] != bytes32(0);\r\n    }\r\n\r\n    function hasBeenClaimed(bytes32 transactionHash) public view returns (bool) {\r\n        return claimed[transactionsDataHashes[transactionHash]];\r\n    }\r\n\r\n}\r\n"
    },
    "contracts/zeppelin/token/ERC777/IERC777Recipient.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\npragma abicoder v2;\r\n\r\n/**\r\n * @dev Interface of the ERC777TokensRecipient standard as defined in the EIP.\r\n *\r\n * Accounts can be notified of `IERC777` tokens being sent to them by having a\r\n * contract implement this interface (contract holders can be their own\r\n * implementer) and registering it on the\r\n * [ERC1820 global registry](https://eips.ethereum.org/EIPS/eip-1820).\r\n *\r\n * See `IERC1820Registry` and `ERC1820Implementer`.\r\n */\r\ninterface IERC777Recipient {\r\n    /**\r\n     * @dev Called by an `IERC777` token contract whenever tokens are being\r\n     * moved or created into a registered account (`to`). The type of operation\r\n     * is conveyed by `from` being the zero address or not.\r\n     *\r\n     * This call occurs _after_ the token contract's state is updated, so\r\n     * `IERC777.balanceOf`, etc., can be used to query the post-operation state.\r\n     *\r\n     * This function may revert to prevent the operation from being executed.\r\n     */\r\n    function tokensReceived(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint amount,\r\n        bytes calldata userData,\r\n        bytes calldata operatorData\r\n    ) external;\r\n}\r\n"
    },
    "contracts/zeppelin/token/ERC777/IERC777.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\npragma abicoder v2;\r\n\r\n/**\r\n * @dev Interface of the ERC777Token standard as defined in the EIP.\r\n *\r\n * This contract uses the\r\n * [ERC1820 registry standard](https://eips.ethereum.org/EIPS/eip-1820) to let\r\n * token holders and recipients react to token movements by using setting implementers\r\n * for the associated interfaces in said registry. See `IERC1820Registry` and\r\n * `ERC1820Implementer`.\r\n */\r\ninterface IERC777 {\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the smallest part of the token that is not divisible. This\r\n     * means all token operations (creation, movement and destruction) must have\r\n     * amounts that are a multiple of this number.\r\n     *\r\n     * For most token contracts, this value will equal 1.\r\n     */\r\n    function granularity() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by an account (`owner`).\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * If send or receive hooks are registered for the caller and `recipient`,\r\n     * the corresponding functions will be called with `data` and empty\r\n     * `operatorData`. See `IERC777Sender` and `IERC777Recipient`.\r\n     *\r\n     * Emits a `Sent` event.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - the caller must have at least `amount` tokens.\r\n     * - `recipient` cannot be the zero address.\r\n     * - if `recipient` is a contract, it must implement the `tokensReceived`\r\n     * interface.\r\n     */\r\n    function send(address recipient, uint256 amount, bytes calldata data) external;\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from the caller's account, reducing the\r\n     * total supply.\r\n     *\r\n     * If a send hook is registered for the caller, the corresponding function\r\n     * will be called with `data` and empty `operatorData`. See `IERC777Sender`.\r\n     *\r\n     * Emits a `Burned` event.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - the caller must have at least `amount` tokens.\r\n     */\r\n    function burn(uint256 amount, bytes calldata data) external;\r\n\r\n    /**\r\n     * @dev Returns true if an account is an operator of `tokenHolder`.\r\n     * Operators can send and burn tokens on behalf of their owners. All\r\n     * accounts are their own operator.\r\n     *\r\n     * See `operatorSend` and `operatorBurn`.\r\n     */\r\n    function isOperatorFor(address operator, address tokenHolder) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Make an account an operator of the caller.\r\n     *\r\n     * See `isOperatorFor`.\r\n     *\r\n     * Emits an `AuthorizedOperator` event.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `operator` cannot be calling address.\r\n     */\r\n    function authorizeOperator(address operator) external;\r\n\r\n    /**\r\n     * @dev Make an account an operator of the caller.\r\n     *\r\n     * See `isOperatorFor` and `defaultOperators`.\r\n     *\r\n     * Emits a `RevokedOperator` event.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `operator` cannot be calling address.\r\n     */\r\n    function revokeOperator(address operator) external;\r\n\r\n    /**\r\n     * @dev Returns the list of default operators. These accounts are operators\r\n     * for all token holders, even if `authorizeOperator` was never called on\r\n     * them.\r\n     *\r\n     * This list is immutable, but individual holders may revoke these via\r\n     * `revokeOperator`, in which case `isOperatorFor` will return false.\r\n     */\r\n    function defaultOperators() external view returns (address[] memory);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient`. The caller must\r\n     * be an operator of `sender`.\r\n     *\r\n     * If send or receive hooks are registered for `sender` and `recipient`,\r\n     * the corresponding functions will be called with `data` and\r\n     * `operatorData`. See `IERC777Sender` and `IERC777Recipient`.\r\n     *\r\n     * Emits a `Sent` event.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `sender` must have at least `amount` tokens.\r\n     * - the caller must be an operator for `sender`.\r\n     * - `recipient` cannot be the zero address.\r\n     * - if `recipient` is a contract, it must implement the `tokensReceived`\r\n     * interface.\r\n     */\r\n    function operatorSend(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount,\r\n        bytes calldata data,\r\n        bytes calldata operatorData\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Destoys `amount` tokens from `account`, reducing the total supply.\r\n     * The caller must be an operator of `account`.\r\n     *\r\n     * If a send hook is registered for `account`, the corresponding function\r\n     * will be called with `data` and `operatorData`. See `IERC777Sender`.\r\n     *\r\n     * Emits a `Burned` event.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     * - the caller must be an operator for `account`.\r\n     */\r\n    function operatorBurn(\r\n        address account,\r\n        uint256 amount,\r\n        bytes calldata data,\r\n        bytes calldata operatorData\r\n    ) external;\r\n\r\n    event Sent(\r\n        address indexed operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 amount,\r\n        bytes data,\r\n        bytes operatorData\r\n    );\r\n\r\n    function decimals() external returns (uint8);\r\n\r\n    event Minted(address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData);\r\n\r\n    event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);\r\n\r\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\r\n\r\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\r\n}\r\n"
    },
    "contracts/interface/IBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\npragma abicoder v2;\r\ninterface IBridge {\r\n\r\n    struct ClaimData {\r\n        address payable to;\r\n        uint256 amount;\r\n        bytes32 blockHash;\r\n        bytes32 transactionHash;\r\n        uint32 logIndex;\r\n    }\r\n\r\n    function version() external pure returns (string memory);\r\n\r\n    function getFeePercentage() external view returns(uint);\r\n\r\n    /**\r\n     * ERC-20 tokens approve and transferFrom pattern\r\n     * See https://eips.ethereum.org/EIPS/eip-20#transferfrom\r\n     */\r\n    function receiveTokensTo(address tokenToUse, address to, uint256 amount) external;\r\n\r\n    /**\r\n     * Use network currency and cross it.\r\n     */\r\n    function depositTo(address to) external payable;\r\n\r\n    /**\r\n     * ERC-777 tokensReceived hook allows to send tokens to a contract and notify it in a single transaction\r\n     * See https://eips.ethereum.org/EIPS/eip-777#motivation for details\r\n     */\r\n    function tokensReceived (\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint amount,\r\n        bytes calldata userData,\r\n        bytes calldata operatorData\r\n    ) external;\r\n\r\n    /**\r\n     * Accepts the transaction from the other chain that was voted and sent by the Federation contract\r\n     */\r\n    function acceptTransfer(\r\n        address _originalTokenAddress,\r\n        address payable _from,\r\n        address payable _to,\r\n        uint256 _amount,\r\n        bytes32 _blockHash,\r\n        bytes32 _transactionHash,\r\n        uint32 _logIndex\r\n    ) external;\r\n\r\n    /**\r\n     * Claims the crossed transaction using the hash, this sends the funds to the address indicated in\r\n     */\r\n    function claim(ClaimData calldata _claimData) external returns (uint256 receivedAmount);\r\n\r\n    function claimFallback(ClaimData calldata _claimData) external returns (uint256 receivedAmount);\r\n\r\n    function claimGasless(\r\n        ClaimData calldata _claimData,\r\n        address payable _relayer,\r\n        uint256 _fee,\r\n        uint256 _deadline,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) external returns (uint256 receivedAmount);\r\n\r\n    function getTransactionDataHash(\r\n        address _to,\r\n        uint256 _amount,\r\n        bytes32 _blockHash,\r\n        bytes32 _transactionHash,\r\n        uint32 _logIndex\r\n    ) external returns(bytes32);\r\n\r\n    event Cross(\r\n        address indexed _tokenAddress,\r\n        address indexed _from,\r\n        address indexed _to,\r\n        uint256 _amount,\r\n        bytes _userData\r\n    );\r\n    event NewSideToken(\r\n        address indexed _newSideTokenAddress,\r\n        address indexed _originalTokenAddress,\r\n        string _newSymbol,\r\n        uint256 _granularity\r\n    );\r\n    event AcceptedCrossTransfer(\r\n        bytes32 indexed _transactionHash,\r\n        address indexed _originalTokenAddress,\r\n        address indexed _to,\r\n        address  _from,\r\n        uint256 _amount,\r\n        bytes32 _blockHash,\r\n        uint256 _logIndex\r\n    );\r\n    event FeePercentageChanged(uint256 _amount);\r\n    event Claimed(\r\n        bytes32 indexed _transactionHash,\r\n        address indexed _originalTokenAddress,\r\n        address indexed _to,\r\n        address _sender,\r\n        uint256 _amount,\r\n        bytes32 _blockHash,\r\n        uint256 _logIndex,\r\n        address _reciever,\r\n        address _relayer,\r\n        uint256 _fee\r\n    );\r\n}"
    },
    "contracts/interface/ISideToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\npragma abicoder v2;\r\n\r\ninterface ISideToken {\r\n    function mint(address account, uint256 amount, bytes calldata userData, bytes calldata operatorData) external;\r\n}"
    },
    "contracts/interface/ISideTokenFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\npragma abicoder v2;\r\n\r\ninterface ISideTokenFactory {\r\n\r\n    function createSideToken(string calldata name, string calldata symbol, uint256 granularity) external returns(address);\r\n\r\n    event SideTokenCreated(address indexed sideToken, string symbol, uint256 granularity);\r\n}"
    },
    "contracts/SideTokenFactory/SideTokenFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\npragma abicoder v2;\r\n\r\nimport \"../zeppelin/ownership/Secondary.sol\";\r\nimport \"../interface/ISideTokenFactory.sol\";\r\nimport \"../SideToken/SideToken.sol\";\r\n\r\ncontract SideTokenFactory is ISideTokenFactory, Secondary {\r\n\r\n    function createSideToken(string calldata name, string calldata symbol, uint256 granularity)\r\n    external onlyPrimary override returns(address) {\r\n        address sideToken = address(new SideToken(name, symbol, primary(), granularity));\r\n        emit SideTokenCreated(sideToken, symbol, granularity);\r\n        return sideToken;\r\n    }\r\n}"
    },
    "contracts/zeppelin/ownership/Secondary.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\npragma abicoder v2;\r\n\r\nimport \"../GSN/Context.sol\";\r\n/**\r\n * @dev A Secondary contract can only be used by its primary account (the one that created it).\r\n */\r\nabstract contract Secondary is Context {\r\n    address private _primary;\r\n\r\n    /**\r\n     * @dev Emitted when the primary contract changes.\r\n     */\r\n    event PrimaryTransferred(\r\n        address recipient\r\n    );\r\n\r\n    /**\r\n     * @dev Sets the primary account to the one that is creating the Secondary contract.\r\n     */\r\n    constructor () {\r\n        _primary = _msgSender();\r\n        emit PrimaryTransferred(_primary);\r\n    }\r\n\r\n    /**\r\n     * @dev Reverts if called from any account other than the primary.\r\n     */\r\n    modifier onlyPrimary() {\r\n        require(_msgSender() == _primary, \"Secondary: caller is not the primary account\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return the address of the primary.\r\n     */\r\n    function primary() public view returns (address) {\r\n        return _primary;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers contract to a new primary.\r\n     * @param recipient The address of new primary.\r\n     */\r\n    function transferPrimary(address recipient) public onlyPrimary {\r\n        require(recipient != address(0), \"Secondary: new primary is the zero address\");\r\n        _primary = recipient;\r\n        emit PrimaryTransferred(_primary);\r\n    }\r\n}\r\n"
    },
    "contracts/SideToken/SideToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\npragma abicoder v2;\r\n\r\nimport \"../zeppelin/token/ERC777/ERC777.sol\";\r\nimport \"../interface/IERC677Receiver.sol\";\r\nimport \"../interface/ISideToken.sol\";\r\nimport \"../lib/LibEIP712.sol\";\r\n\r\ncontract SideToken is ISideToken, ERC777 {\r\n    using Address for address;\r\n    using SafeMath for uint256;\r\n\r\n    address public minter;\r\n    uint256 private _granularity;\r\n\r\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-2612.md\r\n    bytes32 public domainSeparator;\r\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\r\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\r\n    mapping(address => uint) public nonces;\r\n\r\n    // ERC677 Transfer Event\r\n    event Transfer(address,address,uint256,bytes);\r\n\r\n    constructor(string memory _tokenName, string memory _tokenSymbol, address _minterAddr, uint256 _newGranularity)\r\n    ERC777(_tokenName, _tokenSymbol, new address[](0)) {\r\n        require(_minterAddr != address(0), \"SideToken: Empty Minter\");\r\n        require(_newGranularity >= 1, \"SideToken: Granularity < 1\");\r\n        minter = _minterAddr;\r\n        _granularity = _newGranularity;\r\n\r\n        uint chainId;\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            chainId := chainid()\r\n        }\r\n        domainSeparator = LibEIP712.hashEIP712Domain(\r\n            name(),\r\n            \"1\",\r\n            chainId,\r\n            address(this)\r\n        );\r\n    }\r\n\r\n    modifier onlyMinter() {\r\n      require(_msgSender() == minter, \"SideToken: Caller is not the minter\");\r\n      _;\r\n    }\r\n\r\n    function mint(\r\n        address account,\r\n        uint256 amount,\r\n        bytes calldata userData,\r\n        bytes calldata operatorData\r\n    )\r\n    external onlyMinter override\r\n    {\r\n        _mint(_msgSender(), account, amount, userData, operatorData);\r\n    }\r\n\r\n    /**\r\n    * @dev ERC677 transfer token with additional data if the recipient is a contact.\r\n    * @param recipient The address to transfer to.\r\n    * @param amount The amount to be transferred.\r\n    * @param data The extra data to be passed to the receiving contract.\r\n    */\r\n    function transferAndCall(address recipient, uint amount, bytes calldata data)\r\n        external returns (bool success)\r\n    {\r\n        address from = _msgSender();\r\n\r\n        _send(from, from, recipient, amount, data, \"\", false);\r\n        emit Transfer(from, recipient, amount, data);\r\n        IERC677Receiver(recipient).onTokenTransfer(from, amount, data);\r\n        return true;\r\n    }\r\n\r\n    function granularity() public view override returns (uint256) {\r\n        return _granularity;\r\n    }\r\n\r\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-2612.md\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\r\n        require(deadline >= block.timestamp, \"SideToken: EXPIRED\"); // solhint-disable-line not-rely-on-time\r\n        bytes32 digest = LibEIP712.hashEIP712Message(\r\n            domainSeparator,\r\n            keccak256(\r\n                abi.encode(\r\n                    PERMIT_TYPEHASH,\r\n                    owner,\r\n                    spender,\r\n                    value,\r\n                    nonces[owner]++,\r\n                    deadline\r\n                )\r\n            )\r\n        );\r\n        address recoveredAddress = ecrecover(digest, v, r, s);\r\n        require(recoveredAddress != address(0) && recoveredAddress == owner, \"SideToken: INVALID_SIGNATURE\");\r\n        _approve(owner, spender, value);\r\n    }\r\n\r\n}"
    },
    "contracts/zeppelin/token/ERC777/ERC777.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\npragma abicoder v2;\r\n\r\nimport \"../../GSN/Context.sol\";\r\nimport \"./IERC777.sol\";\r\nimport \"./IERC777Recipient.sol\";\r\nimport \"./IERC777Sender.sol\";\r\nimport \"../../token/ERC20/IERC20.sol\";\r\nimport \"../../math/SafeMath.sol\";\r\nimport \"../../utils/Address.sol\";\r\nimport \"../../introspection/IERC1820Registry.sol\";\r\n\r\n/**\r\n * @dev Implementation of the {IERC777} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n *\r\n * Support for ERC20 is included in this contract, as specified by the EIP: both\r\n * the ERC777 and ERC20 interfaces can be safely used when interacting with it.\r\n * Both {IERC777-Sent} and {IERC20-Transfer} events are emitted on token\r\n * movements.\r\n *\r\n * Additionally, the {IERC777-granularity} value is hard-coded to `1`, meaning that there\r\n * are no special restrictions in the amount of tokens that created, moved, or\r\n * destroyed. This makes integration with ERC20 applications seamless.\r\n */\r\ncontract ERC777 is Context, IERC777, IERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    IERC1820Registry constant private _erc1820 = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\r\n\r\n    mapping(address => uint256) private _balances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n\r\n    // We inline the result of the following hashes because Solidity doesn't resolve them at compile time.\r\n    // See https://github.com/ethereum/solidity/issues/4024.\r\n\r\n    // keccak256(\"ERC777TokensSender\")\r\n    bytes32 constant private TOKENS_SENDER_INTERFACE_HASH =\r\n        0x29ddb589b1fb5fc7cf394961c1adf5f8c6454761adf795e67fe149f658abe895;\r\n\r\n    // keccak256(\"ERC777TokensRecipient\")\r\n    bytes32 constant private TOKENS_RECIPIENT_INTERFACE_HASH =\r\n        0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b;\r\n\r\n    // This isn't ever read from - it's only used to respond to the defaultOperators query.\r\n    address[] private _defaultOperatorsArray;\r\n\r\n    // Immutable, but accounts may revoke them (tracked in __revokedDefaultOperators).\r\n    mapping(address => bool) private _defaultOperators;\r\n\r\n    // For each account, a mapping of its operators and revoked default operators.\r\n    mapping(address => mapping(address => bool)) private _operators;\r\n    mapping(address => mapping(address => bool)) private _revokedDefaultOperators;\r\n\r\n    // ERC20-allowances\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    /**\r\n     * @dev `defaultOperators` may be an empty array.\r\n     */\r\n    constructor(\r\n        string memory aName,\r\n        string memory aSymbol,\r\n        address[] memory theDefaultOperators\r\n    ) {\r\n        _name = aName;\r\n        _symbol = aSymbol;\r\n\r\n        _defaultOperatorsArray = theDefaultOperators;\r\n        for (uint256 i = 0; i < _defaultOperatorsArray.length; i++) {\r\n            _defaultOperators[_defaultOperatorsArray[i]] = true;\r\n        }\r\n\r\n        // register interfaces\r\n        _erc1820.setInterfaceImplementer(address(this), keccak256(\"ERC777Token\"), address(this));\r\n        _erc1820.setInterfaceImplementer(address(this), keccak256(\"ERC20Token\"), address(this));\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC777-name}.\r\n     */\r\n    function name() public view override(IERC777) returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC777-symbol}.\r\n     */\r\n    function symbol() public view override(IERC777) returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev See {ERC20Detailed-decimals}.\r\n     *\r\n     * Always returns 18, as per the\r\n     * [ERC777 EIP](https://eips.ethereum.org/EIPS/eip-777#backward-compatibility).\r\n     */\r\n    function decimals() public pure override returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC777-granularity}.\r\n     *\r\n     * This implementation always returns `1`.\r\n     */\r\n    function granularity() public view virtual override(IERC777) returns (uint256) {\r\n        return 1;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC777-totalSupply}.\r\n     */\r\n    function totalSupply() public view override(IERC20, IERC777) returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by an account (`tokenHolder`).\r\n     */\r\n    function balanceOf(address tokenHolder) public view override(IERC20, IERC777) returns (uint256) {\r\n        return _balances[tokenHolder];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC777-send}.\r\n     *\r\n     * Also emits a {Transfer} event for ERC20 compatibility.\r\n     */\r\n    function send(address recipient, uint256 amount, bytes calldata data) external override(IERC777) {\r\n        _send(_msgSender(), _msgSender(), recipient, amount, data, \"\", true);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Unlike `send`, `recipient` is _not_ required to implement the {IERC777Recipient}\r\n     * interface if it is a contract.\r\n     *\r\n     * Also emits a {Sent} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external override(IERC20) returns (bool) {\r\n        require(recipient != address(0), \"ERC777: transfer to zero address\");\r\n\r\n        address from = _msgSender();\r\n\r\n        _callTokensToSend(from, from, recipient, amount, \"\", \"\");\r\n\r\n        _move(from, from, recipient, amount, \"\", \"\");\r\n\r\n        _callTokensReceived(from, from, recipient, amount, \"\", \"\", false);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC777-burn}.\r\n     *\r\n     * Also emits a {Transfer} event for ERC20 compatibility.\r\n     */\r\n    function burn(uint256 amount, bytes calldata data) external override(IERC777) {\r\n        _burn(_msgSender(), _msgSender(), amount, data, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC777-isOperatorFor}.\r\n     */\r\n    function isOperatorFor(\r\n        address operator,\r\n        address tokenHolder\r\n    ) public view override(IERC777) returns (bool) {\r\n        return operator == tokenHolder ||\r\n            (_defaultOperators[operator] && !_revokedDefaultOperators[tokenHolder][operator]) ||\r\n            _operators[tokenHolder][operator];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC777-authorizeOperator}.\r\n     */\r\n    function authorizeOperator(address operator) external override(IERC777) {\r\n        require(_msgSender() != operator, \"ERC777: authorizing self as operator\");\r\n\r\n        if (_defaultOperators[operator]) {\r\n            delete _revokedDefaultOperators[_msgSender()][operator];\r\n        } else {\r\n            _operators[_msgSender()][operator] = true;\r\n        }\r\n\r\n        emit AuthorizedOperator(operator, _msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC777-revokeOperator}.\r\n     */\r\n    function revokeOperator(address operator) external override(IERC777) {\r\n        require(operator != _msgSender(), \"ERC777: revoking self as operator\");\r\n\r\n        if (_defaultOperators[operator]) {\r\n            _revokedDefaultOperators[_msgSender()][operator] = true;\r\n        } else {\r\n            delete _operators[_msgSender()][operator];\r\n        }\r\n\r\n        emit RevokedOperator(operator, _msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC777-defaultOperators}.\r\n     */\r\n    function defaultOperators() public view override(IERC777) returns (address[] memory) {\r\n        return _defaultOperatorsArray;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC777-operatorSend}.\r\n     *\r\n     * Emits {Sent} and {Transfer} events.\r\n     */\r\n    function operatorSend(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount,\r\n        bytes calldata data,\r\n        bytes calldata operatorData\r\n    )\r\n    external override(IERC777)\r\n    {\r\n        require(isOperatorFor(_msgSender(), sender), \"ERC777: caller is not an operator\");\r\n        _send(_msgSender(), sender, recipient, amount, data, operatorData, true);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC777-operatorBurn}.\r\n     *\r\n     * Emits {Burned} and {Transfer} events.\r\n     */\r\n    function operatorBurn(address account, uint256 amount, bytes calldata data, bytes calldata operatorData)\r\n    external override(IERC777) {\r\n        require(isOperatorFor(_msgSender(), account), \"ERC777: caller is not an operator\");\r\n        _burn(_msgSender(), account, amount, data, operatorData);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     *\r\n     * Note that operator and allowance concepts are orthogonal: operators may\r\n     * not have allowance, and accounts with allowance may not be operators\r\n     * themselves.\r\n     */\r\n    function allowance(address holder, address spender)\r\n    public view override(IERC20) returns (uint256) {\r\n        return _allowances[holder][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * Note that accounts cannot have allowance issued by their operators.\r\n     */\r\n    function approve(address spender, uint256 value) external override(IERC20) returns (bool) {\r\n        address holder = _msgSender();\r\n        _approve(holder, spender, value);\r\n        return true;\r\n    }\r\n\r\n   /**\r\n    * @dev See {IERC20-transferFrom}.\r\n    *\r\n    * Note that operator and allowance concepts are orthogonal: operators cannot\r\n    * call `transferFrom` (unless they have allowance), and accounts with\r\n    * allowance cannot call `operatorSend` (unless they are operators).\r\n    *\r\n    * Emits {Sent}, {Transfer} and {Approval} events.\r\n    */\r\n    function transferFrom(address holder, address recipient, uint256 amount)\r\n    external override(IERC20) returns (bool) {\r\n        require(recipient != address(0), \"ERC777: transfer to zero address\");\r\n        require(holder != address(0), \"ERC777: transfer from zero address\");\r\n\r\n        address spender = _msgSender();\r\n\r\n        _callTokensToSend(spender, holder, recipient, amount, \"\", \"\");\r\n\r\n        _move(spender, holder, recipient, amount, \"\", \"\");\r\n        _approve(holder, spender, _allowances[holder][spender].sub(amount, \"ERC777: transfer amount exceeds allowance\"));\r\n\r\n        _callTokensReceived(spender, holder, recipient, amount, \"\", \"\", false);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * If a send hook is registered for `account`, the corresponding function\r\n     * will be called with `operator`, `data` and `operatorData`.\r\n     *\r\n     * See {IERC777Sender} and {IERC777Recipient}.\r\n     *\r\n     * Emits {Minted} and {Transfer} events.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - if `account` is a contract, it must implement the {IERC777Recipient}\r\n     * interface.\r\n     */\r\n    function _mint(\r\n        address operator,\r\n        address account,\r\n        uint256 amount,\r\n        bytes memory userData,\r\n        bytes memory operatorData\r\n    )\r\n    internal\r\n    {\r\n        require(account != address(0), \"ERC777: mint to zero address\");\r\n\r\n        // Update state variables\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n\r\n        _callTokensReceived(operator, address(0), account, amount, userData, operatorData, true);\r\n\r\n        emit Minted(operator, account, amount, userData, operatorData);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Send tokens\r\n     * @param operator address operator requesting the transfer\r\n     * @param from address token holder address\r\n     * @param to address recipient address\r\n     * @param amount uint256 amount of tokens to transfer\r\n     * @param userData bytes extra information provided by the token holder (if any)\r\n     * @param operatorData bytes extra information provided by the operator (if any)\r\n     * @param requireReceptionAck if true, contract recipients are required to implement ERC777TokensRecipient\r\n     */\r\n    function _send(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        bytes memory userData,\r\n        bytes memory operatorData,\r\n        bool requireReceptionAck\r\n    )\r\n        internal\r\n    {\r\n        require(from != address(0), \"ERC777: send from zero address\");\r\n        require(to != address(0), \"ERC777: send to zero address\");\r\n\r\n        _callTokensToSend(operator, from, to, amount, userData, operatorData);\r\n\r\n        _move(operator, from, to, amount, userData, operatorData);\r\n\r\n        _callTokensReceived(operator, from, to, amount, userData, operatorData, requireReceptionAck);\r\n    }\r\n\r\n    /**\r\n     * @dev Burn tokens\r\n     * @param operator address operator requesting the operation\r\n     * @param from address token holder address\r\n     * @param amount uint256 amount of tokens to burn\r\n     * @param data bytes extra information provided by the token holder\r\n     * @param operatorData bytes extra information provided by the operator (if any)\r\n     */\r\n    function _burn(\r\n        address operator,\r\n        address from,\r\n        uint256 amount,\r\n        bytes memory data,\r\n        bytes memory operatorData\r\n    )\r\n        internal\r\n    {\r\n        require(from != address(0), \"ERC777: burn from zero address\");\r\n\r\n        _callTokensToSend(operator, from, address(0), amount, data, operatorData);\r\n\r\n        // Update state variables\r\n        _balances[from] = _balances[from].sub(amount, \"ERC777: burn amount exceeds balance\");\r\n        _totalSupply = _totalSupply.sub(amount);\r\n\r\n        emit Burned(operator, from, amount, data, operatorData);\r\n        emit Transfer(from, address(0), amount);\r\n    }\r\n\r\n    function _move(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        bytes memory userData,\r\n        bytes memory operatorData\r\n    )\r\n        internal\r\n    {\r\n        _balances[from] = _balances[from].sub(amount, \"ERC777: transfer amount exceeds balance\");\r\n        _balances[to] = _balances[to].add(amount);\r\n\r\n        emit Sent(operator, from, to, amount, userData, operatorData);\r\n        emit Transfer(from, to, amount);\r\n    }\r\n\r\n    function _approve(address holder, address spender, uint256 value) internal {\r\n        // TODO: restore this require statement if this function becomes internal, or is called at a new callsite. It is\r\n        // currently unnecessary.\r\n        //require(holder != address(0), \"ERC777: approve from the zero address\");\r\n        require(spender != address(0), \"ERC777: approve to zero address\");\r\n\r\n        _allowances[holder][spender] = value;\r\n        emit Approval(holder, spender, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Call from.tokensToSend() if the interface is registered\r\n     * @param operator address operator requesting the transfer\r\n     * @param from address token holder address\r\n     * @param to address recipient address\r\n     * @param amount uint256 amount of tokens to transfer\r\n     * @param userData bytes extra information provided by the token holder (if any)\r\n     * @param operatorData bytes extra information provided by the operator (if any)\r\n     */\r\n    function _callTokensToSend(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        bytes memory userData,\r\n        bytes memory operatorData\r\n    )\r\n        internal\r\n    {\r\n        address implementer = _erc1820.getInterfaceImplementer(from, TOKENS_SENDER_INTERFACE_HASH);\r\n        if (implementer != address(0)) {\r\n            IERC777Sender(implementer).tokensToSend(operator, from, to, amount, userData, operatorData);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Call to.tokensReceived() if the interface is registered. Reverts if the recipient is a contract but\r\n     * tokensReceived() was not registered for the recipient\r\n     * @param operator address operator requesting the transfer\r\n     * @param from address token holder address\r\n     * @param to address recipient address\r\n     * @param amount uint256 amount of tokens to transfer\r\n     * @param userData bytes extra information provided by the token holder (if any)\r\n     * @param operatorData bytes extra information provided by the operator (if any)\r\n     * @param requireReceptionAck if true, contract recipients are required to implement ERC777TokensRecipient\r\n     */\r\n    function _callTokensReceived(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        bytes memory userData,\r\n        bytes memory operatorData,\r\n        bool requireReceptionAck\r\n    )\r\n        private\r\n    {\r\n         address implementer = _erc1820.getInterfaceImplementer(to, TOKENS_RECIPIENT_INTERFACE_HASH);\r\n        if (implementer != address(0)) {\r\n            IERC777Recipient(implementer).tokensReceived(operator, from, to, amount, userData, operatorData);\r\n        } else if (requireReceptionAck) {\r\n            require(!to.isContract(), \"ERC777: token recipient contract has no implementer for ERC777TokensRecipient\");\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/interface/IERC677Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\npragma abicoder v2;\r\n\r\ninterface IERC677Receiver {\r\n  function onTokenTransfer(address _sender, uint _value, bytes calldata _data) external;\r\n}"
    },
    "contracts/zeppelin/token/ERC777/IERC777Sender.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\npragma abicoder v2;\r\n\r\n/**\r\n * @dev Interface of the ERC777TokensSender standard as defined in the EIP.\r\n *\r\n * `IERC777` Token holders can be notified of operations performed on their\r\n * tokens by having a contract implement this interface (contract holders can be\r\n *  their own implementer) and registering it on the\r\n * [ERC1820 global registry](https://eips.ethereum.org/EIPS/eip-1820).\r\n *\r\n * See `IERC1820Registry` and `ERC1820Implementer`.\r\n */\r\ninterface IERC777Sender {\r\n    /**\r\n     * @dev Called by an `IERC777` token contract whenever a registered holder's\r\n     * (`from`) tokens are about to be moved or destroyed. The type of operation\r\n     * is conveyed by `to` being the zero address or not.\r\n     *\r\n     * This call occurs _before_ the token contract's state is updated, so\r\n     * `IERC777.balanceOf`, etc., can be used to query the pre-operation state.\r\n     *\r\n     * This function may revert to prevent the operation from being executed.\r\n     */\r\n    function tokensToSend(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint amount,\r\n        bytes calldata userData,\r\n        bytes calldata operatorData\r\n    ) external;\r\n}\r\n"
    },
    "contracts/Bridge/BridgeV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\n\r\n// Import base Initializable contract\r\nimport \"../zeppelin/upgradable/Initializable.sol\";\r\n// Import interface and library from OpenZeppelin contracts\r\nimport \"../zeppelin/upgradable/utils/ReentrancyGuard.sol\";\r\nimport \"../zeppelin/upgradable/lifecycle/UpgradablePausable.sol\";\r\nimport \"../zeppelin/upgradable/ownership/UpgradableOwnable.sol\";\r\n\r\nimport \"../zeppelin/introspection/IERC1820Registry.sol\";\r\nimport \"../zeppelin/token/ERC777/IERC777Recipient.sol\";\r\nimport \"../zeppelin/token/ERC20/IERC20.sol\";\r\nimport \"../zeppelin/token/ERC20/SafeERC20.sol\";\r\nimport \"../zeppelin/token/ERC777/IERC777.sol\";\r\nimport \"../zeppelin/utils/Address.sol\";\r\nimport \"../zeppelin/math/SafeMath.sol\";\r\n\r\nimport \"./IBridgeV2.sol\";\r\nimport \"../interface/ISideToken.sol\";\r\nimport \"../interface/ISideTokenFactory.sol\";\r\nimport \"../AllowTokens/AllowTokensV0.sol\";\r\nimport \"../Utils/UtilsV1.sol\";\r\n\r\ncontract BridgeV2 is Initializable, IBridgeV2, IERC777Recipient, UpgradablePausable, UpgradableOwnable, ReentrancyGuard {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n    using Address for address;\r\n\r\n    address constant private NULL_ADDRESS = address(0);\r\n    bytes32 constant private NULL_HASH = bytes32(0);\r\n    IERC1820Registry constant private ERC_1820 = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\r\n\r\n    address private federation;\r\n    uint256 private feePercentage;\r\n    string public symbolPrefix;\r\n    uint256 public lastDay;\r\n    uint256 public spentToday;\r\n\r\n    mapping (address => address) public mappedTokens; // OirignalToken => SideToken\r\n    mapping (address => address) public originalTokens; // SideToken => OriginalToken\r\n    mapping (address => bool) public knownTokens; // OriginalToken => true\r\n    mapping(bytes32 => bool) public processed; // ProcessedHash => true\r\n    AllowTokensV0 public allowTokens;\r\n    ISideTokenFactory public sideTokenFactory;\r\n    //Bridge_v1 variables\r\n    bool public isUpgrading;\r\n    uint256 constant public FEE_PERCENTAGE_DIVIDER = 10000; // Percentage with up to 2 decimals\r\n    bool private alreadyRun;\r\n\r\n    event FederationChanged(address _newFederation);\r\n    event SideTokenFactoryChanged(address _newSideTokenFactory);\r\n    event Upgrading(bool isUpgrading);\r\n    function initialize(\r\n        address _manager,\r\n        address _federation,\r\n        address _allowTokens,\r\n        address _sideTokenFactory,\r\n        string memory _symbolPrefix\r\n    ) public initializer {\r\n        UpgradableOwnable.initialize(_manager);\r\n        UpgradablePausable.__Pausable_init(_manager);\r\n        symbolPrefix = _symbolPrefix;\r\n        allowTokens = AllowTokensV0(_allowTokens);\r\n        _changeSideTokenFactory(_sideTokenFactory);\r\n        _changeFederation(_federation);\r\n        //keccak256(\"ERC777TokensRecipient\")\r\n        ERC_1820.setInterfaceImplementer(address(this), 0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b, address(this));\r\n    }\r\n\r\n    function version() external pure override returns (string memory) {\r\n        return \"v2\";\r\n    }\r\n\r\n    modifier onlyFederation() {\r\n        require(msg.sender == federation, \"Bridge: Sender not Federation\");\r\n        _;\r\n    }\r\n\r\n    modifier whenNotUpgrading() {\r\n        require(!isUpgrading, \"Bridge: Upgrading\");\r\n        _;\r\n    }\r\n\r\n    function acceptTransfer(\r\n        address tokenAddress,\r\n        address receiver,\r\n        uint256 amount,\r\n        string calldata symbol,\r\n        bytes32 blockHash,\r\n        bytes32 transactionHash,\r\n        uint32 logIndex,\r\n        uint8 decimals,\r\n        uint256 granularity\r\n    ) external onlyFederation whenNotPaused nonReentrant override returns(bool) {\r\n        require(tokenAddress != NULL_ADDRESS, \"Bridge: Token is null\");\r\n        require(receiver != NULL_ADDRESS, \"Bridge: Receiver is null\");\r\n        require(amount > 0, \"Bridge: Amount 0\");\r\n        require(bytes(symbol).length > 0, \"Bridge: Empty symbol\");\r\n        require(blockHash != NULL_HASH, \"Bridge: BlockHash is null\");\r\n        require(transactionHash != NULL_HASH, \"Bridge: Transaction is null\");\r\n        require(decimals <= 18, \"Bridge: Decimals bigger 18\");\r\n        require(UtilsV1.granularityToDecimals(granularity) <= 18, \"Bridge: invalid granularity\");\r\n\r\n        _processTransaction(blockHash, transactionHash, receiver, amount, logIndex);\r\n\r\n        if (knownTokens[tokenAddress]) {\r\n            _acceptCrossBackToToken(receiver, tokenAddress, decimals, granularity, amount);\r\n        } else {\r\n            _acceptCrossToSideToken(receiver, tokenAddress, decimals, granularity, amount, symbol);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function _acceptCrossToSideToken(\r\n        address receiver,\r\n        address tokenAddress,\r\n        uint8 decimals,\r\n        uint256 granularity,\r\n        uint256 amount,\r\n        string memory symbol\r\n    ) private {\r\n\r\n        (uint256 calculatedGranularity,uint256 formattedAmount) = UtilsV1.calculateGranularityAndAmount(decimals, granularity, amount);\r\n        address sideToken = mappedTokens[tokenAddress];\r\n        if (sideToken == NULL_ADDRESS) {\r\n            sideToken = _createSideToken(tokenAddress, symbol, calculatedGranularity);\r\n        } else {\r\n            require(calculatedGranularity == IERC777(sideToken).granularity(), \"Bridge: Granularity differ from side token\");\r\n        }\r\n        ISideToken(sideToken).mint(receiver, formattedAmount, \"\", \"\");\r\n        emit AcceptedCrossTransfer(tokenAddress, receiver, amount, decimals, granularity, formattedAmount, 18, calculatedGranularity);\r\n    }\r\n\r\n    function _acceptCrossBackToToken(address receiver, address tokenAddress, uint8 decimals, uint256 granularity, uint256 amount) private {\r\n        require(decimals == 18, \"Bridge: Invalid decimals cross back\");\r\n        //As side tokens are ERC777 we need to convert granularity to decimals\r\n        (uint8 calculatedDecimals, uint256 formattedAmount) = UtilsV1.calculateDecimalsAndAmount(tokenAddress, granularity, amount);\r\n        IERC20(tokenAddress).safeTransfer(receiver, formattedAmount);\r\n        emit AcceptedCrossTransfer(tokenAddress, receiver, amount, decimals, granularity, formattedAmount, calculatedDecimals, 1);\r\n    }\r\n\r\n    /**\r\n     * ERC-20 tokens approve and transferFrom pattern\r\n     * See https://eips.ethereum.org/EIPS/eip-20#transferfrom\r\n     */\r\n    function receiveTokens(address tokenToUse, uint256 amount) override external whenNotUpgrading whenNotPaused nonReentrant returns(bool) {\r\n        address sender = _msgSender();\r\n        require(!sender.isContract(), \"Bridge: Sender can't be a contract\");\r\n        //Transfer the tokens on IERC20, they should be already Approved for the bridge Address to use them\r\n        IERC20(tokenToUse).safeTransferFrom(sender, address(this), amount);\r\n        crossTokens(tokenToUse, sender, amount, \"\");\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * ERC-777 tokensReceived hook allows to send tokens to a contract and notify it in a single transaction\r\n     * See https://eips.ethereum.org/EIPS/eip-777#motivation for details\r\n     */\r\n    function tokensReceived (\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint amount,\r\n        bytes calldata userData,\r\n        bytes calldata\r\n    ) external whenNotPaused whenNotUpgrading override(IBridgeV2, IERC777Recipient) {\r\n        //Hook from ERC777address\r\n        if(operator == address(this)) return; // Avoid loop from bridge calling to ERC77transferFrom\r\n        require(to == address(this), \"Bridge: Not to address\");\r\n        address tokenToUse = _msgSender();\r\n        //This can only be used with trusted contracts\r\n        crossTokens(tokenToUse, from, amount, userData);\r\n    }\r\n\r\n    function crossTokens(address tokenToUse, address from, uint256 amount, bytes memory userData) private {\r\n        bool isASideToken = originalTokens[tokenToUse] != NULL_ADDRESS;\r\n        //Send the payment to the MultiSig of the Federation\r\n        uint256 fee = amount.mul(feePercentage).div(FEE_PERCENTAGE_DIVIDER);\r\n        uint256 amountMinusFees = amount.sub(fee);\r\n        if (isASideToken) {\r\n            uint256 modulo = amountMinusFees.mod(IERC777(tokenToUse).granularity());\r\n            fee = fee.add(modulo);\r\n            amountMinusFees = amountMinusFees.sub(modulo);\r\n        }\r\n        if(fee > 0) {\r\n            IERC20(tokenToUse).safeTransfer(owner(), fee);\r\n        }\r\n        if (isASideToken) {\r\n            verifyWithAllowTokens(tokenToUse, amount, isASideToken);\r\n            //Side Token Crossing\r\n            IERC777(tokenToUse).burn(amountMinusFees, userData);\r\n            // solium-disable-next-line max-len\r\n            emit Cross(originalTokens[tokenToUse], from, amountMinusFees, IERC777(tokenToUse).symbol(), userData, IERC777(tokenToUse).decimals(), IERC777(tokenToUse).granularity());\r\n        } else {\r\n            //Main Token Crossing\r\n            knownTokens[tokenToUse] = true;\r\n            (uint8 decimals, uint256 granularity, string memory symbol) = UtilsV1.getTokenInfo(tokenToUse);\r\n            uint formattedAmount = amount;\r\n            if(decimals != 18) {\r\n                formattedAmount = amount.mul(uint256(10)**(18-decimals));\r\n            }\r\n            //We consider the amount before fees converted to 18 decimals to check the limits\r\n            verifyWithAllowTokens(tokenToUse, formattedAmount, isASideToken);\r\n            emit Cross(tokenToUse, from, amountMinusFees, symbol, userData, decimals, granularity);\r\n        }\r\n    }\r\n\r\n    function _createSideToken(address token, string memory symbol, uint256 granularity) private returns (address sideToken){\r\n        string memory newSymbol = string(abi.encodePacked(symbolPrefix, symbol));\r\n        address sideTokenAddress = sideTokenFactory.createSideToken(newSymbol, newSymbol, granularity);\r\n        sideToken = sideTokenAddress;\r\n        mappedTokens[token] = sideToken;\r\n        originalTokens[sideTokenAddress] = token;\r\n        emit NewSideToken(sideTokenAddress, token, newSymbol, granularity);\r\n        return sideToken;\r\n    }\r\n\r\n    function verifyWithAllowTokens(address tokenToUse, uint256 amount, bool isASideToken) private  {\r\n        // solium-disable-next-line security/no-block-members\r\n        if (block.timestamp > lastDay + 24 hours) { // solhint-disable-line not-rely-on-time\r\n            // solium-disable-next-line security/no-block-members\r\n            lastDay = block.timestamp; // solhint-disable-line not-rely-on-time\r\n            spentToday = 0;\r\n        }\r\n        require(allowTokens.isValidTokenTransfer(tokenToUse, amount, spentToday, isASideToken), \"Bridge: Bigger than limit\");\r\n        spentToday = spentToday.add(amount);\r\n    }\r\n\r\n    function getTransactionId(\r\n        bytes32 _blockHash,\r\n        bytes32 _transactionHash,\r\n        address _receiver,\r\n        uint256 _amount,\r\n        uint32 _logIndex\r\n    )\r\n        public pure returns(bytes32)\r\n    {\r\n        return keccak256(abi.encodePacked(_blockHash, _transactionHash, _receiver, _amount, _logIndex));\r\n    }\r\n\r\n    function _processTransaction(\r\n        bytes32 _blockHash,\r\n        bytes32 _transactionHash,\r\n        address _receiver,\r\n        uint256 _amount,\r\n        uint32 _logIndex\r\n    )\r\n        private\r\n    {\r\n        bytes32 compiledId = getTransactionId(_blockHash, _transactionHash, _receiver, _amount, _logIndex);\r\n        require(!processed[compiledId], \"Bridge: Already processed\");\r\n        processed[compiledId] = true;\r\n    }\r\n\r\n    function setFeePercentage(uint amount) external onlyOwner whenNotPaused {\r\n        require(amount < (FEE_PERCENTAGE_DIVIDER/10), \"Bridge: bigger than 10%\");\r\n        feePercentage = amount;\r\n        emit FeePercentageChanged(feePercentage);\r\n    }\r\n\r\n    function getFeePercentage() override external view returns(uint) {\r\n        return feePercentage;\r\n    }\r\n\r\n    function calcMaxWithdraw() override external view returns (uint) {\r\n        uint spent = spentToday;\r\n        // solium-disable-next-line security/no-block-members\r\n        if (block.timestamp > lastDay + 24 hours) // solhint-disable-line not-rely-on-time\r\n            spent = 0;\r\n        return allowTokens.calcMaxWithdraw(spent);\r\n    }\r\n\r\n    function changeFederation(address newFederation) external onlyOwner returns(bool) {\r\n        _changeFederation(newFederation);\r\n        return true;\r\n    }\r\n\r\n    function _changeFederation(address newFederation) internal {\r\n        require(newFederation != NULL_ADDRESS, \"Bridge: Federation is empty\");\r\n        federation = newFederation;\r\n        emit FederationChanged(federation);\r\n    }\r\n\r\n    function getFederation() external view returns(address) {\r\n        return federation;\r\n    }\r\n\r\n    function changeSideTokenFactory(address newSideTokenFactory) external onlyOwner returns(bool) {\r\n        _changeSideTokenFactory(newSideTokenFactory);\r\n        return true;\r\n    }\r\n\r\n    function _changeSideTokenFactory(address newSideTokenFactory) internal {\r\n        require(newSideTokenFactory != NULL_ADDRESS, \"Bridge: SideTokenFactory is empty\");\r\n        sideTokenFactory = ISideTokenFactory(newSideTokenFactory);\r\n        emit SideTokenFactoryChanged(newSideTokenFactory);\r\n    }\r\n\r\n    function startUpgrade() external onlyOwner {\r\n        isUpgrading = true;\r\n        emit Upgrading(isUpgrading);\r\n    }\r\n\r\n    function endUpgrade() external onlyOwner {\r\n        isUpgrading = false;\r\n        emit Upgrading(isUpgrading);\r\n    }\r\n\r\n    //This method is only to recreate the USDT and USDC tokens on rsk without granularity restrictions.\r\n    function clearSideToken() external onlyOwner returns(bool) {\r\n        require(!alreadyRun, \"already done\");\r\n        alreadyRun = true;\r\n        address payable[4] memory sideTokens = [\r\n            0xe506F698b31a66049BD4653ed934E7a07Cbc5549,\r\n            0x5a42221D7AaE8e185BC0054Bb036D9757eC18857,\r\n            0xcdc8ccBbFB6407c53118fE47259e8d00C81F42CD,\r\n            0x6117C9529F15c52e2d3188d5285C745B757b5825\r\n        ];\r\n        for (uint i = 0; i < sideTokens.length; i++) {\r\n            address originalToken = address(originalTokens[sideTokens[i]]);\r\n            originalTokens[sideTokens[i]] = NULL_ADDRESS;\r\n            mappedTokens[originalToken] = address(NULL_ADDRESS);\r\n        }\r\n        return true;\r\n    }\r\n\r\n}\r\n"
    },
    "contracts/Bridge/IBridgeV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\n\r\ninterface IBridgeV2 {function version() external pure returns (string memory);\r\n\r\n    function getFeePercentage() external view returns(uint);\r\n\r\n    function calcMaxWithdraw() external view returns (uint);\r\n\r\n    /**\r\n     * ERC-20 tokens approve and transferFrom pattern\r\n     * See https://eips.ethereum.org/EIPS/eip-20#transferfrom\r\n     */\r\n    function receiveTokens(address tokenToUse, uint256 amount) external returns(bool);\r\n\r\n    /**\r\n     * ERC-777 tokensReceived hook allows to send tokens to a contract and notify it in a single transaction\r\n     * See https://eips.ethereum.org/EIPS/eip-777#motivation for details\r\n     */\r\n    function tokensReceived (\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint amount,\r\n        bytes calldata userData,\r\n        bytes calldata operatorData\r\n    ) external;\r\n\r\n    /**\r\n     * Accepts the transaction from the other chain that was voted and sent by the federation contract\r\n     */\r\n    function acceptTransfer(\r\n        address originalTokenAddress,\r\n        address receiver,\r\n        uint256 amount,\r\n        string calldata symbol,\r\n        bytes32 blockHash,\r\n        bytes32 transactionHash,\r\n        uint32 logIndex,\r\n        uint8 decimals,\r\n        uint256 granularity\r\n    ) external returns(bool);\r\n\r\n    event Cross(address indexed _tokenAddress, address indexed _to, uint256 _amount, string _symbol, bytes _userData,\r\n        uint8 _decimals, uint256 _granularity);\r\n    event NewSideToken(address indexed _newSideTokenAddress, address indexed _originalTokenAddress, string _newSymbol, uint256 _granularity);\r\n    event AcceptedCrossTransfer(address indexed _tokenAddress, address indexed _to, uint256 _amount, uint8 _decimals, uint256 _granularity,\r\n        uint256 _formattedAmount, uint8 _calculatedDecimals, uint256 _calculatedGranularity);\r\n    event FeePercentageChanged(uint256 _amount);\r\n}"
    },
    "contracts/AllowTokens/AllowTokensV0.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\n\r\nimport \"../zeppelin/math/SafeMath.sol\";\r\nimport \"../zeppelin/ownership/Ownable.sol\";\r\n\r\ncontract AllowTokensV0 is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    address constant private NULL_ADDRESS = address(0);\r\n\r\n    mapping (address => bool) public allowedTokens;\r\n    bool private validateAllowedTokens;\r\n    uint256 private maxTokensAllowed;\r\n    uint256 private minTokensAllowed;\r\n    uint256 public dailyLimit;\r\n\r\n    event AllowedTokenAdded(address indexed _tokenAddress);\r\n    event AllowedTokenRemoved(address indexed _tokenAddress);\r\n    event AllowedTokenValidation(bool _enabled);\r\n    event MaxTokensAllowedChanged(uint256 _maxTokens);\r\n    event MinTokensAllowedChanged(uint256 _minTokens);\r\n    event DailyLimitChanged(uint256 dailyLimit);\r\n\r\n    modifier notNull(address _address) {\r\n        require(_address != NULL_ADDRESS, \"AllowTokens: Address cannot be empty\");\r\n        _;\r\n    }\r\n\r\n    constructor(address _manager)  {\r\n        transferOwnership(_manager);\r\n        validateAllowedTokens = true;\r\n        maxTokensAllowed = 10000 ether;\r\n        minTokensAllowed = 1 ether;\r\n        dailyLimit = 100000 ether;\r\n    }\r\n\r\n    function isValidatingAllowedTokens() external view returns(bool) {\r\n        return validateAllowedTokens;\r\n    }\r\n\r\n    function getMaxTokensAllowed() external view returns(uint256) {\r\n        return maxTokensAllowed;\r\n    }\r\n\r\n    function getMinTokensAllowed() external view returns(uint256) {\r\n        return minTokensAllowed;\r\n    }\r\n\r\n    function allowedTokenExist(address token) private view notNull(token) returns (bool) {\r\n        return allowedTokens[token];\r\n    }\r\n\r\n    function isTokenAllowed(address token) public view notNull(token) returns (bool) {\r\n        if (validateAllowedTokens) {\r\n            return allowedTokenExist(token);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function addAllowedToken(address token) external onlyOwner {\r\n        require(!allowedTokenExist(token), \"AllowTokens: Token already exists in allowedTokens\");\r\n        allowedTokens[token] = true;\r\n        emit AllowedTokenAdded(token);\r\n    }\r\n\r\n    function removeAllowedToken(address token) external onlyOwner {\r\n        require(allowedTokenExist(token), \"AllowTokens: Token does not exis  in allowedTokenst\");\r\n        allowedTokens[token] = false;\r\n        emit AllowedTokenRemoved(token);\r\n    }\r\n\r\n    function enableAllowedTokensValidation() external onlyOwner {\r\n        validateAllowedTokens = true;\r\n        emit AllowedTokenValidation(validateAllowedTokens);\r\n    }\r\n\r\n    function disableAllowedTokensValidation() external onlyOwner {\r\n        // Before disabling Allowed Tokens Validations some kind of contract validation system\r\n        // should be implemented on the Bridge for the methods receiveTokens, tokenFallback and tokensReceived\r\n        validateAllowedTokens = false;\r\n        emit AllowedTokenValidation(validateAllowedTokens);\r\n    }\r\n\r\n    function setMaxTokensAllowed(uint256 maxTokens) external onlyOwner {\r\n        require(maxTokens >= minTokensAllowed, \"AllowTokens: Max Tokens should be equal or bigger than Min Token\");\r\n        maxTokensAllowed = maxTokens;\r\n        emit MaxTokensAllowedChanged(maxTokensAllowed);\r\n    }\r\n\r\n    function setMinTokensAllowed(uint256 minTokens) external onlyOwner {\r\n        require(maxTokensAllowed >= minTokens, \"AllowTokens: minTokens should be equal or smaller than maxTokens\");\r\n        minTokensAllowed = minTokens;\r\n        emit MinTokensAllowedChanged(minTokensAllowed);\r\n    }\r\n\r\n    function changeDailyLimit(uint256 _dailyLimit) external onlyOwner {\r\n        require(_dailyLimit >= maxTokensAllowed, \"AllowTokens: dailyLimit should be equal or bigger than maxTokens\");\r\n        dailyLimit = _dailyLimit;\r\n        emit DailyLimitChanged(_dailyLimit);\r\n    }\r\n\r\n    // solium-disable-next-line max-len\r\n    function isValidTokenTransfer(address tokenToUse, uint amount, uint spentToday, bool isSideToken) external view returns (bool) {\r\n        if(amount > maxTokensAllowed)\r\n            return false;\r\n        if(amount < minTokensAllowed)\r\n            return false;\r\n        if (spentToday + amount > dailyLimit || spentToday + amount < spentToday)\r\n            return false;\r\n        if(!isSideToken && !isTokenAllowed(tokenToUse))\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    function calcMaxWithdraw(uint spentToday) external view returns (uint) {\r\n        uint maxWithrow = dailyLimit - spentToday;\r\n        if (dailyLimit < spentToday)\r\n            return 0;\r\n        if(maxWithrow > maxTokensAllowed)\r\n            maxWithrow = maxTokensAllowed;\r\n        return maxWithrow;\r\n    }\r\n\r\n}\r\n"
    },
    "contracts/Utils/UtilsV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\n\r\nimport \"../zeppelin/math/SafeMath.sol\";\r\nimport \"../zeppelin/introspection/IERC1820Registry.sol\";\r\nimport \"../zeppelin/token/ERC777/IERC777.sol\";\r\n\r\nlibrary UtilsV1 {\r\n    using SafeMath for uint256;\r\n\r\n    IERC1820Registry constant private ERC_1820 = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\r\n    // keccak256(\"ERC777Token\")\r\n    bytes32 constant private TOKENS_ERC777_HASH = 0xac7fbab5f54a3ca8194167523c6753bfeb96a445279294b6125b68cce2177054;\r\n\r\n    function getTokenInfo(address tokenToUse) external view returns (uint8 decimals, uint256 granularity, string memory symbol) {\r\n        decimals = getDecimals(tokenToUse);\r\n        granularity = getGranularity(tokenToUse);\r\n        symbol = getSymbol(tokenToUse);\r\n    }\r\n\r\n    function getSymbol(address tokenToUse) public view returns (string memory symbol) {\r\n        //support 32 bytes or string symbol\r\n        (bool success, bytes memory data) = tokenToUse.staticcall(abi.encodeWithSignature(\"symbol()\"));\r\n        require(success, \"Utils: Token hasn't symbol()\");\r\n        if (data.length == 32) {\r\n            symbol = bytes32ToString(abi.decode(data, (bytes32)));\r\n        } else {\r\n            symbol = abi.decode(data, (string));\r\n        }\r\n        require(bytes(symbol).length > 0, \"Utils: Token empty symbol\");\r\n        return symbol;\r\n    }\r\n\r\n    function getDecimals(address tokenToUse) public view returns (uint8) {\r\n        //support decimals as uint256 or uint8\r\n        (bool success, bytes memory data) = tokenToUse.staticcall(abi.encodeWithSignature(\"decimals()\"));\r\n        require(success, \"Utils: No decimals\");\r\n        require(data.length == 32, \"Utils: Decimals not uint<M>\");\r\n        // uint<M>: enc(X) is the big-endian encoding of X,\r\n        //padded on the higher-order (left) side with zero-bytes such that the length is 32 bytes.\r\n        uint256 decimalsDecoded = abi.decode(data, (uint256));\r\n        require(decimalsDecoded <= 18, \"Utils: Decimals not in 0 to 18\");\r\n        return uint8(decimalsDecoded);\r\n    }\r\n\r\n    function getGranularity(address tokenToUse) public view returns (uint256 granularity) {\r\n        granularity = 1;\r\n        //support granularity if ERC777\r\n        address implementer = ERC_1820.getInterfaceImplementer(tokenToUse, TOKENS_ERC777_HASH);\r\n        if (implementer != address(0)) {\r\n            granularity = IERC777(implementer).granularity();\r\n            //Verify granularity is power of 10 to keep it compatible with ERC20 decimals\r\n            granularityToDecimals(granularity);\r\n        }\r\n        return granularity;\r\n    }\r\n\r\n    /* bytes32 (fixed-size array) to string (dynamically-sized array) */\r\n    function bytes32ToString(bytes32 _bytes32) internal pure returns (string memory) {\r\n        uint8 i = 0;\r\n        while(i < 32 && _bytes32[i] != 0) {\r\n            i++;\r\n        }\r\n        bytes memory bytesArray = new bytes(i);\r\n        for (i = 0; i < 32 && _bytes32[i] != 0; i++) {\r\n            bytesArray[i] = _bytes32[i];\r\n        }\r\n        return string(bytesArray);\r\n    }\r\n\r\n    function decimalsToGranularity(uint8 decimals) public pure returns (uint256) {\r\n        require(decimals <= 18, \"Utils: Decimals not in 0 to 18\");\r\n        return uint256(10)**(18-decimals);\r\n    }\r\n\r\n    function granularityToDecimals(uint256 granularity) public pure returns (uint8) {\r\n        if(granularity == 1) return 18;\r\n        if(granularity == 10) return 17;\r\n        if(granularity == 100) return 16;\r\n        if(granularity == 1000) return 15;\r\n        if(granularity == 10000) return 14;\r\n        if(granularity == 100000) return 13;\r\n        if(granularity == 1000000) return 12;\r\n        if(granularity == 10000000) return 11;\r\n        if(granularity == 100000000) return 10;\r\n        if(granularity == 1000000000) return 9;\r\n        if(granularity == 10000000000) return 8;\r\n        if(granularity == 100000000000) return 7;\r\n        if(granularity == 1000000000000) return 6;\r\n        if(granularity == 10000000000000) return 5;\r\n        if(granularity == 100000000000000) return 4;\r\n        if(granularity == 1000000000000000) return 3;\r\n        if(granularity == 10000000000000000) return 2;\r\n        if(granularity == 100000000000000000) return 1;\r\n        if(granularity == 1000000000000000000) return 0;\r\n        require(false, \"Utils: invalid granularity\");\r\n        return 0;\r\n    }\r\n\r\n    function calculateGranularityAndAmount(uint8 decimals, uint256 granularity, uint256 amount) external pure\r\n        returns(uint256 calculatedGranularity, uint256 formattedAmount) {\r\n\r\n        if(decimals == 18) {\r\n            //tokenAddress is a ERC20 with 18 decimals should have 1 granularity\r\n            //tokenAddress is a ERC777 token we give the same granularity\r\n            calculatedGranularity = granularity;\r\n            formattedAmount = amount;\r\n        } else {\r\n            //tokenAddress is a ERC20 with other than 18 decimals\r\n            calculatedGranularity = decimalsToGranularity(decimals);\r\n            formattedAmount = amount.mul(calculatedGranularity);\r\n        }\r\n    }\r\n\r\n    function calculateDecimalsAndAmount(address tokenAddress, uint256 granularity, uint256 amount)\r\n        external view returns (uint8 calculatedDecimals, uint256 formattedAmount) {\r\n        uint8 tokenDecimals = getDecimals(tokenAddress);\r\n        //As side tokens are ERC777 we need to convert granularity to decimals\r\n        calculatedDecimals = granularityToDecimals(granularity);\r\n        require(tokenDecimals == calculatedDecimals, \"Utils: Token decimals differ from decimals - granularity\");\r\n        formattedAmount = amount.div(granularity);\r\n    }\r\n\r\n}\r\n"
    },
    "contracts/zeppelin/ownership/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\npragma abicoder v2;\r\n\r\nimport \"../GSN/Context.sol\";\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () {\r\n        _owner = _msgSender();\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return _msgSender() == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n"
    },
    "contracts/test/mockReceiveTokensCall.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\n\r\nimport \"../interface/IBridge.sol\";\r\nimport \"../zeppelin/token/ERC20/IERC20.sol\";\r\nimport \"../zeppelin/token/ERC777/IERC777.sol\";\r\nimport \"../zeppelin/token/ERC777/IERC777Recipient.sol\";\r\nimport \"../zeppelin/introspection/IERC1820Registry.sol\";\r\n\r\ncontract mockReceiveTokensCall is IERC777Recipient {\r\n    address public bridge;\r\n    IERC1820Registry constant public erc1820 = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\r\n\r\n    constructor(address _bridge) {\r\n        bridge = _bridge;\r\n        //keccak256(\"ERC777TokensRecipient\")\r\n        erc1820.setInterfaceImplementer(address(this), 0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b, address(this));\r\n    }\r\n\r\n    function callReceiveTokens(address tokenToUse, address receiver, uint256 amount) external {\r\n        IERC20(tokenToUse).approve(bridge, amount);\r\n        IBridge(bridge).receiveTokensTo(tokenToUse, receiver, amount);\r\n    }\r\n\r\n    function callDepositTo(address receiver) external payable {\r\n        IBridge(bridge).depositTo{ value: msg.value }(receiver);\r\n    }\r\n\r\n    function callTokensReceived(address tokenToUse, uint256 amount, bytes calldata data) external {\r\n        IERC777(tokenToUse).send(bridge, amount, data);\r\n    }\r\n\r\n    // Mandatory for IERC777Recipient\r\n    function tokensReceived(\r\n        address,\r\n        address,\r\n        address,\r\n        uint,\r\n        bytes calldata,\r\n        bytes calldata\r\n    ) override external view {\r\n        this;\r\n    }\r\n}"
    },
    "contracts/test/mockERC777Recipient.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\n\r\nimport \"../zeppelin/token/ERC777/IERC777Recipient.sol\";\r\nimport \"../zeppelin/introspection/IERC1820Registry.sol\";\r\n\r\ncontract mockERC777Recipient is IERC777Recipient {\r\n    IERC1820Registry constant private _erc1820 = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\r\n\r\n    constructor() {\r\n        _erc1820.setInterfaceImplementer(address(this), keccak256(\"ERC777TokensRecipient\"), address(this));\r\n    }\r\n\r\n    event Success(\r\n    address operator,\r\n    address from,\r\n    address to,\r\n    uint amount,\r\n    bytes userData,\r\n    bytes operatorData);\r\n\r\n    /**\r\n     * ERC-677's only method implementation\r\n     * See https://github.com/ethereum/EIPs/issues/677 for details\r\n     */\r\n    function tokensReceived(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint amount,\r\n        bytes calldata userData,\r\n        bytes calldata operatorData\r\n    ) override external {\r\n        emit Success(operator, from, to, amount, userData, operatorData);\r\n    }\r\n}"
    },
    "contracts/SideToken/SideTokenV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\n\r\nimport \"../zeppelin/token/ERC777/ERC777.sol\";\r\n\r\ncontract SideTokenV1 is ERC777 {\r\n    address public minter;\r\n\r\n    constructor(string memory _tokenName, string memory _tokenSymbol, address _minterAddr)\r\n    ERC777(_tokenName, _tokenSymbol, new address[](0)) {\r\n        require(_minterAddr != address(0), \"SideToken: Minter address is null\");\r\n        minter = _minterAddr;\r\n    }\r\n\r\n    modifier onlyMinter() {\r\n        require(_msgSender() == minter, \"SideToken: Caller is not the minter\");\r\n        _;\r\n    }\r\n    function mint(\r\n        address account,\r\n        uint256 amount,\r\n        bytes calldata userData,\r\n        bytes calldata operatorData\r\n    )\r\n    external onlyMinter\r\n    {\r\n        _mint(_msgSender(), account, amount, userData, operatorData);\r\n    }\r\n\r\n}"
    },
    "contracts/SideTokenFactory/SideTokenFactoryV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\n\r\nimport \"../zeppelin/ownership/Secondary.sol\";\r\nimport \"../SideToken/SideTokenV1.sol\";\r\n\r\ncontract SideTokenFactoryV1 is Secondary {\r\n    event CreatedSideToken(address sideToken, string symbol);\r\n\r\n    function createSideToken(string calldata name, string calldata symbol) external onlyPrimary returns(SideTokenV1) {\r\n        SideTokenV1 sideToken = new SideTokenV1(name, symbol, primary());\r\n        emit CreatedSideToken(address(sideToken), symbol);\r\n        return sideToken;\r\n    }\r\n}"
    },
    "contracts/zeppelin/token/ERC1155/ERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\n\r\nimport \"./IERC1155.sol\";\r\nimport \"./IERC1155MetadataURI.sol\";\r\nimport \"./IERC1155Receiver.sol\";\r\nimport \"../../GSN/Context.sol\";\r\nimport \"../../introspection/ERC165.sol\";\r\nimport \"../../math/SafeMath.sol\";\r\nimport \"../../utils/Address.sol\";\r\n\r\n/**\r\n *\r\n * @dev Implementation of the basic standard multi-token.\r\n * See https://eips.ethereum.org/EIPS/eip-1155\r\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\r\n *\r\n * _Available since v3.1._\r\n */\r\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    // Mapping from token ID to account balances\r\n    mapping (uint256 => mapping(address => uint256)) private _balances;\r\n\r\n    // Mapping from account to operator approvals\r\n    mapping (address => mapping(address => bool)) private _operatorApprovals;\r\n\r\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\r\n    string private _uri;\r\n\r\n    /*\r\n     *     bytes4(keccak256('balanceOf(address,uint256)')) == 0x00fdd58e\r\n     *     bytes4(keccak256('balanceOfBatch(address[],uint256[])')) == 0x4e1273f4\r\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\r\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\r\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,uint256,bytes)')) == 0xf242432a\r\n     *     bytes4(keccak256('safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)')) == 0x2eb2c2d6\r\n     *\r\n     *     => 0x00fdd58e ^ 0x4e1273f4 ^ 0xa22cb465 ^\r\n     *        0xe985e9c5 ^ 0xf242432a ^ 0x2eb2c2d6 == 0xd9b67a26\r\n     */\r\n    bytes4 private constant _INTERFACE_ID_ERC1155 = 0xd9b67a26;\r\n\r\n    /*\r\n     *     bytes4(keccak256('uri(uint256)')) == 0x0e89341c\r\n     */\r\n    bytes4 private constant _INTERFACE_ID_ERC1155_METADATA_URI = 0x0e89341c;\r\n\r\n    /**\r\n     * @dev See {_setURI}.\r\n     */\r\n    constructor (string memory uri_) {\r\n        _setURI(uri_);\r\n\r\n        // register the supported interfaces to conform to ERC1155 via ERC165\r\n        _registerInterface(_INTERFACE_ID_ERC1155);\r\n\r\n        // register the supported interfaces to conform to ERC1155MetadataURI via ERC165\r\n        _registerInterface(_INTERFACE_ID_ERC1155_METADATA_URI);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155MetadataURI-uri}.\r\n     *\r\n     * This implementation returns the same URI for *all* token types. It relies\r\n     * on the token type ID substitution mechanism\r\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\r\n     *\r\n     * Clients calling this function must replace the `\\{id\\}` substring with the\r\n     * actual token type ID.\r\n     */\r\n    function uri(uint256) external view virtual override returns (string memory) {\r\n        return _uri;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-balanceOf}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\r\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\r\n        return _balances[id][account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-balanceOfBatch}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `accounts` and `ids` must have the same length.\r\n     */\r\n    function balanceOfBatch(\r\n        address[] memory accounts,\r\n        uint256[] memory ids\r\n    )\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256[] memory)\r\n    {\r\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\r\n\r\n        uint256[] memory batchBalances = new uint256[](accounts.length);\r\n\r\n        for (uint256 i = 0; i < accounts.length; ++i) {\r\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\r\n        }\r\n\r\n        return batchBalances;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-setApprovalForAll}.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) public virtual override {\r\n        require(_msgSender() != operator, \"ERC1155: setting approval status for self\");\r\n\r\n        _operatorApprovals[_msgSender()][operator] = approved;\r\n        emit ApprovalForAll(_msgSender(), operator, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-isApprovedForAll}.\r\n     */\r\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\r\n        return _operatorApprovals[account][operator];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-safeTransferFrom}.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    )\r\n        public\r\n        virtual\r\n        override\r\n    {\r\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\r\n        require(\r\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\r\n            \"ERC1155: caller is not owner nor approved\"\r\n        );\r\n\r\n        address operator = _msgSender();\r\n\r\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\r\n\r\n        _balances[id][from] = _balances[id][from].sub(amount, \"ERC1155: insufficient balance for transfer\");\r\n        _balances[id][to] = _balances[id][to].add(amount);\r\n\r\n        emit TransferSingle(operator, from, to, id, amount);\r\n\r\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-safeBatchTransferFrom}.\r\n     */\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    )\r\n        public\r\n        virtual\r\n        override\r\n    {\r\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\r\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\r\n        require(\r\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\r\n            \"ERC1155: transfer caller is not owner nor approved\"\r\n        );\r\n\r\n        address operator = _msgSender();\r\n\r\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\r\n\r\n        for (uint256 i = 0; i < ids.length; ++i) {\r\n            uint256 id = ids[i];\r\n            uint256 amount = amounts[i];\r\n\r\n            _balances[id][from] = _balances[id][from].sub(\r\n                amount,\r\n                \"ERC1155: insufficient balance for transfer\"\r\n            );\r\n            _balances[id][to] = _balances[id][to].add(amount);\r\n        }\r\n\r\n        emit TransferBatch(operator, from, to, ids, amounts);\r\n\r\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets a new URI for all token types, by relying on the token type ID\r\n     * substitution mechanism\r\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\r\n     *\r\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\r\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\r\n     * clients with the token type ID.\r\n     *\r\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\r\n     * interpreted by clients as\r\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\r\n     * for token type ID 0x4cce0.\r\n     *\r\n     * See {uri}.\r\n     *\r\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\r\n     * this function emits no events.\r\n     */\r\n    function _setURI(string memory newuri) internal virtual {\r\n        _uri = newuri;\r\n    }\r\n\r\n    /**\r\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `account`.\r\n     *\r\n     * Emits a {TransferSingle} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - If `account` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function _mint(address account, uint256 id, uint256 amount, bytes memory data) internal virtual {\r\n        require(account != address(0), \"ERC1155: mint to the zero address\");\r\n\r\n        address operator = _msgSender();\r\n\r\n        _beforeTokenTransfer(operator, address(0), account, _asSingletonArray(id), _asSingletonArray(amount), data);\r\n\r\n        _balances[id][account] = _balances[id][account].add(amount);\r\n        emit TransferSingle(operator, address(0), account, id, amount);\r\n\r\n        _doSafeTransferAcceptanceCheck(operator, address(0), account, id, amount, data);\r\n    }\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `ids` and `amounts` must have the same length.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function _mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) internal virtual {\r\n        require(to != address(0), \"ERC1155: mint to the zero address\");\r\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\r\n\r\n        address operator = _msgSender();\r\n\r\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\r\n\r\n        for (uint i = 0; i < ids.length; i++) {\r\n            _balances[ids[i]][to] = amounts[i].add(_balances[ids[i]][to]);\r\n        }\r\n\r\n        emit TransferBatch(operator, address(0), to, ids, amounts);\r\n\r\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens of token type `id` from `account`\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens of token type `id`.\r\n     */\r\n    function _burn(address account, uint256 id, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC1155: burn from the zero address\");\r\n\r\n        address operator = _msgSender();\r\n\r\n        _beforeTokenTransfer(operator, account, address(0), _asSingletonArray(id), _asSingletonArray(amount), \"\");\r\n\r\n        _balances[id][account] = _balances[id][account].sub(\r\n            amount,\r\n            \"ERC1155: burn amount exceeds balance\"\r\n        );\r\n\r\n        emit TransferSingle(operator, account, address(0), id, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `ids` and `amounts` must have the same length.\r\n     */\r\n    function _burnBatch(address account, uint256[] memory ids, uint256[] memory amounts) internal virtual {\r\n        require(account != address(0), \"ERC1155: burn from the zero address\");\r\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\r\n\r\n        address operator = _msgSender();\r\n\r\n        _beforeTokenTransfer(operator, account, address(0), ids, amounts, \"\");\r\n\r\n        for (uint i = 0; i < ids.length; i++) {\r\n            _balances[ids[i]][account] = _balances[ids[i]][account].sub(\r\n                amounts[i],\r\n                \"ERC1155: burn amount exceeds balance\"\r\n            );\r\n        }\r\n\r\n        emit TransferBatch(operator, account, address(0), ids, amounts);\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any token transfer. This includes minting\r\n     * and burning, as well as batched variants.\r\n     *\r\n     * The same hook is called on both single and batched variants. For single\r\n     * transfers, the length of the `id` and `amount` arrays will be 1.\r\n     *\r\n     * Calling conditions (for each `id` and `amount` pair):\r\n     *\r\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * of token type `id` will be  transferred to `to`.\r\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\r\n     * for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\r\n     * will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     * - `ids` and `amounts` have the same, non-zero length.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    )\r\n        internal\r\n        virtual\r\n    { }\r\n\r\n    function _doSafeTransferAcceptanceCheck(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    )\r\n        private\r\n    {\r\n        if (to.isContract()) {\r\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\r\n                if (response != IERC1155Receiver(to).onERC1155Received.selector) {\r\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\r\n                }\r\n            } catch Error(string memory reason) {\r\n                revert(reason);\r\n            } catch {\r\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\r\n            }\r\n        }\r\n    }\r\n\r\n    function _doSafeBatchTransferAcceptanceCheck(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    )\r\n        private\r\n    {\r\n        if (to.isContract()) {\r\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (bytes4 response) {\r\n                if (response != IERC1155Receiver(to).onERC1155BatchReceived.selector) {\r\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\r\n                }\r\n            } catch Error(string memory reason) {\r\n                revert(reason);\r\n            } catch {\r\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\r\n            }\r\n        }\r\n    }\r\n\r\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\r\n        uint256[] memory array = new uint256[](1);\r\n        array[0] = element;\r\n\r\n        return array;\r\n    }\r\n}\r\n"
    },
    "contracts/zeppelin/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\n\r\nimport \"../../introspection/IERC165.sol\";\r\n\r\n/**\r\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\r\n *\r\n * _Available since v3.1._\r\n */\r\ninterface IERC1155 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\r\n     */\r\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\r\n\r\n    /**\r\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\r\n     * transfers.\r\n     */\r\n    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\r\n\r\n    /**\r\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\r\n     * `approved`.\r\n     */\r\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\r\n     *\r\n     * If an {URI} event was emitted for `id`, the standard\r\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\r\n     * returned by {IERC1155MetadataURI-uri}.\r\n     */\r\n    event URI(string value, uint256 indexed id);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function balanceOf(address account, uint256 id) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `accounts` and `ids` must have the same length.\r\n     */\r\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\r\n\r\n    /**\r\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `operator` cannot be the caller.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n\r\n    /**\r\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\r\n     *\r\n     * See {setApprovalForAll}.\r\n     */\r\n    function isApprovedForAll(address account, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\r\n     *\r\n     * Emits a {TransferSingle} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\r\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\r\n     *\r\n     * Emits a {TransferBatch} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `ids` and `amounts` must have the same length.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;\r\n}\r\n"
    },
    "contracts/zeppelin/token/ERC1155/IERC1155MetadataURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\n\r\nimport \"./IERC1155.sol\";\r\n\r\n/**\r\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\r\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\r\n *\r\n * _Available since v3.1._\r\n */\r\ninterface IERC1155MetadataURI is IERC1155 {\r\n    /**\r\n     * @dev Returns the URI for token type `id`.\r\n     *\r\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\r\n     * clients with the actual token type ID.\r\n     */\r\n    function uri(uint256 id) external view returns (string memory);\r\n}\r\n"
    },
    "contracts/zeppelin/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\n\r\nimport \"../../introspection/IERC165.sol\";\r\n\r\n/**\r\n * _Available since v3.1._\r\n */\r\ninterface IERC1155Receiver is IERC165 {\r\n\r\n    /**\r\n        @dev Handles the receipt of a single ERC1155 token type. This function is\r\n        called at the end of a `safeTransferFrom` after the balance has been updated.\r\n        To accept the transfer, this must return\r\n        `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\r\n        (i.e. 0xf23a6e61, or its own function selector).\r\n        @param operator The address which initiated the transfer (i.e. msg.sender)\r\n        @param from The address which previously owned the token\r\n        @param id The ID of the token being transferred\r\n        @param value The amount of tokens being transferred\r\n        @param data Additional data with no specified format\r\n        @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\r\n    */\r\n    function onERC1155Received(\r\n        address operator,\r\n        address from,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes calldata data\r\n    )\r\n        external\r\n        returns(bytes4);\r\n\r\n    /**\r\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\r\n        is called at the end of a `safeBatchTransferFrom` after the balances have\r\n        been updated. To accept the transfer(s), this must return\r\n        `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\r\n        (i.e. 0xbc197c81, or its own function selector).\r\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\r\n        @param from The address which previously owned the token\r\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\r\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\r\n        @param data Additional data with no specified format\r\n        @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\r\n    */\r\n    function onERC1155BatchReceived(\r\n        address operator,\r\n        address from,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values,\r\n        bytes calldata data\r\n    )\r\n        external\r\n        returns(bytes4);\r\n}\r\n"
    },
    "contracts/zeppelin/token/ERC1155/ERC1155Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\n\r\nimport \"./ERC1155.sol\";\r\nimport \"../../lifecycle/Pausable.sol\";\r\n\r\n/**\r\n * @dev ERC1155 token with pausable token transfers, minting and burning.\r\n *\r\n * Useful for scenarios such as preventing trades until the end of an evaluation\r\n * period, or having an emergency switch for freezing all token transfers in the\r\n * event of a large bug.\r\n *\r\n * _Available since v3.1._\r\n */\r\nabstract contract ERC1155Pausable is ERC1155, Pausable {\r\n    /**\r\n     * @dev See {ERC1155-_beforeTokenTransfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the contract must not be paused.\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    )\r\n        internal\r\n        virtual\r\n        override\r\n    {\r\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\r\n\r\n        require(!paused(), \"ERC1155Pausable: token transfer while paused\");\r\n    }\r\n}\r\n"
    },
    "contracts/zeppelin/lifecycle/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\npragma abicoder v2;\r\n\r\nimport \"../GSN/Context.sol\";\r\nimport \"../access/roles/PauserRole.sol\";\r\n\r\n/**\r\n * @dev Contract module which allows children to implement an emergency stop\r\n * mechanism that can be triggered by an authorized account.\r\n *\r\n * This module is used through inheritance. It will make available the\r\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\r\n * the functions of your contract. Note that they will not be pausable by\r\n * simply including this module, only once the modifiers are put in place.\r\n */\r\nabstract contract Pausable is Context, PauserRole {\r\n    /**\r\n     * @dev Emitted when the pause is triggered by a pauser (`account`).\r\n     */\r\n    event Paused(address account);\r\n\r\n    /**\r\n     * @dev Emitted when the pause is lifted by a pauser (`account`).\r\n     */\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    /**\r\n     * @dev Initializes the contract in unpaused state. Assigns the Pauser role\r\n     * to the deployer.\r\n     */\r\n    constructor () {\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the contract is paused, and false otherwise.\r\n     */\r\n    function paused() public view returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!_paused, \"Pausable: paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     */\r\n    modifier whenPaused() {\r\n        require(_paused, \"Pausable: not paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Called by a pauser to pause, triggers stopped state.\r\n     */\r\n    function pause() public onlyPauser whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Called by a pauser to unpause, returns to normal state.\r\n     */\r\n    function unpause() public onlyPauser whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(_msgSender());\r\n    }\r\n}\r\n"
    },
    "contracts/zeppelin/access/roles/PauserRole.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\npragma abicoder v2;\r\n\r\nimport \"../../GSN/Context.sol\";\r\nimport \"../Roles.sol\";\r\n\r\nabstract contract PauserRole is Context {\r\n    using Roles for Roles.Role;\r\n\r\n    event PauserAdded(address indexed account);\r\n    event PauserRemoved(address indexed account);\r\n\r\n    Roles.Role private _pausers;\r\n\r\n    constructor () {\r\n        _addPauser(_msgSender());\r\n    }\r\n\r\n    modifier onlyPauser() {\r\n        require(isPauser(_msgSender()), \"PauserRole: caller doesn't have the role\");\r\n        _;\r\n    }\r\n\r\n    function isPauser(address account) public view returns (bool) {\r\n        return _pausers.has(account);\r\n    }\r\n\r\n    function addPauser(address account) public onlyPauser {\r\n        _addPauser(account);\r\n    }\r\n\r\n    function renouncePauser() public {\r\n        _removePauser(_msgSender());\r\n    }\r\n\r\n    function _addPauser(address account) internal {\r\n        _pausers.add(account);\r\n        emit PauserAdded(account);\r\n    }\r\n\r\n    function _removePauser(address account) internal {\r\n        _pausers.remove(account);\r\n        emit PauserRemoved(account);\r\n    }\r\n}\r\n"
    },
    "contracts/zeppelin/token/ERC721/ERC721Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\n\r\nimport \"./ERC721.sol\";\r\nimport \"../../lifecycle/Pausable.sol\";\r\n\r\n/**\r\n * @dev ERC721 token with pausable token transfers, minting and burning.\r\n *\r\n * Useful for scenarios such as preventing trades until the end of an evaluation\r\n * period, or having an emergency switch for freezing all token transfers in the\r\n * event of a large bug.\r\n */\r\nabstract contract ERC721Pausable is ERC721, Pausable {\r\n    /**\r\n     * @dev See {ERC721-_beforeTokenTransfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the contract must not be paused.\r\n     */\r\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual override {\r\n        super._beforeTokenTransfer(from, to, tokenId);\r\n\r\n        require(!paused(), \"ERC721Pausable: token transfer while paused\");\r\n    }\r\n}\r\n"
    },
    "contracts/test/nftbridge/OpenSea721.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\n// created using https://github.com/ProjectOpenSea/opensea-creatures/blob/master/contracts/ERC721Tradable.sol\r\n// and https://github.com/ProjectOpenSea/opensea-creatures/blob/master/contracts/Creature.sol\r\nimport \"../../zeppelin/token/ERC721/ERC721.sol\";\r\nimport \"../../zeppelin/ownership/Ownable.sol\";\r\nimport \"../../zeppelin/math/SafeMath.sol\";\r\nimport \"../../zeppelin/utils/Strings.sol\";\r\nimport \"./OpenSeaEIP712Base.sol\";\r\n\r\n\r\n/**\r\n * @title OpenSea721\r\n * OpenSea721 - ERC721 contract that whitelists a trading address, and has minting functionality.\r\n */\r\ncontract OpenSea721 is ERC721, OpenSeaEIP712Base, Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 private _currentTokenId = 0;\r\n\r\n    constructor(\r\n        string memory _name,\r\n        string memory _symbol\r\n    ) ERC721(_name, _symbol) {\r\n        _initializeEIP712(_name);\r\n    }\r\n\r\n    function baseTokenURI() public pure returns (string memory) {\r\n        return \"https://creatures-api.opensea.io/api/creature/\";\r\n    }\r\n\r\n    function contractURI() public pure returns (string memory) {\r\n        return \"https://creatures-api.opensea.io/contract/opensea-creatures\";\r\n    }\r\n\r\n    /**\r\n     * @dev Mints a token to an address with a tokenURI.\r\n     * @param _to address of the future owner of the token\r\n     */\r\n    function mintTo(address _to) public onlyOwner {\r\n        uint256 newTokenId = _getNextTokenId();\r\n        _mint(_to, newTokenId);\r\n        _incrementTokenId();\r\n    }\r\n\r\n    /**\r\n     * @dev calculates the next token ID based on value of _currentTokenId\r\n     * @return uint256 for the next token ID\r\n     */\r\n    function _getNextTokenId() private view returns (uint256) {\r\n        return _currentTokenId.add(1);\r\n    }\r\n\r\n    /**\r\n     * @dev increments the value of _currentTokenId\r\n     */\r\n    function _incrementTokenId() private {\r\n        _currentTokenId++;\r\n    }\r\n\r\n    function tokenURI(uint256 _tokenId) override public pure returns (string memory) {\r\n        return string(abi.encodePacked(baseTokenURI(), Strings.toString(_tokenId)));\r\n    }\r\n\r\n}"
    },
    "contracts/test/nftbridge/OpenSeaEIP712Base.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\n\r\nimport \"../../zeppelin/upgradable/Initializable.sol\";\r\n\r\ncontract OpenSeaEIP712Base is Initializable {\r\n    struct EIP712Domain {\r\n        string name;\r\n        string version;\r\n        address verifyingContract;\r\n        bytes32 salt;\r\n    }\r\n\r\n    string constant public ERC712_VERSION = \"1\";\r\n\r\n    bytes32 internal constant EIP712_DOMAIN_TYPEHASH = keccak256(\r\n        bytes(\r\n            \"EIP712Domain(string name,string version,address verifyingContract,bytes32 salt)\"\r\n        )\r\n    );\r\n    bytes32 internal domainSeperator;\r\n\r\n    // supposed to be called once while initializing.\r\n    // one of the contracts that inherits this contract follows proxy pattern\r\n    // so it is not possible to do this in a constructor\r\n    function _initializeEIP712(\r\n        string memory name\r\n    )\r\n        internal\r\n        initializer\r\n    {\r\n        _setDomainSeperator(name);\r\n    }\r\n\r\n    function _setDomainSeperator(string memory name) internal {\r\n        domainSeperator = keccak256(\r\n            abi.encode(\r\n                EIP712_DOMAIN_TYPEHASH,\r\n                keccak256(bytes(name)),\r\n                keccak256(bytes(ERC712_VERSION)),\r\n                address(this),\r\n                bytes32(getChainId())\r\n            )\r\n        );\r\n    }\r\n\r\n    function getDomainSeperator() public view returns (bytes32) {\r\n        return domainSeperator;\r\n    }\r\n\r\n    function getChainId() public pure returns (uint256) {\r\n        uint256 id;\r\n        assembly {\r\n            id := chainid()\r\n        }\r\n        return id;\r\n    }\r\n\r\n    /**\r\n     * Accept message hash and returns hash message in EIP712 compatible form\r\n     * So that it can be used to recover signer from signature signed using EIP712 formatted data\r\n     * https://eips.ethereum.org/EIPS/eip-712\r\n     * \"\\\\x19\" makes the encoding deterministic\r\n     * \"\\\\x01\" is the version byte to make it compatible to EIP-191\r\n     */\r\n    function toTypedMessageHash(bytes32 messageHash)\r\n        internal\r\n        view\r\n        returns (bytes32)\r\n    {\r\n        return\r\n            keccak256(\r\n                abi.encodePacked(\"\\x19\\x01\", getDomainSeperator(), messageHash)\r\n            );\r\n    }\r\n}\r\n"
    },
    "contracts/Federation/FederationV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\npragma abicoder v2;\r\n\r\n// Upgradables\r\nimport \"../zeppelin/upgradable/Initializable.sol\";\r\nimport \"../zeppelin/upgradable/ownership/UpgradableOwnable.sol\";\r\n\r\nimport \"../interface/IBridge.sol\";\r\n\r\ncontract FederationV2 is Initializable, UpgradableOwnable {\r\n    uint constant public MAX_MEMBER_COUNT = 50;\r\n    address constant private NULL_ADDRESS = address(0);\r\n\r\n    IBridge public bridge;\r\n    address[] public members;\r\n    uint public required;\r\n\r\n    mapping (address => bool) public isMember;\r\n    mapping (bytes32 => mapping (address => bool)) public votes;\r\n    mapping(bytes32 => bool) public processed;\r\n\r\n    event Executed(\r\n        address indexed federator,\r\n        bytes32 indexed transactionHash,\r\n        bytes32 indexed transactionId,\r\n        address originalTokenAddress,\r\n        address sender,\r\n        address receiver,\r\n        uint256 amount,\r\n        bytes32 blockHash,\r\n        uint32 logIndex\r\n    );\r\n    event MemberAddition(address indexed member);\r\n    event MemberRemoval(address indexed member);\r\n    event RequirementChange(uint required);\r\n    event BridgeChanged(address bridge);\r\n    event Voted(\r\n        address indexed federator,\r\n        bytes32 indexed transactionHash,\r\n        bytes32 indexed transactionId,\r\n        address originalTokenAddress,\r\n        address sender,\r\n        address receiver,\r\n        uint256 amount,\r\n        bytes32 blockHash,\r\n        uint32 logIndex\r\n    );\r\n    event HeartBeat(\r\n        address indexed sender,\r\n        uint256 fedRskBlock,\r\n        uint256 fedEthBlock,\r\n        string federatorVersion,\r\n        string nodeRskInfo,\r\n        string nodeEthInfo\r\n    );\r\n\r\n    modifier onlyMember() {\r\n        require(isMember[_msgSender()], \"Federation: Not Federator\");\r\n        _;\r\n    }\r\n\r\n    modifier validRequirement(uint membersCount, uint _required) {\r\n        // solium-disable-next-line max-len\r\n        require(_required <= membersCount && _required != 0 && membersCount != 0, \"Federation: Invalid requirements\");\r\n        _;\r\n    }\r\n\r\n    function initialize(address[] memory _members, uint _required, address _bridge, address owner)\r\n    public validRequirement(_members.length, _required) initializer {\r\n        UpgradableOwnable.initialize(owner);\r\n        require(_members.length <= MAX_MEMBER_COUNT, \"Federation: Too many members\");\r\n        members = _members;\r\n        for (uint i = 0; i < _members.length; i++) {\r\n            require(!isMember[_members[i]] && _members[i] != NULL_ADDRESS, \"Federation: Invalid members\");\r\n            isMember[_members[i]] = true;\r\n            emit MemberAddition(_members[i]);\r\n        }\r\n        required = _required;\r\n        emit RequirementChange(required);\r\n        _setBridge(_bridge);\r\n    }\r\n\r\n    function version() external pure returns (string memory) {\r\n        return \"v2\";\r\n    }\r\n\r\n    function setBridge(address _bridge) external onlyOwner {\r\n        _setBridge(_bridge);\r\n    }\r\n\r\n    function _setBridge(address _bridge) internal {\r\n        require(_bridge != NULL_ADDRESS, \"Federation: Empty bridge\");\r\n        bridge = IBridge(_bridge);\r\n        emit BridgeChanged(_bridge);\r\n    }\r\n\r\n    function voteTransaction(\r\n        address originalTokenAddress,\r\n        address payable sender,\r\n        address payable receiver,\r\n        uint256 amount,\r\n        bytes32 blockHash,\r\n        bytes32 transactionHash,\r\n        uint32 logIndex\r\n    )\r\n    public onlyMember returns(bool)\r\n    {\r\n        bytes32 transactionId = getTransactionId(\r\n            originalTokenAddress,\r\n            sender,\r\n            receiver,\r\n            amount,\r\n            blockHash,\r\n            transactionHash,\r\n            logIndex\r\n        );\r\n        if (processed[transactionId])\r\n            return true;\r\n\r\n        if (votes[transactionId][_msgSender()])\r\n            return true;\r\n\r\n        votes[transactionId][_msgSender()] = true;\r\n        emit Voted(\r\n            _msgSender(),\r\n            transactionHash,\r\n            transactionId,\r\n            originalTokenAddress,\r\n            sender,\r\n            receiver,\r\n            amount,\r\n            blockHash,\r\n            logIndex\r\n        );\r\n\r\n        uint transactionCount = getTransactionCount(transactionId);\r\n        if (transactionCount >= required && transactionCount >= members.length / 2 + 1) {\r\n            processed[transactionId] = true;\r\n            bridge.acceptTransfer(\r\n                originalTokenAddress,\r\n                sender,\r\n                receiver,\r\n                amount,\r\n                blockHash,\r\n                transactionHash,\r\n                logIndex\r\n            );\r\n            emit Executed(\r\n                _msgSender(),\r\n                transactionHash,\r\n                transactionId,\r\n                originalTokenAddress,\r\n                sender,\r\n                receiver,\r\n                amount,\r\n                blockHash,\r\n                logIndex\r\n            );\r\n            return true;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function getTransactionCount(bytes32 transactionId) public view returns(uint) {\r\n        uint count = 0;\r\n        for (uint i = 0; i < members.length; i++) {\r\n            if (votes[transactionId][members[i]])\r\n                count += 1;\r\n        }\r\n        return count;\r\n    }\r\n\r\n    function hasVoted(bytes32 transactionId) external view returns(bool)\r\n    {\r\n        return votes[transactionId][_msgSender()];\r\n    }\r\n\r\n    function transactionWasProcessed(bytes32 transactionId) external view returns(bool)\r\n    {\r\n        return processed[transactionId];\r\n    }\r\n\r\n    function getTransactionId(\r\n        address originalTokenAddress,\r\n        address sender,\r\n        address receiver,\r\n        uint256 amount,\r\n        bytes32 blockHash,\r\n        bytes32 transactionHash,\r\n        uint32 logIndex\r\n    ) public pure returns(bytes32)\r\n    {\r\n        return keccak256(\r\n            abi.encodePacked(\r\n            originalTokenAddress,\r\n            sender,\r\n            receiver,\r\n            amount,\r\n            blockHash,\r\n            transactionHash,\r\n            logIndex\r\n            )\r\n        );\r\n    }\r\n\r\n    function addMember(address _newMember) external onlyOwner\r\n    {\r\n        require(_newMember != NULL_ADDRESS, \"Federation: Empty member\");\r\n        require(!isMember[_newMember], \"Federation: Member already exists\");\r\n        require(members.length < MAX_MEMBER_COUNT, \"Federation: Max members reached\");\r\n\r\n        isMember[_newMember] = true;\r\n        members.push(_newMember);\r\n        emit MemberAddition(_newMember);\r\n    }\r\n\r\n    function removeMember(address _oldMember) external onlyOwner\r\n    {\r\n        require(_oldMember != NULL_ADDRESS, \"Federation: Empty member\");\r\n        require(isMember[_oldMember], \"Federation: Member doesn't exists\");\r\n        require(members.length > 1, \"Federation: Can't remove all the members\");\r\n        require(members.length - 1 >= required, \"Federation: Can't have less than required members\");\r\n\r\n        isMember[_oldMember] = false;\r\n        for (uint i = 0; i < members.length - 1; i++) {\r\n            if (members[i] == _oldMember) {\r\n                members[i] = members[members.length - 1];\r\n                break;\r\n            }\r\n        }\r\n        members.pop(); // remove an element from the end of the array.\r\n        emit MemberRemoval(_oldMember);\r\n    }\r\n\r\n    function getMembers() external view returns (address[] memory)\r\n    {\r\n        return members;\r\n    }\r\n\r\n    function changeRequirement(uint _required) external onlyOwner validRequirement(members.length, _required)\r\n    {\r\n        require(_required >= 2, \"Federation: Requires at least 2\");\r\n        required = _required;\r\n        emit RequirementChange(_required);\r\n    }\r\n\r\n    function emitHeartbeat(\r\n        uint256 fedRskBlock,\r\n        uint256 fedEthBlock,\r\n        string calldata federatorVersion,\r\n        string calldata nodeRskInfo,\r\n        string calldata nodeEthInfo\r\n    ) external onlyMember {\r\n        emit HeartBeat(\r\n            _msgSender(),\r\n            fedRskBlock,\r\n            fedEthBlock,\r\n            federatorVersion,\r\n            nodeRskInfo,\r\n            nodeEthInfo\r\n        );\r\n    }\r\n}"
    },
    "contracts/Federation/Federation.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\npragma abicoder v2;\r\n\r\n// Upgradables\r\nimport \"../zeppelin/upgradable/Initializable.sol\";\r\nimport \"../zeppelin/upgradable/ownership/UpgradableOwnable.sol\";\r\n\r\nimport \"../nftbridge/INFTBridge.sol\";\r\nimport \"../interface/IBridge.sol\";\r\nimport \"../interface/IFederation.sol\";\r\n\r\ncontract Federation is Initializable, UpgradableOwnable, IFederation {\r\n    uint constant public MAX_MEMBER_COUNT = 50;\r\n    address constant private NULL_ADDRESS = address(0);\r\n\r\n    IBridge public bridge;\r\n    address[] public members;\r\n\r\n    /**\r\n      @notice The minimum amount of votes to approve a transaction\r\n      @dev It should have more members than the required amount\r\n     */\r\n    uint public required;\r\n\r\n    /**\r\n      @notice All the addresses that are members of the federation\r\n      @dev The address should be a member to vote in transactions\r\n     */\r\n    mapping (address => bool) public isMember;\r\n\r\n    /**\r\n      (bytes32) transactionId = keccak256(\r\n        abi.encodePacked(\r\n          originalTokenAddress,\r\n          sender,\r\n          receiver,\r\n          amount,\r\n          blockHash,\r\n          transactionHash,\r\n          logIndex\r\n        )\r\n      ) => (\r\n        (address) members => (bool) voted\r\n      )\r\n      @notice Votes by members by the transaction ID\r\n      @dev usually the members should approve the transaction by 50% + 1\r\n     */\r\n    mapping (bytes32 => mapping (address => bool)) public votes;\r\n\r\n    /**\r\n      (bytes32) transactionId => (bool) voted\r\n      @notice Check if that transaction was already processed\r\n     */\r\n    mapping(bytes32 => bool) public processed;\r\n\r\n    /** Federator v3 variables */\r\n    INFTBridge public bridgeNFT;\r\n\r\n    modifier onlyMember() {\r\n        require(isMember[_msgSender()], \"Federation: Not Federator\");\r\n        _;\r\n    }\r\n\r\n    modifier validRequirement(uint membersCount, uint _required) {\r\n        // solium-disable-next-line max-len\r\n        require(_required <= membersCount && _required != 0 && membersCount != 0, \"Federation: Invalid requirements\");\r\n        _;\r\n    }\r\n\r\n    function initialize(address[] memory _members, uint _required, address _bridge, address owner, address _bridgeNFT) public\r\n    validRequirement(_members.length, _required) initializer {\r\n        UpgradableOwnable.initialize(owner);\r\n        require(_members.length <= MAX_MEMBER_COUNT, \"Federation: Too many members\");\r\n        members = _members;\r\n        for (uint i = 0; i < _members.length; i++) {\r\n            require(!isMember[_members[i]] && _members[i] != NULL_ADDRESS, \"Federation: Invalid members\");\r\n            isMember[_members[i]] = true;\r\n            emit MemberAddition(_members[i]);\r\n        }\r\n        required = _required;\r\n        emit RequirementChange(required);\r\n        _setBridge(_bridge);\r\n        _setNFTBridge(_bridgeNFT);\r\n    }\r\n\r\n    /**\r\n      @notice Current version of the contract\r\n      @return version in v{Number}\r\n     */\r\n    function version() external pure override returns (string memory) {\r\n      return \"v3\";\r\n    }\r\n\r\n    /**\r\n      @notice Sets a new bridge contract\r\n      @dev Emits BridgeChanged event\r\n      @param _bridge the new bridge contract address that should implement the IBridge interface\r\n     */\r\n    function setBridge(address _bridge) external onlyOwner override {\r\n        _setBridge(_bridge);\r\n    }\r\n\r\n    function _setBridge(address _bridge) internal {\r\n        require(_bridge != NULL_ADDRESS, \"Federation: Empty bridge\");\r\n        bridge = IBridge(_bridge);\r\n        emit BridgeChanged(_bridge);\r\n    }\r\n\r\n    /**\r\n      @notice Sets a new NFT bridge contract\r\n      @dev Emits NFTBridgeChanged event\r\n      @param _bridgeNFT the new NFT bridge contract address that should implement the INFTBridge interface\r\n     */\r\n    function setNFTBridge(address _bridgeNFT) external onlyOwner override {\r\n      _setNFTBridge(_bridgeNFT);\r\n    }\r\n\r\n    function _setNFTBridge(address _bridgeNFT) internal {\r\n      require(_bridgeNFT != NULL_ADDRESS, \"Federation: Empty NFT bridge\");\r\n      bridgeNFT = INFTBridge(_bridgeNFT);\r\n      emit NFTBridgeChanged(_bridgeNFT);\r\n    }\r\n\r\n    function validateTransaction(bytes32 transactionId) internal view returns(bool) {\r\n      uint transactionCount = getTransactionCount(transactionId);\r\n      return transactionCount >= required && transactionCount >= members.length / 2 + 1;\r\n    }\r\n\r\n    /**\r\n      @notice Vote in a transaction, if it has enough votes it accepts the transfer\r\n      @param originalTokenAddress The address of the token in the origin (main) chain\r\n      @param sender The address who solicited the cross token\r\n      @param receiver Who is going to receive the token in the opposite chain\r\n      @param value Could be the amount if tokenType == COIN or the tokenId if tokenType == NFT\r\n      @param blockHash The block hash in which the transaction with the cross event occurred\r\n      @param transactionHash The transaction in which the cross event occurred\r\n      @param logIndex Index of the event in the logs\r\n      @param tokenType Is the type of bridge to be used\r\n     */\r\n    function voteTransaction(\r\n      address originalTokenAddress,\r\n      address payable sender,\r\n      address payable receiver,\r\n      uint256 value,\r\n      bytes32 blockHash,\r\n      bytes32 transactionHash,\r\n      uint32 logIndex,\r\n      TokenType tokenType\r\n    ) external onlyMember override {\r\n        bytes32 transactionId = getTransactionId(\r\n            originalTokenAddress,\r\n            sender,\r\n            receiver,\r\n            value,\r\n            blockHash,\r\n            transactionHash,\r\n            logIndex\r\n        );\r\n        if (processed[transactionId])\r\n            return;\r\n\r\n        if (votes[transactionId][_msgSender()])\r\n            return;\r\n\r\n        votes[transactionId][_msgSender()] = true;\r\n        emit Voted(\r\n            _msgSender(),\r\n            transactionHash,\r\n            transactionId,\r\n            originalTokenAddress,\r\n            sender,\r\n            receiver,\r\n            value,\r\n            blockHash,\r\n            logIndex\r\n        );\r\n\r\n        if (validateTransaction(transactionId)) {\r\n            processed[transactionId] = true;\r\n            acceptTransfer(\r\n              originalTokenAddress,\r\n              sender,\r\n              receiver,\r\n              value,\r\n              blockHash,\r\n              transactionHash,\r\n              logIndex,\r\n              tokenType\r\n            );\r\n\r\n            emit Executed(\r\n                _msgSender(),\r\n                transactionHash,\r\n                transactionId,\r\n                originalTokenAddress,\r\n                sender,\r\n                receiver,\r\n                value,\r\n                blockHash,\r\n                logIndex\r\n            );\r\n            return;\r\n        }\r\n    }\r\n\r\n  function acceptTransfer(\r\n    address originalTokenAddress,\r\n    address payable sender,\r\n    address payable receiver,\r\n    uint256 value,\r\n    bytes32 blockHash,\r\n    bytes32 transactionHash,\r\n    uint32 logIndex,\r\n    TokenType tokenType\r\n  ) internal {\r\n    if (tokenType == TokenType.NFT) {\r\n      require(address(bridgeNFT) != NULL_ADDRESS, \"Federation: Empty NFTBridge\");\r\n      bridgeNFT.acceptTransfer(\r\n        originalTokenAddress,\r\n        sender,\r\n        receiver,\r\n        value,\r\n        blockHash,\r\n        transactionHash,\r\n        logIndex\r\n      );\r\n      return;\r\n    }\r\n\r\n    bridge.acceptTransfer(\r\n      originalTokenAddress,\r\n      sender,\r\n      receiver,\r\n      value,\r\n      blockHash,\r\n      transactionHash,\r\n      logIndex\r\n    );\r\n  }\r\n\r\n  /**\r\n    @notice Get the amount of approved votes for that transactionId\r\n    @param transactionId The transaction hashed from getTransactionId function\r\n   */\r\n  function getTransactionCount(bytes32 transactionId) public view returns(uint) {\r\n    uint count = 0;\r\n    for (uint i = 0; i < members.length; i++) {\r\n      if (votes[transactionId][members[i]])\r\n        count += 1;\r\n    }\r\n    return count;\r\n  }\r\n\r\n    function hasVoted(bytes32 transactionId) external view returns(bool)\r\n    {\r\n        return votes[transactionId][_msgSender()];\r\n    }\r\n\r\n    function transactionWasProcessed(bytes32 transactionId) external view returns(bool)\r\n    {\r\n        return processed[transactionId];\r\n    }\r\n\r\n    /**\r\n      @notice Gets the hash of transaction from the following parameters encoded and keccaked\r\n      @dev It encodes and applies keccak256 to the parameters received in the same order\r\n      @param originalTokenAddress The address of the token in the origin (main) chain\r\n      @param sender The address who solicited the cross token\r\n      @param receiver Who is going to receive the token in the opposite chain\r\n      @param amount Could be the amount or the tokenId\r\n      @param blockHash The block hash in which the transaction with the cross event occurred\r\n      @param transactionHash The transaction in which the cross event occurred\r\n      @param logIndex Index of the event in the logs\r\n      @return The hash generated by the parameters.\r\n    */\r\n    function getTransactionId(\r\n        address originalTokenAddress,\r\n        address sender,\r\n        address receiver,\r\n        uint256 amount,\r\n        bytes32 blockHash,\r\n        bytes32 transactionHash,\r\n        uint32 logIndex\r\n    ) public pure returns(bytes32) {\r\n      return keccak256(\r\n        abi.encodePacked(\r\n          originalTokenAddress,\r\n          sender,\r\n          receiver,\r\n          amount,\r\n          blockHash,\r\n          transactionHash,\r\n          logIndex\r\n        )\r\n      );\r\n    }\r\n\r\n    function addMember(address _newMember) external onlyOwner override\r\n    {\r\n        require(_newMember != NULL_ADDRESS, \"Federation: Empty member\");\r\n        require(!isMember[_newMember], \"Federation: Member already exists\");\r\n        require(members.length < MAX_MEMBER_COUNT, \"Federation: Max members reached\");\r\n\r\n        isMember[_newMember] = true;\r\n        members.push(_newMember);\r\n        emit MemberAddition(_newMember);\r\n    }\r\n\r\n    function removeMember(address _oldMember) external onlyOwner override\r\n    {\r\n        require(_oldMember != NULL_ADDRESS, \"Federation: Empty member\");\r\n        require(isMember[_oldMember], \"Federation: Member doesn't exists\");\r\n        require(members.length > 1, \"Federation: Can't remove all the members\");\r\n        require(members.length - 1 >= required, \"Federation: Can't have less than required members\");\r\n\r\n        isMember[_oldMember] = false;\r\n        for (uint i = 0; i < members.length - 1; i++) {\r\n            if (members[i] == _oldMember) {\r\n                members[i] = members[members.length - 1];\r\n                break;\r\n            }\r\n        }\r\n        members.pop(); // remove an element from the end of the array.\r\n        emit MemberRemoval(_oldMember);\r\n    }\r\n\r\n    /**\r\n      @notice Return all the current members of the federation\r\n      @return Current members\r\n     */\r\n    function getMembers() external view override returns (address[] memory) {\r\n      return members;\r\n    }\r\n\r\n    /**\r\n      @notice Changes the number of required members to vote and approve an transaction\r\n      @dev Emits the RequirementChange event\r\n      @param _required the number of minimum members to approve an transaction, it has to be bigger than 1\r\n     */\r\n    function changeRequirement(uint _required) external onlyOwner validRequirement(members.length, _required) override {\r\n      require(_required >= 2, \"Federation: Requires at least 2\");\r\n      required = _required;\r\n      emit RequirementChange(_required);\r\n    }\r\n\r\n    /**\r\n      @notice It emits an HeartBeat like an health check\r\n      @dev Emits HeartBeat event\r\n     */\r\n    function emitHeartbeat(\r\n      uint256 fedRskBlock,\r\n      uint256 fedEthBlock,\r\n      string calldata federatorVersion,\r\n      string calldata nodeRskInfo,\r\n      string calldata nodeEthInfo\r\n    ) external onlyMember override {\r\n      emit HeartBeat(\r\n        _msgSender(),\r\n        fedRskBlock,\r\n        fedEthBlock,\r\n        federatorVersion,\r\n        nodeRskInfo,\r\n        nodeEthInfo\r\n      );\r\n    }\r\n}\r\n"
    },
    "contracts/interface/IFederation.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.7.0;\r\npragma abicoder v2;\r\n\r\ninterface IFederation {\r\n  enum TokenType{ COIN, NFT }\r\n\r\n  /**\r\n    @notice Current version of the contract\r\n    @return version in v{Number}\r\n    */\r\n  function version() external pure returns (string memory);\r\n\r\n  /**\r\n    @notice Sets a new bridge contract\r\n    @param _bridge the new bridge contract address that should implement the IBridge interface\r\n  */\r\n  function setBridge(address _bridge) external;\r\n\r\n  /**\r\n    @notice Sets a new NFT bridge contract\r\n    @param _bridgeNFT the new NFT bridge contract address that should implement the INFTBridge interface\r\n  */\r\n  function setNFTBridge(address _bridgeNFT) external;\r\n\r\n  /**\r\n    @notice Vote in a transaction, if it has enough votes it accepts the transfer\r\n    @param originalTokenAddress The address of the token in the origin (main) chain\r\n    @param sender The address who solicited the cross token\r\n    @param receiver Who is going to receive the token in the opposite chain\r\n    @param value Could be the amount if tokenType == COIN or the tokenId if tokenType == NFT\r\n    @param blockHash The block hash in which the transaction with the cross event occurred\r\n    @param transactionHash The transaction in which the cross event occurred\r\n    @param logIndex Index of the event in the logs\r\n    @param tokenType Is the type of bridge to be used\r\n  */\r\n  function voteTransaction(\r\n    address originalTokenAddress,\r\n    address payable sender,\r\n    address payable receiver,\r\n    uint256 value,\r\n    bytes32 blockHash,\r\n    bytes32 transactionHash,\r\n    uint32 logIndex,\r\n    TokenType tokenType\r\n  ) external;\r\n\r\n  /**\r\n    @notice Add a new member to the federation\r\n    @param _newMember address of the new member\r\n  */\r\n  function addMember(address _newMember) external;\r\n\r\n  /**\r\n    @notice Remove a member of the federation\r\n    @param _oldMember address of the member to be removed from federation\r\n  */\r\n  function removeMember(address _oldMember) external;\r\n\r\n  /**\r\n    @notice Return all the current members of the federation\r\n    @return Current members\r\n  */\r\n  function getMembers() external view returns (address[] memory);\r\n\r\n  /**\r\n    @notice Changes the number of required members to vote and approve an transaction\r\n    @param _required the number of minimum members to approve an transaction, it has to be bigger than 1\r\n  */\r\n  function changeRequirement(uint _required) external;\r\n\r\n  /**\r\n    @notice It emmits an HeartBeat like an healthy check\r\n  */\r\n  function emitHeartbeat(\r\n    uint256 fedRskBlock,\r\n    uint256 fedEthBlock,\r\n    string calldata federatorVersion,\r\n    string calldata nodeRskInfo,\r\n    string calldata nodeEthInfo\r\n  ) external;\r\n\r\n  event Executed(\r\n    address indexed federator,\r\n    bytes32 indexed transactionHash,\r\n    bytes32 indexed transactionId,\r\n    address originalTokenAddress,\r\n    address sender,\r\n    address receiver,\r\n    uint256 amount,\r\n    bytes32 blockHash,\r\n    uint32 logIndex\r\n  );\r\n  event MemberAddition(address indexed member);\r\n  event MemberRemoval(address indexed member);\r\n  event RequirementChange(uint required);\r\n  event BridgeChanged(address bridge);\r\n  event NFTBridgeChanged(address bridgeNFT);\r\n  event Voted(\r\n    address indexed federator,\r\n    bytes32 indexed transactionHash,\r\n    bytes32 indexed transactionId,\r\n    address originalTokenAddress,\r\n    address sender,\r\n    address receiver,\r\n    uint256 amount,\r\n    bytes32 blockHash,\r\n    uint32 logIndex\r\n  );\r\n  event HeartBeat(\r\n    address indexed sender,\r\n    uint256 fedRskBlock,\r\n    uint256 fedEthBlock,\r\n    string federatorVersion,\r\n    string nodeRskInfo,\r\n    string nodeEthInfo\r\n  );\r\n\r\n}\r\n"
    },
    "contracts/zeppelin/access/roles/MinterRole.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\npragma abicoder v2;\r\n\r\nimport \"../../GSN/Context.sol\";\r\nimport \"../Roles.sol\";\r\n\r\nabstract contract MinterRole is Context {\r\n    using Roles for Roles.Role;\r\n\r\n    event MinterAdded(address indexed account);\r\n    event MinterRemoved(address indexed account);\r\n\r\n    Roles.Role private _minters;\r\n\r\n    constructor () {\r\n        _addMinter(_msgSender());\r\n    }\r\n\r\n    modifier onlyMinter() {\r\n        require(isMinter(_msgSender()), \"MinterRole: caller doesn't have the role\");\r\n        _;\r\n    }\r\n\r\n    function isMinter(address account) public view returns (bool) {\r\n        return _minters.has(account);\r\n    }\r\n\r\n    function addMinter(address account) public onlyMinter {\r\n        _addMinter(account);\r\n    }\r\n\r\n    function renounceMinter() public {\r\n        _removeMinter(_msgSender());\r\n    }\r\n\r\n    function _addMinter(address account) internal {\r\n        _minters.add(account);\r\n        emit MinterAdded(account);\r\n    }\r\n\r\n    function _removeMinter(address account) internal {\r\n        _minters.remove(account);\r\n        emit MinterRemoved(account);\r\n    }\r\n}\r\n"
    },
    "contracts/zeppelin/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\npragma abicoder v2;\r\n\r\nimport \"../../GSN/Context.sol\";\r\nimport \"./IERC20.sol\";\r\nimport \"../../math/SafeMath.sol\";\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20Mintable}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin guidelines: functions revert instead\r\n * of returning `false` on failure. This behavior is nonetheless conventional\r\n * and does not conflict with the expectations of ERC20 applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract ERC20 is Context, IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() override public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) override public view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount) override public returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) override public view returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) override public returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20};\r\n     *\r\n     * Requirements:\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for `sender`'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) override public returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * This is internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(address sender, address recipient, uint256 amount) internal {\r\n        require(sender != address(0), \"ERC20: transfer from zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to zero address\");\r\n\r\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: mint to zero address\");\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n     /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: burn from zero address\");\r\n\r\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\r\n     *\r\n     * This is internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(address owner, address spender, uint256 amount) internal {\r\n        require(owner != address(0), \"ERC20: approve from zero address\");\r\n        require(spender != address(0), \"ERC20: approve to zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\r\n     * from the caller's allowance.\r\n     *\r\n     * See {_burn} and {_approve}.\r\n     */\r\n    function _burnFrom(address account, uint256 amount) internal {\r\n        _burn(account, amount);\r\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"ERC20: burn amount exceeds allowance\"));\r\n    }\r\n}\r\n"
    },
    "contracts/test/mockERC677Reciever.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\n\r\nimport \"../zeppelin/token/ERC20/ERC20Detailed.sol\";\r\nimport \"../zeppelin/token/ERC20/ERC20.sol\";\r\nimport \"../interface/IERC677Receiver.sol\";\r\n\r\ncontract mockERC677Receiver is IERC677Receiver {\r\n    event Success(address _sender, uint _value, bytes _data);\r\n    /**\r\n     * ERC-677's only method implementation\r\n     * See https://github.com/ethereum/EIPs/issues/677 for details\r\n     */\r\n    function onTokenTransfer(address _sender, uint _value, bytes memory _data) override public {\r\n        emit Success(_sender, _value, _data);\r\n    }\r\n}"
    },
    "contracts/zeppelin/token/ERC20/ERC20Detailed.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\npragma abicoder v2;\r\n\r\nimport \"./IERC20.sol\";\r\n\r\n/**\r\n * @dev Optional functions from the ERC20 standard.\r\n */\r\nabstract contract ERC20Detailed is IERC20 {\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    /**\r\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\r\n     * these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    constructor (string memory aName, string memory aSymbol, uint8 theDecimals) {\r\n        _name = aName;\r\n        _symbol = aSymbol;\r\n        _decimals = theDecimals;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei.\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n}\r\n"
    },
    "contracts/zeppelin/upgradable/proxy/UpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\npragma abicoder v2;\r\n\r\nimport \"./Proxy.sol\";\r\nimport \"../../utils/Address.sol\";\r\n\r\n/**\r\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\r\n * implementation address that can be changed. This address is stored in storage in the location specified by\r\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\r\n * implementation behind the proxy.\r\n *\r\n * Upgradeability is only provided internally through {_upgradeTo}. For an externally upgradeable proxy see\r\n * {TransparentUpgradeableProxy}.\r\n */\r\ncontract UpgradeableProxy is Proxy {\r\n    /**\r\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\r\n     *\r\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\r\n     * function call, and allows initializating the storage of the proxy like a Solidity constructor.\r\n     */\r\n    constructor(address _logic, bytes memory _data) payable {\r\n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\r\n        _setImplementation(_logic);\r\n        if(_data.length > 0) {\r\n            Address.functionDelegateCall(_logic, _data);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Emitted when the implementation is upgraded.\r\n     */\r\n    event Upgraded(address indexed implementation);\r\n\r\n    /**\r\n     * @dev Storage slot with the address of the current implementation.\r\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\r\n     * validated in the constructor.\r\n     */\r\n    bytes32 private constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\r\n\r\n    /**\r\n     * @dev Returns the current implementation address.\r\n     */\r\n    function _implementation() internal view virtual override returns (address impl) {\r\n        bytes32 slot = _IMPLEMENTATION_SLOT;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            impl := sload(slot)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Upgrades the proxy to a new implementation.\r\n     *\r\n     * Emits an {Upgraded} event.\r\n     */\r\n    function _upgradeTo(address newImplementation) internal virtual {\r\n        _setImplementation(newImplementation);\r\n        emit Upgraded(newImplementation);\r\n    }\r\n\r\n    /**\r\n     * @dev Stores a new address in the EIP1967 implementation slot.\r\n     */\r\n    function _setImplementation(address newImplementation) private {\r\n        require(Address.isContract(newImplementation), \"UpgradeableProxy: new implementation is not a contract\");\r\n\r\n        bytes32 slot = _IMPLEMENTATION_SLOT;\r\n\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            sstore(slot, newImplementation)\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/zeppelin/upgradable/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\npragma abicoder v2;\r\n\r\n/**\r\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\r\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\r\n * be specified by overriding the virtual {_implementation} function.\r\n *\r\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\r\n * different contract through the {_delegate} function.\r\n *\r\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\r\n */\r\nabstract contract Proxy {\r\n    /**\r\n     * @dev Delegates the current call to `implementation`.\r\n     *\r\n     * This function does not return to its internall call site, it will return directly to the external caller.\r\n     */\r\n    function _delegate(address implementation) internal virtual {\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            // Copy msg.data. We take full control of memory in this inline assembly\r\n            // block because it will not return to Solidity code. We overwrite the\r\n            // Solidity scratch pad at memory position 0.\r\n            calldatacopy(0, 0, calldatasize())\r\n\r\n            // Call the implementation.\r\n            // out and outsize are 0 because we don't know the size yet.\r\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\r\n\r\n            // Copy the returned data.\r\n            returndatacopy(0, 0, returndatasize())\r\n\r\n            switch result\r\n            // delegatecall returns 0 on error.\r\n            case 0 { revert(0, returndatasize()) }\r\n            default { return(0, returndatasize()) }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\r\n     * and {_fallback} should delegate.\r\n     */\r\n    function _implementation() internal view virtual returns (address);\r\n\r\n    /**\r\n     * @dev Delegates the current call to the address returned by `_implementation()`.\r\n     *\r\n     * This function does not return to its internall call site, it will return directly to the external caller.\r\n     */\r\n    function _fallback() internal virtual {\r\n        _beforeFallback();\r\n        _delegate(_implementation());\r\n    }\r\n\r\n    /**\r\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\r\n     * function in the contract matches the call data.\r\n     */\r\n    fallback () external payable virtual {\r\n        _fallback();\r\n    }\r\n\r\n    /**\r\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\r\n     * is empty.\r\n     */\r\n    receive () external payable virtual {\r\n        _fallback();\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\r\n     * call, or as part of the Solidity `fallback` or `receive` functions.\r\n     *\r\n     * If overriden should call `super._beforeFallback()`.\r\n     */\r\n    function _beforeFallback() internal virtual {\r\n    }\r\n}\r\n"
    },
    "contracts/zeppelin/upgradable/proxy/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\npragma abicoder v2;\r\n\r\nimport \"./UpgradeableProxy.sol\";\r\n\r\n/**\r\n * @dev This contract implements a proxy that is upgradeable by an admin.\r\n *\r\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\r\n * clashing], which can potentially be used in an attack, this contract uses the\r\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\r\n * things that go hand in hand:\r\n *\r\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\r\n * that call matches one of the admin functions exposed by the proxy itself.\r\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\r\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\r\n * \"admin cannot fallback to proxy target\".\r\n *\r\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\r\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\r\n * to sudden errors when trying to call a function from the proxy implementation.\r\n *\r\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\r\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\r\n */\r\ncontract TransparentUpgradeableProxy is UpgradeableProxy {\r\n    /**\r\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\r\n     * optionally initialized with `_data` as explained in {UpgradeableProxy-constructor}.\r\n     */\r\n    constructor(address _logic, address admin_, bytes memory _data) payable UpgradeableProxy(_logic, _data) {\r\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\r\n        _setAdmin(admin_);\r\n    }\r\n\r\n    /**\r\n     * @dev Emitted when the admin account has changed.\r\n     */\r\n    event AdminChanged(address previousAdmin, address newAdmin);\r\n\r\n    /**\r\n     * @dev Storage slot with the admin of the contract.\r\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\r\n     * validated in the constructor.\r\n     */\r\n    bytes32 private constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\r\n\r\n    /**\r\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\r\n     */\r\n    modifier ifAdmin() {\r\n        if (msg.sender == _admin()) {\r\n            _;\r\n        } else {\r\n            _fallback();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the current admin.\r\n     *\r\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\r\n     *\r\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\r\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\r\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\r\n     */\r\n    function admin() external ifAdmin returns (address admin_) {\r\n        admin_ = _admin();\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the current implementation.\r\n     *\r\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\r\n     *\r\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\r\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\r\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\r\n     */\r\n    function implementation() external ifAdmin returns (address implementation_) {\r\n        implementation_ = _implementation();\r\n    }\r\n\r\n    /**\r\n     * @dev Changes the admin of the proxy.\r\n     *\r\n     * Emits an {AdminChanged} event.\r\n     *\r\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\r\n     */\r\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\r\n        require(newAdmin != address(0), \"TransparentUpgradeableProxy: new admin is the zero address\");\r\n        emit AdminChanged(_admin(), newAdmin);\r\n        _setAdmin(newAdmin);\r\n    }\r\n\r\n    /**\r\n     * @dev Upgrade the implementation of the proxy.\r\n     *\r\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\r\n     */\r\n    function upgradeTo(address newImplementation) external virtual ifAdmin {\r\n        _upgradeTo(newImplementation);\r\n    }\r\n\r\n    /**\r\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\r\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\r\n     * proxied contract.\r\n     *\r\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\r\n     */\r\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable virtual ifAdmin {\r\n        _upgradeTo(newImplementation);\r\n        Address.functionDelegateCall(newImplementation, data);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the current admin.\r\n     */\r\n    function _admin() internal view virtual returns (address adm) {\r\n        bytes32 slot = _ADMIN_SLOT;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            adm := sload(slot)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Stores a new address in the EIP1967 admin slot.\r\n     */\r\n    function _setAdmin(address newAdmin) private {\r\n        bytes32 slot = _ADMIN_SLOT;\r\n\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            sstore(slot, newAdmin)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\r\n     */\r\n    function _beforeFallback() internal virtual override {\r\n        require(msg.sender != _admin(), \"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");\r\n        super._beforeFallback();\r\n    }\r\n}\r\n"
    },
    "contracts/zeppelin/upgradable/proxy/ProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.7.0;\r\npragma abicoder v2;\r\n\r\nimport \"../../ownership/Ownable.sol\";\r\nimport \"./TransparentUpgradeableProxy.sol\";\r\n\r\n/**\r\n * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an\r\n * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.\r\n */\r\ncontract ProxyAdmin is Ownable {\r\n\r\n    /**\r\n     * @dev Returns the current implementation of `proxy`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - This contract must be the admin of `proxy`.\r\n     */\r\n    function getProxyImplementation(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\r\n        // We need to manually run the static call since the getter cannot be flagged as view\r\n        // bytes4(keccak256(\"implementation()\")) == 0x5c60da1b\r\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"5c60da1b\");\r\n        require(success);\r\n        return abi.decode(returndata, (address));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the current admin of `proxy`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - This contract must be the admin of `proxy`.\r\n     */\r\n    function getProxyAdmin(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\r\n        // We need to manually run the static call since the getter cannot be flagged as view\r\n        // bytes4(keccak256(\"admin()\")) == 0xf851a440\r\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"f851a440\");\r\n        require(success);\r\n        return abi.decode(returndata, (address));\r\n    }\r\n\r\n    /**\r\n     * @dev Changes the admin of `proxy` to `newAdmin`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - This contract must be the current admin of `proxy`.\r\n     */\r\n    function changeProxyAdmin(TransparentUpgradeableProxy proxy, address newAdmin) public virtual onlyOwner {\r\n        proxy.changeAdmin(newAdmin);\r\n    }\r\n\r\n    /**\r\n     * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - This contract must be the admin of `proxy`.\r\n     */\r\n    function upgrade(TransparentUpgradeableProxy proxy, address implementation) public virtual onlyOwner {\r\n        proxy.upgradeTo(implementation);\r\n    }\r\n\r\n    /**\r\n     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See\r\n     * {TransparentUpgradeableProxy-upgradeToAndCall}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - This contract must be the admin of `proxy`.\r\n     */\r\n    function upgradeAndCall(TransparentUpgradeableProxy proxy, address implementation, bytes memory data) public payable virtual onlyOwner {\r\n        proxy.upgradeToAndCall{value: msg.value}(implementation, data);\r\n    }\r\n}\r\n"
    },
    "contracts/Federation/FederationV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\n\r\nimport \"../Bridge/IBridgeV2.sol\";\r\nimport \"../zeppelin/ownership/Ownable.sol\";\r\n\r\ncontract FederationV1 is Ownable {\r\n    uint constant public MAX_MEMBER_COUNT = 50;\r\n    address constant private NULL_ADDRESS = address(0);\r\n\r\n    IBridgeV2 public bridge;\r\n    address[] public members;\r\n    uint public required;\r\n\r\n    mapping (address => bool) public isMember;\r\n    mapping (bytes32 => mapping (address => bool)) public votes;\r\n    mapping(bytes32 => bool) public processed;\r\n    // solium-disable-next-line max-len\r\n    event Voted(address indexed sender, bytes32 indexed transactionId, address originalTokenAddress, address receiver, uint256 amount, string symbol, bytes32 blockHash, bytes32 indexed transactionHash, uint32 logIndex, uint8 decimals, uint256 granularity);\r\n    event Executed(bytes32 indexed transactionId);\r\n    event MemberAddition(address indexed member);\r\n    event MemberRemoval(address indexed member);\r\n    event RequirementChange(uint required);\r\n    event BridgeChanged(address bridge);\r\n\r\n    modifier onlyMember() {\r\n        require(isMember[_msgSender()], \"Federation: Caller not a Federator\");\r\n        _;\r\n    }\r\n\r\n    modifier validRequirement(uint membersCount, uint _required) {\r\n        // solium-disable-next-line max-len\r\n        require(_required <= membersCount && _required != 0 && membersCount != 0, \"Federation: Invalid requirements\");\r\n        _;\r\n    }\r\n\r\n    constructor(address[] memory _members, uint _required) validRequirement(_members.length, _required) {\r\n        require(_members.length <= MAX_MEMBER_COUNT, \"Federation: Members larger than max allowed\");\r\n        members = _members;\r\n        for (uint i = 0; i < _members.length; i++) {\r\n            require(!isMember[_members[i]] && _members[i] != NULL_ADDRESS, \"Federation: Invalid members\");\r\n            isMember[_members[i]] = true;\r\n            emit MemberAddition(_members[i]);\r\n        }\r\n        required = _required;\r\n        emit RequirementChange(required);\r\n    }\r\n\r\n    function setBridge(address _bridge) external onlyOwner {\r\n        require(_bridge != NULL_ADDRESS, \"Federation: Empty bridge\");\r\n        bridge = IBridgeV2(_bridge);\r\n        emit BridgeChanged(_bridge);\r\n    }\r\n\r\n    function voteTransaction(\r\n        address originalTokenAddress,\r\n        address receiver,\r\n        uint256 amount,\r\n        string calldata symbol,\r\n        bytes32 blockHash,\r\n        bytes32 transactionHash,\r\n        uint32 logIndex,\r\n        uint8 decimals,\r\n        uint256 granularity)\r\n    external onlyMember returns(bool)\r\n    {\r\n        // solium-disable-next-line max-len\r\n        bytes32 transactionId = getTransactionId(originalTokenAddress, receiver, amount, symbol, blockHash, transactionHash, logIndex, decimals, granularity);\r\n        if (processed[transactionId])\r\n            return true;\r\n\r\n        if (votes[transactionId][_msgSender()])\r\n            return true;\r\n\r\n        votes[transactionId][_msgSender()] = true;\r\n        // solium-disable-next-line max-len\r\n        emit Voted(_msgSender(), transactionId, originalTokenAddress, receiver, amount, symbol, blockHash, transactionHash, logIndex, decimals, granularity);\r\n\r\n        uint transactionCount = getTransactionCount(transactionId);\r\n        if (transactionCount >= required && transactionCount >= members.length / 2 + 1) {\r\n            processed[transactionId] = true;\r\n            bool acceptTransfer = bridge.acceptTransfer(originalTokenAddress, receiver, amount, symbol, blockHash, transactionHash, logIndex, decimals, granularity);\r\n            require(acceptTransfer, \"Federation: Bridge acceptTransfer error\");\r\n            emit Executed(transactionId);\r\n            return true;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function getTransactionCount(bytes32 transactionId) public view returns(uint) {\r\n        uint count = 0;\r\n        for (uint i = 0; i < members.length; i++) {\r\n            if (votes[transactionId][members[i]])\r\n                count += 1;\r\n        }\r\n        return count;\r\n    }\r\n\r\n    function hasVoted(bytes32 transactionId) external view returns(bool)\r\n    {\r\n        return votes[transactionId][_msgSender()];\r\n    }\r\n\r\n    function transactionWasProcessed(bytes32 transactionId) external view returns(bool)\r\n    {\r\n        return processed[transactionId];\r\n    }\r\n\r\n    function getTransactionId(\r\n        address originalTokenAddress,\r\n        address receiver,\r\n        uint256 amount,\r\n        string memory symbol,\r\n        bytes32 blockHash,\r\n        bytes32 transactionHash,\r\n        uint32 logIndex,\r\n        uint8 decimals,\r\n        uint256 granularity)\r\n    public pure returns(bytes32)\r\n    {\r\n        // solium-disable-next-line max-len\r\n        return keccak256(abi.encodePacked(originalTokenAddress, receiver, amount, symbol, blockHash, transactionHash, logIndex, decimals, granularity));\r\n    }\r\n\r\n    function addMember(address _newMember) external onlyOwner\r\n    {\r\n        require(_newMember != NULL_ADDRESS, \"Federation: Empty member\");\r\n        require(!isMember[_newMember], \"Federation: Member already exists\");\r\n        require(members.length < MAX_MEMBER_COUNT, \"Federation: Max members reached\");\r\n\r\n        isMember[_newMember] = true;\r\n        members.push(_newMember);\r\n        emit MemberAddition(_newMember);\r\n    }\r\n\r\n    function removeMember(address _oldMember) external onlyOwner\r\n    {\r\n        require(_oldMember != NULL_ADDRESS, \"Federation: Empty member\");\r\n        require(isMember[_oldMember], \"Federation: Member doesn't exists\");\r\n        require(members.length > 1, \"Federation: Can't remove all the members\");\r\n        require(members.length - 1 >= required, \"Federation: Can't have less than required members\");\r\n\r\n        isMember[_oldMember] = false;\r\n        for (uint i = 0; i < members.length - 1; i++) {\r\n            if (members[i] == _oldMember) {\r\n                members[i] = members[members.length - 1];\r\n                break;\r\n            }\r\n        }\r\n        members.pop(); // remove last element\r\n        emit MemberRemoval(_oldMember);\r\n    }\r\n\r\n    function getMembers() external view returns (address[] memory)\r\n    {\r\n        return members;\r\n    }\r\n\r\n    function changeRequirement(uint _required) external onlyOwner validRequirement(members.length, _required)\r\n    {\r\n        require(_required >= 2, \"Federation: Requires at least 2\");\r\n        required = _required;\r\n        emit RequirementChange(_required);\r\n    }\r\n\r\n}"
    },
    "contracts/Proxies.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\npragma abicoder v2;\r\n\r\nimport \"./zeppelin/upgradable/proxy/TransparentUpgradeableProxy.sol\";\r\n\r\ncontract BridgeProxy is TransparentUpgradeableProxy {\r\n  // solhint-disable-next-line no-empty-blocks\r\n  constructor(address _logic, address _admin, bytes memory _data) TransparentUpgradeableProxy(_logic,_admin, _data) payable {}\r\n}\r\n\r\ncontract AllowTokensProxy is TransparentUpgradeableProxy {\r\n  // solhint-disable-next-line no-empty-blocks\r\n  constructor(address _logic, address _admin, bytes memory _data) TransparentUpgradeableProxy(_logic,_admin, _data) payable {}\r\n}\r\n\r\ncontract FederationProxy is TransparentUpgradeableProxy {\r\n  // solhint-disable-next-line no-empty-blocks\r\n  constructor(address _logic, address _admin, bytes memory _data) TransparentUpgradeableProxy(_logic,_admin, _data) payable {}\r\n}"
    },
    "contracts/test/MainToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\n\r\nimport \"../zeppelin/token/ERC20/ERC20Detailed.sol\";\r\nimport \"../zeppelin/token/ERC20/ERC20.sol\";\r\n\r\ncontract MainToken is ERC20Detailed, ERC20 {\r\n    constructor(string memory name, string memory symbol, uint8 decimals, uint totalSupply)\r\n        ERC20Detailed(name, symbol, decimals)\r\n    {\r\n        _mint(msg.sender, totalSupply);\r\n    }\r\n\r\n    /**\r\n     * ERC-677's only method implementation\r\n     * See https://github.com/ethereum/EIPs/issues/677 for details\r\n     */\r\n    function transferAndCall(address _to, uint _value, bytes memory _data) public returns (bool) {\r\n        bool result = transfer(_to, _value);\r\n        if (!result) return false;\r\n\r\n        ERC677TransferReceiver receiver = ERC677TransferReceiver(_to);\r\n        receiver.tokenFallback(msg.sender, _value, _data);\r\n\r\n        // IMPORTANT: the ERC-677 specification does not say\r\n        // anything about the use of the receiver contract's\r\n        // tokenFallback method return value. Given\r\n        // its return type matches with this method's return\r\n        // type, returning it could be a possibility.\r\n        // We here take the more conservative approach and\r\n        // ignore the return value, returning true\r\n        // to signal a succesful transfer despite tokenFallback's\r\n        // return value -- fact being tokens are transferred\r\n        // in any case.\r\n        return true;\r\n    }\r\n}\r\n\r\ninterface ERC677TransferReceiver {\r\n    function tokenFallback(address from, uint256 amount, bytes calldata data) external returns (bool);\r\n}"
    },
    "contracts/test/AlternativeERC20Detailed.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\n\r\nimport \"../zeppelin/token/ERC20/ERC20.sol\";\r\n\r\ncontract AlternativeERC20Detailed is ERC20 {\r\n    string private _name;\r\n    bytes32 private _symbol;\r\n    uint256 private _decimals;\r\n\r\n    constructor(string memory aName, bytes32 aSymbol, uint256 someDecimals, uint256 aTotalSupply)\r\n    {\r\n        _name = aName;\r\n        _symbol = aSymbol;\r\n        _decimals = someDecimals;\r\n        _mint(msg.sender, aTotalSupply);\r\n    }\r\n\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view returns (bytes32) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view returns (uint256) {\r\n        return _decimals;\r\n    }\r\n}"
    },
    "contracts/test/nftbridge/NFTERC721TestToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.7.6;\r\n\r\nimport \"../../zeppelin/token/ERC721/ERC721.sol\";\r\n\r\ncontract NFTERC721TestToken is ERC721 {\r\n\r\n  string private _contractURI;\r\n\r\n  constructor(string memory name_, string memory symbol_) ERC721(name_, symbol_) {}\r\n\r\n  function safeMint(address to, uint256 tokenId) public {\r\n    _safeMint(to, tokenId);\r\n  }\r\n\r\n  function setBaseURI(string memory baseURI) public {\r\n    _setBaseURI(baseURI);\r\n  }\r\n\r\n  function setContractURI(string memory contractURI_) public {\r\n    _contractURI = contractURI_;\r\n  }\r\n\r\n  function contractURI() public view returns (string memory) {\r\n    return _contractURI;\r\n  }\r\n\r\n  function setTokenURI(uint256 tokenId, string memory _tokenURI) public {\r\n    _setTokenURI(tokenId, _tokenURI);\r\n  }\r\n\r\n}\r\n"
    },
    "contracts/nftbridge/SideNFTToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\npragma abicoder v2;\r\n\r\nimport \"./ISideNFTToken.sol\";\r\nimport \"../zeppelin/token/ERC721/ERC721.sol\";\r\nimport \"../zeppelin/token/ERC721/ERC721Burnable.sol\";\r\n\r\ncontract SideNFTToken is ISideNFTToken, ERC721, ERC721Burnable {\r\n  address public minter;\r\n  string private _contractURI;\r\n\r\n  constructor(string memory _name, string memory _symbol, address _minter, string memory _baseURI, string memory contractURI_) ERC721(_name, _symbol) {\r\n    require(_minter != address(0), \"SideToken: Empty Minter\");\r\n    minter = _minter;\r\n    _setBaseURI(_baseURI);\r\n    _setContractURI(contractURI_);\r\n  }\r\n\r\n  function _setContractURI(string memory contractURI_) internal {\r\n    _contractURI = contractURI_;\r\n  }\r\n\r\n  function contractURI() public view returns (string memory) {\r\n    return _contractURI;\r\n  }\r\n\r\n  modifier onlyMinter() {\r\n    require(_msgSender() == minter, \"SideToken: Caller is not the minter\");\r\n    _;\r\n  }\r\n\r\n  function mint(address account, uint256 tokenId) external onlyMinter override {\r\n    _mint(account, tokenId);\r\n  }\r\n}"
    },
    "contracts/nftbridge/SideNFTTokenFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\npragma abicoder v2;\r\n\r\nimport \"../zeppelin/ownership/Secondary.sol\";\r\nimport \"./ISideNFTTokenFactory.sol\";\r\nimport \"./SideNFTToken.sol\";\r\n\r\ncontract SideNFTTokenFactory is ISideNFTTokenFactory, Secondary {\r\n\r\n    function createSideNFTToken(string calldata name, string calldata symbol, string calldata baseURI,\r\n        string calldata contractURI) external onlyPrimary override returns(address) {\r\n        address sideTokenAddress = address(new SideNFTToken(name, symbol, primary(), baseURI, contractURI));\r\n        emit SideNFTTokenCreated(sideTokenAddress, symbol, baseURI, contractURI);\r\n        return sideTokenAddress;\r\n    }\r\n}"
    },
    "contracts/zeppelin/token/ERC1155/ERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\n\r\nimport \"./IERC1155Receiver.sol\";\r\nimport \"../../introspection/ERC165.sol\";\r\n\r\n/**\r\n * @dev _Available since v3.1._\r\n */\r\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\r\n    constructor() {\r\n        _registerInterface(\r\n            ERC1155Receiver(address(0)).onERC1155Received.selector ^\r\n            ERC1155Receiver(address(0)).onERC1155BatchReceived.selector\r\n        );\r\n    }\r\n}\r\n"
    },
    "contracts/zeppelin/token/ERC1155/ERC1155Holder.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\n\r\nimport \"./ERC1155Receiver.sol\";\r\n\r\n/**\r\n * @dev _Available since v3.1._\r\n */\r\ncontract ERC1155Holder is ERC1155Receiver {\r\n    function onERC1155Received(address, address, uint256, uint256, bytes memory) public virtual override returns (bytes4) {\r\n        return this.onERC1155Received.selector;\r\n    }\r\n\r\n    function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) public virtual override returns (bytes4) {\r\n        return this.onERC1155BatchReceived.selector;\r\n    }\r\n}\r\n"
    },
    "contracts/zeppelin/token/ERC721/ERC721Holder.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\n\r\nimport \"./IERC721Receiver.sol\";\r\n\r\n  /**\r\n   * @dev Implementation of the {IERC721Receiver} interface.\r\n   *\r\n   * Accepts all token transfers. \r\n   * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\r\n   */\r\ncontract ERC721Holder is IERC721Receiver {\r\n\r\n    /**\r\n     * @dev See {IERC721Receiver-onERC721Received}.\r\n     *\r\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\r\n     */\r\n    function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {\r\n        return this.onERC721Received.selector;\r\n    }\r\n}\r\n"
    },
    "contracts/zeppelin/token/ERC1155/ERC1155Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\n\r\nimport \"./ERC1155.sol\";\r\n\r\n/**\r\n * @dev Extension of {ERC1155} that allows token holders to destroy both their\r\n * own tokens and those that they have been approved to use.\r\n *\r\n * _Available since v3.1._\r\n */\r\nabstract contract ERC1155Burnable is ERC1155 {\r\n    function burn(address account, uint256 id, uint256 value) public virtual {\r\n        require(\r\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\r\n            \"ERC1155: caller is not owner nor approved\"\r\n        );\r\n\r\n        _burn(account, id, value);\r\n    }\r\n\r\n    function burnBatch(address account, uint256[] memory ids, uint256[] memory values) public virtual {\r\n        require(\r\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\r\n            \"ERC1155: caller is not owner nor approved\"\r\n        );\r\n\r\n        _burnBatch(account, ids, values);\r\n    }\r\n}\r\n"
    },
    "contracts/test/LibUtilsHarness.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\n\r\nimport \"../lib/LibUtils.sol\";\r\n\r\ncontract LibUtilsHarness {\r\n\r\n    function decimalsToGranularity(uint8 decimals) external pure returns (uint256) {\r\n        return LibUtils.decimalsToGranularity(decimals);\r\n    }\r\n\r\n    function getDecimals(address tokenToUse) external view returns (uint8) {\r\n        return LibUtils.getDecimals(tokenToUse);\r\n    }\r\n\r\n    function getGranularity(address tokenToUse) external view returns (uint256) {\r\n        return LibUtils.getGranularity(tokenToUse);\r\n    }\r\n\r\n    function bytesToAddress(bytes memory bys) external pure returns (address addr) {\r\n        return LibUtils.bytesToAddress(bys);\r\n    }\r\n\r\n}\r\n"
    }
  },
  "settings": {
    "evmVersion": "istanbul",
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}