{
  "language": "Solidity",
  "sources": {
    "contracts/Bridge/Bridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma abicoder v2;\n\n// import \"hardhat/console.sol\";\n// Import base Initializable contract\nimport \"../zeppelin/upgradable/Initializable.sol\";\n// Import interface and library from OpenZeppelin contracts\nimport \"../zeppelin/upgradable/utils/ReentrancyGuard.sol\";\nimport \"../zeppelin/upgradable/lifecycle/UpgradablePausable.sol\";\nimport \"../zeppelin/upgradable/ownership/UpgradableOwnable.sol\";\n\nimport \"../zeppelin/introspection/IERC1820Registry.sol\";\nimport \"../zeppelin/token/ERC777/IERC777Recipient.sol\";\nimport \"../zeppelin/token/ERC20/IERC20.sol\";\nimport \"../zeppelin/token/ERC20/SafeERC20.sol\";\nimport \"../zeppelin/utils/Address.sol\";\nimport \"../zeppelin/math/SafeMath.sol\";\nimport \"../zeppelin/token/ERC777/IERC777.sol\";\n\nimport \"../lib/LibEIP712.sol\";\nimport \"../lib/LibUtils.sol\";\n\nimport \"../interface/IBridge.sol\";\nimport \"../interface/ISideToken.sol\";\nimport \"../interface/ISideTokenFactory.sol\";\nimport \"../interface/IAllowTokens.sol\";\nimport \"../interface/IWrapped.sol\";\n\n// solhint-disable-next-line max-states-count\ncontract Bridge is Initializable, IBridge, IERC777Recipient, UpgradablePausable, UpgradableOwnable, ReentrancyGuard {\n\tusing SafeMath for uint256;\n\tusing SafeERC20 for IERC20;\n\tusing Address for address;\n\n\taddress constant internal NULL_ADDRESS = address(0);\n\tbytes32 constant internal NULL_HASH = bytes32(0);\n\tIERC1820Registry constant internal ERC1820 = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\n\n\taddress internal federation;\n\tuint256 internal feePercentage;\n\tstring public deprecatedSymbolPrefix;\n\t// domainSeparator replaces uint256 internal _depprecatedLastDay;\n\tbytes32 public domainSeparator;\n\tuint256 internal _deprecatedSpentToday;\n\n\tmapping (address => address) public deprecatedMappedTokens; // OriginalToken => SideToken\n\tmapping (address => address) public deprecatedOriginalTokens; // SideToken => OriginalToken\n\tmapping (address => bool) public deprecatedKnownTokens; // OriginalToken => true\n\n\t// claimed can use the same of bytes32\n\tmapping (bytes32 => bool) public claimed; // transactionDataHash => true // previously named processed\n\n\tIAllowTokens public allowTokens;\n\tISideTokenFactory public sideTokenFactory;\n\t//Bridge_v1 variables\n\tbool public isUpgrading;\n\t// Percentage with up to 2 decimals\n\tuint256 constant public feePercentageDivider = 10000; // solhint-disable-line const-name-snakecase\n\t//Bridge_v2 variables\n\tbytes32 constant internal _erc777Interface = keccak256(\"ERC777Token\"); // solhint-disable-line const-name-snakecase\n\tIWrapped public wrappedCurrency;\n\tmapping (bytes32 => bytes32) public transactionsDataHashes; // transactionHash => transactionDataHash\n\tmapping (bytes32 => address) public originalTokenAddresses; // transactionHash => originalTokenAddress\n\tmapping (bytes32 => address) public senderAddresses; // transactionHash => senderAddress\n\n\t// keccak256(\"Claim(address to,uint256 amount,bytes32 transactionHash,uint256 originChainId,address relayer,uint256 fee,uint256 nonce,uint256 deadline)\");\n\tbytes32 public constant CLAIM_TYPEHASH = 0xaf3ac34fea9cc1b1def33a9bdc482d988feb61b5015ae4a55e2a62bb3600d54c;\n\tmapping(address => uint) public nonces;\n\n\t//Bridge_v3 variables multichain\n\tmapping (uint256 => mapping(address => address)) public sideTokenByOriginalTokenByChain; // chainId => OriginalToken Address => SideToken Address\n\tmapping (address => OriginalToken) public originalTokenBySideToken; // SideTokenAddress => struct {}\n\tmapping (uint256 => mapping(address => bool)) public knownTokenByChain; // chainId => OriginalToken Address => Know\n\n\tevent AllowTokensChanged(address _newAllowTokens);\n\tevent FederationChanged(address _newFederation);\n\tevent SideTokenFactoryChanged(address _newSideTokenFactory);\n\tevent Upgrading(bool _isUpgrading);\n\tevent WrappedCurrencyChanged(address _wrappedCurrency);\n\n\tfunction initialize(\n\t\taddress _manager,\n\t\taddress _federation,\n\t\taddress _allowTokens,\n\t\taddress _sideTokenFactory\n\t) public initializer {\n\t\tUpgradableOwnable.initialize(_manager);\n\t\tUpgradablePausable.__Pausable_init(_manager);\n\t\tallowTokens = IAllowTokens(_allowTokens);\n\t\tsideTokenFactory = ISideTokenFactory(_sideTokenFactory);\n\t\tfederation = _federation;\n\t\t//keccak256(\"ERC777TokensRecipient\")\n\t\tERC1820.setInterfaceImplementer(address(this), 0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b, address(this));\n\t\tinitDomainSeparator();\n\t}\n\n\treceive () external payable {\n\t\t// The fallback function is needed to use WRBTC\n\t\trequire(_msgSender() == address(wrappedCurrency), \"Bridge: not wrappedCurrency\");\n\t}\n\n\tfunction version() override external pure returns (string memory) {\n\t\treturn \"v4\";\n\t}\n\n\tfunction initDomainSeparator() public {\n\t\tdomainSeparator = LibEIP712.hashEIP712Domain(\n\t\t\t\"RSK Token Bridge\",\n\t\t\t\"1\",\n\t\t\tblock.chainid,\n\t\t\taddress(this)\n\t\t);\n\t}\n\n\tmodifier whenNotUpgrading() {\n\t\trequire(!isUpgrading, \"Bridge: Upgrading\");\n\t\t_;\n\t}\n\n\tfunction shouldBeCurrentChainId(uint256 chainId) internal view {\n\t\trequire(chainId == block.chainid, \"Bridge: Not block.chainid\");\n\t}\n\n\tfunction sideTokenByOriginalToken(uint256 chainId, address originalToken) public view returns(address) {\n\t\taddress sideTokenAddr = sideTokenByOriginalTokenByChain[chainId][originalToken];\n\n\t\tif (sideTokenAddr != NULL_ADDRESS) {\n\t\t\treturn sideTokenAddr;\n\t\t}\n\n\t\t// specification for retrocompatibility\n\t\treturn deprecatedMappedTokens[originalToken];\n\t}\n\n\tfunction setSideTokenByOriginalAddressByChain(uint256 chainId, address originalToken, address sideToken) public onlyOwner {\n\t\tsideTokenByOriginalTokenByChain[chainId][originalToken] = sideToken;\n\t}\n\n\tfunction getOriginalTokenBySideToken(address sideToken) public view returns(OriginalToken memory originalToken) {\n\t\toriginalToken = originalTokenBySideToken[sideToken];\n\t\tif (originalToken.tokenAddress != NULL_ADDRESS) {\n\t\t\treturn originalToken;\n\t\t}\n\n\t\t// specification for retrocompatibility\n\t\toriginalToken.originChainId = 1; // ethereum main chain id\n\t\toriginalToken.tokenAddress = deprecatedOriginalTokens[sideToken];\n\t\treturn originalToken;\n\t}\n\n\tfunction setOriginalTokenBySideTokenByChain(address sideToken, OriginalToken memory originalToken) public onlyOwner {\n\t\toriginalTokenBySideToken[sideToken] = originalToken;\n\t}\n\n\tfunction knownToken(uint256 chainId, address originalToken) public view returns(bool) {\n\t\tbool knowToken = knownTokenByChain[chainId][originalToken];\n\t\tif (knowToken) {\n\t\t\treturn knowToken;\n\t\t}\n\n\t\t// specification for retrocompatibility\n\t\treturn deprecatedKnownTokens[originalToken];\n\t}\n\n\tfunction _setKnownTokenByChain(uint256 chainId, address originalToken, bool knownTokenValue) internal {\n\t\tknownTokenByChain[chainId][originalToken] = knownTokenValue;\n\t}\n\n\tfunction acceptTransfer(\n\t\taddress _originalTokenAddress,\n\t\taddress payable _from,\n\t\taddress payable _to,\n\t\tuint256 _amount,\n\t\tbytes32 _blockHash,\n\t\tbytes32 _transactionHash,\n\t\tuint32 _logIndex,\n\t\tuint256 _originChainId,\n\t\tuint256\t_destinationChainId\n\t) external whenNotPaused nonReentrant override {\n\t\trequire(_msgSender() == federation, \"Bridge: Not Federation\");\n\t\tcheckChainId(_originChainId);\n\t\tshouldBeCurrentChainId(_destinationChainId);\n\t\trequire(knownToken(_originChainId, _originalTokenAddress) ||\n\t\t\tsideTokenByOriginalToken(_originChainId, _originalTokenAddress) != NULL_ADDRESS,\n\t\t\t\"Bridge: Unknown token\"\n\t\t);\n\t\trequire(_to != NULL_ADDRESS, \"Bridge: Null To\");\n\t\trequire(_amount > 0, \"Bridge: Amount 0\");\n\t\trequire(_blockHash != NULL_HASH, \"Bridge: Null BlockHash\");\n\t\trequire(_transactionHash != NULL_HASH, \"Bridge: Null TxHash\");\n\t\trequire(transactionsDataHashes[_transactionHash] == bytes32(0), \"Bridge: Already accepted\");\n\n\t\tbytes32 _transactionDataHash = getTransactionDataHash(\n\t\t\t_to,\n\t\t\t_amount,\n\t\t\t_blockHash,\n\t\t\t_transactionHash,\n\t\t\t_logIndex\n\t\t);\n\n\t\tbytes32 _transactionDataHashMultichain = getTransactionDataHash(\n\t\t\t_to,\n\t\t\t_amount,\n\t\t\t_blockHash,\n\t\t\t_transactionHash,\n\t\t\t_logIndex,\n\t\t\t_originChainId,\n\t\t\t_destinationChainId\n\t\t);\n\t\t// Do not remove, claimed also has the previously processed using the older bridge version\n\t\t// https://github.com/rsksmart/tokenbridge/blob/TOKENBRIDGE-1.2.0/bridge/contracts/Bridge.sol#L41\n\t\trequire(!isClaimed(_transactionDataHash, _transactionDataHashMultichain), \"Bridge: Already claimed\");\n\n\t\ttransactionsDataHashes[_transactionHash] = _transactionDataHashMultichain;\n\t\toriginalTokenAddresses[_transactionHash] = _originalTokenAddress;\n\t\tsenderAddresses[_transactionHash] = _from;\n\n\t\temit AcceptedCrossTransfer(\n\t\t\t_transactionHash,\n\t\t\t_originalTokenAddress,\n\t\t\t_to,\n\t\t\t_from,\n\t\t\t_amount,\n\t\t\t_blockHash,\n\t\t\t_logIndex,\n\t\t\t_originChainId,\n\t\t\t_destinationChainId\n\t\t);\n\t}\n\n\tfunction checkChainId(uint256 chainId) internal pure {\n\t\trequire(chainId > 0, \"Bridge: ChainId is 0\");\n\t}\n\n\tfunction _createSideToken(\n\t\tuint256 _typeId,\n\t\taddress _originalTokenAddress,\n\t\tuint8 _originalTokenDecimals,\n\t\tstring calldata _tokenSymbol,\n\t\tstring calldata _tokenName,\n\t\tuint256 _originChainId\n\t) internal {\n\t\trequire(_originalTokenAddress != NULL_ADDRESS, \"Bridge: Null token\");\n\t\tcheckChainId(_originChainId);\n\t\taddress sideToken = sideTokenByOriginalToken(_originChainId, _originalTokenAddress);\n\t\trequire(sideToken == NULL_ADDRESS, \"Bridge: Already exists\");\n\n\t\tuint256 granularity = LibUtils.decimalsToGranularity(_originalTokenDecimals);\n\n\t\t// Create side token\n\t\tsideToken = sideTokenFactory.createSideToken(_tokenName, _tokenSymbol, granularity);\n\n\t\tsetSideTokenByOriginalAddressByChain(_originChainId, _originalTokenAddress, sideToken);\n\n\t\tOriginalToken memory originalToken;\n\t\toriginalToken.originChainId = _originChainId;\n\t\toriginalToken.tokenAddress = _originalTokenAddress;\n\t\tsetOriginalTokenBySideTokenByChain(sideToken, originalToken);\n\t\tallowTokens.setToken(sideToken, _typeId);\n\n\t\temit NewSideToken(sideToken, _originalTokenAddress, _tokenSymbol, granularity, _originChainId);\n\t}\n\n\tfunction createSideToken(\n\t\tuint256 _typeId,\n\t\taddress _originalTokenAddress,\n\t\tuint8 _originalTokenDecimals,\n\t\tstring calldata _tokenSymbol,\n\t\tstring calldata _tokenName,\n\t\tuint256 _originChainId\n\t) external onlyOwner override {\n\t\t_createSideToken(\n\t\t\t_typeId,\n\t\t\t_originalTokenAddress,\n\t\t\t_originalTokenDecimals,\n\t\t\t_tokenSymbol,\n\t\t\t_tokenName,\n\t\t\t_originChainId\n\t\t);\n\t}\n\n\tfunction createMultipleSideTokens(\n\t\tCreateSideTokenStruct[] calldata createSideTokenStruct\n\t) external onlyOwner {\n\t\tfor(uint256 i = 0; i < createSideTokenStruct.length; i++) {\n\t\t\t_createSideToken(\n\t\t\t\tcreateSideTokenStruct[i]._typeId,\n\t\t\t\tcreateSideTokenStruct[i]._originalTokenAddress,\n\t\t\t\tcreateSideTokenStruct[i]._originalTokenDecimals,\n\t\t\t\tcreateSideTokenStruct[i]._originalTokenSymbol,\n\t\t\t\tcreateSideTokenStruct[i]._originalTokenName,\n\t\t\t\tcreateSideTokenStruct[i]._originChainId\n\t\t\t);\n\t\t}\n\t}\n\n\tfunction claim(ClaimData calldata _claimData) external override returns (uint256 receivedAmount) {\n\t\treceivedAmount = _claim(\n\t\t\t_claimData,\n\t\t\t_claimData.to,\n\t\t\tpayable(address(0)),\n\t\t\t0\n\t\t);\n\t\treturn receivedAmount;\n\t}\n\n\tfunction claimFallback(ClaimData calldata _claimData) external override returns (uint256 receivedAmount) {\n\t\trequire(_msgSender() == senderAddresses[_claimData.transactionHash],\"Bridge: invalid sender\");\n\t\treceivedAmount = _claim(\n\t\t\t_claimData,\n\t\t\t_msgSender(),\n\t\t\tpayable(address(0)),\n\t\t\t0\n\t\t);\n\t\treturn receivedAmount;\n\t}\n\n\tfunction getDigest(\n\t\tClaimData memory _claimData,\n\t\taddress payable _relayer,\n\t\tuint256 _fee,\n\t\tuint256 _deadline\n\t) internal returns (bytes32) {\n\t\treturn LibEIP712.hashEIP712Message(\n\t\t\tdomainSeparator,\n\t\t\tkeccak256(\n\t\t\t\tabi.encode(\n\t\t\t\t\tCLAIM_TYPEHASH,\n\t\t\t\t\t_claimData.to,\n\t\t\t\t\t_claimData.amount,\n\t\t\t\t\t_claimData.transactionHash,\n\t\t\t\t\t_claimData.originChainId,\n\t\t\t\t\t_relayer,\n\t\t\t\t\t_fee,\n\t\t\t\t\tnonces[_claimData.to]++,\n\t\t\t\t\t_deadline\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\t}\n\n\t// Inspired by https://github.com/dapphub/ds-dach/blob/master/src/dach.sol\n\tfunction claimGasless(\n\t\tClaimData calldata _claimData,\n\t\taddress payable _relayer,\n\t\tuint256 _fee,\n\t\tuint256 _deadline,\n\t\tuint8 _v,\n\t\tbytes32 _r,\n\t\tbytes32 _s\n\t) external override returns (uint256 receivedAmount) {\n\t\trequire(_deadline >= block.timestamp, \"Bridge: EXPIRED\"); // solhint-disable-line not-rely-on-time\n\n\t\tbytes32 digest = getDigest(_claimData, _relayer, _fee, _deadline);\n\t\taddress recoveredAddress = ecrecover(digest, _v, _r, _s);\n\t\trequire(_claimData.to != address(0) && recoveredAddress == _claimData.to, \"Bridge: INVALID_SIGNATURE\");\n\n\t\treturn _claim(\n\t\t\t_claimData,\n\t\t\t_claimData.to,\n\t\t\t_relayer,\n\t\t\t_fee\n\t\t);\n\t}\n\n\tfunction isClaimed(bytes32 transactionDataHash, bytes32 transactionDataHashMultichain) public view returns(bool) {\n\t\treturn claimed[transactionDataHash] || claimed[transactionDataHashMultichain];\n\t}\n\n\tfunction isClaimed(ClaimData calldata _claimData, bytes32 transactionDataHashMultichain) public view returns(bool) {\n\t\tbytes32 transactionDataHash = getTransactionDataHash(\n\t\t\t_claimData.to,\n\t\t\t_claimData.amount,\n\t\t\t_claimData.blockHash,\n\t\t\t_claimData.transactionHash,\n\t\t\t_claimData.logIndex\n\t\t);\n\n\t\treturn claimed[transactionDataHash] || claimed[transactionDataHashMultichain];\n\t}\n\n\tfunction _claim(\n\t\tClaimData calldata _claimData,\n\t\taddress payable _reciever,\n\t\taddress payable _relayer,\n\t\tuint256 _fee\n\t) internal nonReentrant returns (uint256 receivedAmount) {\n\t\taddress originalTokenAddress = originalTokenAddresses[_claimData.transactionHash];\n\t\trequire(originalTokenAddress != NULL_ADDRESS, \"Bridge: Tx not crossed\");\n\n\t\tbytes32 transactionDataHash = getTransactionDataHash(\n\t\t\t_claimData.to,\n\t\t\t_claimData.amount,\n\t\t\t_claimData.blockHash,\n\t\t\t_claimData.transactionHash,\n\t\t\t_claimData.logIndex,\n\t\t\t_claimData.originChainId,\n\t\t\tblock.chainid\n\t\t);\n\n\t\trequire(transactionsDataHashes[_claimData.transactionHash] == transactionDataHash, \"Bridge: Wrong transactionDataHash\");\n\t\trequire(!isClaimed(_claimData, transactionDataHash), \"Bridge: Already claimed\");\n\t\tclaimed[transactionDataHash] = true;\n\n\t\treceivedAmount = _claimCross(\n\t\t\t_claimData.originChainId,\n\t\t\toriginalTokenAddress,\n\t\t\t_reciever,\n\t\t\t_claimData.amount,\n\t\t\t_relayer,\n\t\t\t_fee\n\t\t);\n\n\t\temitClaimed(_claimData, originalTokenAddress, _reciever, _relayer, _fee);\n\t\treturn receivedAmount;\n\t}\n\n\tfunction emitClaimed(\n\t\tClaimData calldata _claimData,\n\t\taddress _originalTokenAddress,\n\t\taddress payable _reciever,\n\t\taddress payable _relayer,\n\t\tuint256 _fee\n\t) internal {\n\t\temit Claimed(\n\t\t\t_claimData.transactionHash,\n\t\t\t_originalTokenAddress,\n\t\t\t_claimData.to,\n\t\t\tsenderAddresses[_claimData.transactionHash],\n\t\t\t_claimData.amount,\n\t\t\t_claimData.blockHash,\n\t\t\t_claimData.logIndex,\n\t\t\t_reciever,\n\t\t\t_relayer,\n\t\t\t_fee,\n\t\t\t_claimData.originChainId,\n\t\t\tblock.chainid\n\t\t);\n\t}\n\n\tfunction _claimCross(\n\t\tuint256 _originalChainId,\n\t\taddress _originalTokenAddress,\n\t\taddress payable _reciever,\n\t\tuint256 _amount,\n\t\taddress payable _relayer,\n\t\tuint256 _fee\n\t) internal returns (uint256) {\n\t\tcheckChainId(_originalChainId);\n\t\tif (knownToken(_originalChainId, _originalTokenAddress)) {\n\t\t\treturn _claimCrossBackToToken(\n\t\t\t\t_originalTokenAddress,\n\t\t\t\t_reciever,\n\t\t\t\t_amount,\n\t\t\t\t_relayer,\n\t\t\t\t_fee\n\t\t\t);\n\t\t}\n\n\t\treturn _claimCrossToSideToken(\n\t\t\tsideTokenByOriginalToken(_originalChainId, _originalTokenAddress),\n\t\t\t_reciever,\n\t\t\t_amount,\n\t\t\t_relayer,\n\t\t\t_fee\n\t\t);\n\t}\n\n\tfunction _claimCrossToSideToken(\n\t\taddress _sideToken,\n\t\taddress payable _receiver,\n\t\tuint256 _amount,\n\t\taddress payable _relayer,\n\t\tuint256 _fee\n\t) internal returns (uint256 receivedAmount) {\n\t\trequire(_sideToken != NULL_ADDRESS, \"Bridge: side token is null\");\n\t\tuint256 granularity = IERC777(_sideToken).granularity();\n\t\tuint256 formattedAmount = _amount.mul(granularity);\n\t\trequire(_fee <= formattedAmount, \"Bridge: fee too high\");\n\t\treceivedAmount = formattedAmount.sub(_fee);\n\t\tISideToken(_sideToken).mint(_receiver, receivedAmount, \"\", \"\");\n\t\tif (_fee > 0) {\n\t\t\tISideToken(_sideToken).mint(_relayer, _fee, \"\", \"relayer fee\");\n\t\t}\n\t\treturn receivedAmount;\n\t}\n\n\tfunction _claimCrossBackToToken(\n\t\taddress _originalTokenAddress,\n\t\taddress payable _receiver,\n\t\tuint256 _amount,\n\t\taddress payable _relayer,\n\t\tuint256 _fee\n\t) internal returns (uint256 receivedAmount) {\n\t\tuint256 decimals = LibUtils.getDecimals(_originalTokenAddress);\n\t\t//As side tokens are ERC777 they will always have 18 decimals\n\t\tuint256 formattedAmount = _amount.div(uint256(10) ** (18 - decimals));\n\t\trequire(_fee <= formattedAmount, \"Bridge: fee too high\");\n\t\treceivedAmount = formattedAmount.sub(_fee);\n\t\tif (address(wrappedCurrency) == _originalTokenAddress) {\n\t\t\twrappedCurrency.withdraw(formattedAmount);\n\t\t\t_receiver.transfer(receivedAmount);\n\t\t\tif(_fee > 0) {\n\t\t\t\t_relayer.transfer(_fee);\n\t\t\t}\n\t\t} else {\n\t\t\tIERC20(_originalTokenAddress).safeTransfer(_receiver, receivedAmount);\n\t\t\tif(_fee > 0) {\n\t\t\t\tIERC20(_originalTokenAddress).safeTransfer(_relayer, _fee);\n\t\t\t}\n\t\t}\n\t\treturn receivedAmount;\n\t}\n\n\t/**\n\t\t* ERC-20 tokens approve and transferFrom pattern\n\t\t* See https://eips.ethereum.org/EIPS/eip-20#transferfrom\n\t\t*/\n\tfunction receiveTokensTo(uint256 destinationChainId, address tokenToUse, address to, uint256 amount) external override {\n\t\taddress sender = _msgSender();\n\t\t//Transfer the tokens on IERC20, they should be already Approved for the bridge Address to use them\n\t\tIERC20(tokenToUse).safeTransferFrom(sender, address(this), amount);\n\t\tcrossTokens(tokenToUse, sender, to, amount, \"\", destinationChainId);\n\t}\n\n\t/**\n\t\t* Use network currency and cross it.\n\t\t*/\n\tfunction depositTo(uint256 chainId, address to) external payable override {\n\t\taddress sender = _msgSender();\n\t\trequire(address(wrappedCurrency) != NULL_ADDRESS, \"Bridge: wrappedCurrency empty\");\n\t\twrappedCurrency.deposit{ value: msg.value }();\n\t\tcrossTokens(address(wrappedCurrency), sender, to, msg.value, \"\", chainId);\n\t}\n\n\t/**\n\t\t* ERC-777 tokensReceived hook allows to send tokens to a contract and notify it in a single transaction\n\t\t* See https://eips.ethereum.org/EIPS/eip-777#motivation for details\n\t\t* @param userData it can be 2 options in the first one you can send the receiver and the chain id of the destination\n\t\t* const userData = web3.eth.abi.encodeParameters(\n    *   [\"address\", \"uint256\"],\n    *   [anAccount.toLowerCase(), chains.ETHEREUM_MAIN_NET_CHAIN_ID]\n    * );\n\t\t* or you also can send only the destination chain id, and the receiver would be the same as the from parameter\n\t\t* const userData = web3.eth.abi.encodeParameters([\"uint256\"], [chains.ETHEREUM_MAIN_NET_CHAIN_ID]);\n\t\t*/\n\tfunction tokensReceived(\n\t\taddress operator,\n\t\taddress from,\n\t\taddress to,\n\t\tuint amount,\n\t\tbytes calldata userData, // [address,uint256] user addrest receiver, destinationChainId || [uint256] same as from, destinationChainId\n\t\tbytes calldata\n\t) external override(IBridge, IERC777Recipient) {\n\t\t//Hook from ERC777address\n\t\tif(operator == address(this)) return; // Avoid loop from bridge calling to ERC77transferFrom\n\t\trequire(to == address(this), \"Bridge: Not to this address\");\n\t\taddress tokenToUse = _msgSender();\n\t\trequire(ERC1820.getInterfaceImplementer(tokenToUse, _erc777Interface) != NULL_ADDRESS, \"Bridge: Not ERC777 token\");\n\t\trequire(userData.length >= 32, \"Bridge: user data with at least the destinationChainId\");\n\t\trequire(userData.length == 64 || !from.isContract(), \"Bridge: Specify receiver address in data\");\n\t\taddress receiver = userData.length == 32 ? from : LibUtils.toAddress(userData, 12);\n\t\tuint256 destinationChainId = LibUtils.toUint256(userData, userData.length - 32);\n\t\tcrossTokens(tokenToUse, from, receiver, amount, userData, destinationChainId);\n\t}\n\n\tfunction crossTokens(\n\t\taddress tokenToUse,\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 amount,\n\t\tbytes memory userData,\n\t\tuint256 destinationChainId\n\t) internal whenNotUpgrading whenNotPaused nonReentrant {\n\t\trequire(block.chainid != destinationChainId, \"Bridge: destination chain id equal current chain id\");\n\t\tcheckChainId(destinationChainId);\n\t\t_setKnownTokenByChain(destinationChainId, tokenToUse, true);\n\t\tuint256 fee = amount.mul(feePercentage).div(feePercentageDivider);\n\t\tuint256 amountMinusFees = amount.sub(fee);\n\t\tuint8 decimals = LibUtils.getDecimals(tokenToUse);\n\t\tuint formattedAmount = amount;\n\t\tif (decimals != 18) {\n\t\t\tformattedAmount = amount.mul(uint256(10)**(18-decimals));\n\t\t}\n\t\t// We consider the amount before fees converted to 18 decimals to check the limits\n\t\t// updateTokenTransfer revert if token not allowed\n\t\tallowTokens.updateTokenTransfer(tokenToUse, formattedAmount);\n\n\t\tOriginalToken memory sideToken = getOriginalTokenBySideToken(tokenToUse);\n\t\tif (sideToken.tokenAddress != NULL_ADDRESS) {\n\t\t\t// Side Token Crossing back\n\t\t\t{ // Created scope to avoid stack too deep\n\t\t\t\tuint256 granularity = LibUtils.getGranularity(tokenToUse);\n\t\t\t\tuint256 modulo = amountMinusFees.mod(granularity);\n\t\t\t\tfee = fee.add(modulo);\n\t\t\t\tamountMinusFees = amountMinusFees.sub(modulo);\n\t\t\t\tIERC777(tokenToUse).burn(amountMinusFees, userData);\n\t\t\t}\n\t\t\temit Cross(\n\t\t\t\tsideToken.tokenAddress,\n\t\t\t\tto,\n\t\t\t\tdestinationChainId,\n\t\t\t\tfrom,\n\t\t\t\tblock.chainid,\n\t\t\t\tamountMinusFees,\n\t\t\t\tuserData\n\t\t\t);\n\t\t} else {\n\t\t\temit Cross(\n\t\t\t\ttokenToUse,\n\t\t\t\tto,\n\t\t\t\tdestinationChainId,\n\t\t\t\tfrom,\n\t\t\t\tblock.chainid,\n\t\t\t\tamountMinusFees,\n\t\t\t\tuserData\n\t\t\t);\n\t\t}\n\n\t\tif (fee > 0) {\n\t\t\t//Send the payment to the MultiSig of the Federation\n\t\t\tIERC20(tokenToUse).safeTransfer(owner(), fee);\n\t\t}\n\t}\n\n\t// function for retrocompatibility\n\tfunction getTransactionDataHash(\n\t\taddress _to,\n\t\tuint256 _amount,\n\t\tbytes32 _blockHash,\n\t\tbytes32 _transactionHash,\n\t\tuint32 _logIndex\n\t) internal pure returns(bytes32) {\n\t\treturn keccak256(abi.encodePacked(_blockHash, _transactionHash, _to, _amount, _logIndex));\n\t}\n\n\tfunction getTransactionDataHash(\n\t\taddress _to,\n\t\tuint256 _amount,\n\t\tbytes32 _blockHash,\n\t\tbytes32 _transactionHash,\n\t\tuint32 _logIndex,\n\t\tuint256 _originChainId,\n\t\tuint256\t_destinationChainId\n\t) public pure override returns(bytes32) {\n\t\treturn keccak256(abi.encodePacked(_blockHash, _transactionHash, _to, _amount, _logIndex, _originChainId, _destinationChainId));\n\t}\n\n\tfunction setFeePercentage(uint amount) external onlyOwner {\n\t\trequire(amount < (feePercentageDivider/10), \"Bridge: bigger than 10%\");\n\t\tfeePercentage = amount;\n\t\temit FeePercentageChanged(feePercentage);\n\t}\n\n\tfunction getFeePercentage() external view override returns(uint) {\n\t\treturn feePercentage;\n\t}\n\n\tfunction changeFederation(address newFederation) external onlyOwner {\n\t\trequire(newFederation != NULL_ADDRESS, \"Bridge: Federation is empty\");\n\t\tfederation = newFederation;\n\t\temit FederationChanged(federation);\n\t}\n\n\tfunction changeAllowTokens(address newAllowTokens) external onlyOwner {\n\t\trequire(newAllowTokens != NULL_ADDRESS, \"Bridge: AllowTokens is empty\");\n\t\tallowTokens = IAllowTokens(newAllowTokens);\n\t\temit AllowTokensChanged(newAllowTokens);\n\t}\n\n\tfunction getFederation() external view returns(address) {\n\t\treturn federation;\n\t}\n\n\tfunction changeSideTokenFactory(address newSideTokenFactory) external onlyOwner {\n\t\trequire(newSideTokenFactory != NULL_ADDRESS, \"Bridge: SideTokenFactory is empty\");\n\t\tsideTokenFactory = ISideTokenFactory(newSideTokenFactory);\n\t\temit SideTokenFactoryChanged(newSideTokenFactory);\n\t}\n\n\tfunction setUpgrading(bool _isUpgrading) external onlyOwner {\n\t\tisUpgrading = _isUpgrading;\n\t\temit Upgrading(isUpgrading);\n\t}\n\n\tfunction setWrappedCurrency(address _wrappedCurrency) external onlyOwner {\n\t\trequire(_wrappedCurrency != NULL_ADDRESS, \"Bridge: wrapp is empty\");\n\t\twrappedCurrency = IWrapped(_wrappedCurrency);\n\t\temit WrappedCurrencyChanged(_wrappedCurrency);\n\t}\n\n\tfunction hasCrossed(bytes32 transactionHash) public view returns (bool) {\n\t\treturn transactionsDataHashes[transactionHash] != bytes32(0);\n\t}\n\n\tfunction hasBeenClaimed(bytes32 transactionHash) public view returns (bool) {\n\t\treturn claimed[transactionsDataHashes[transactionHash]];\n\t}\n\n}\n"
    },
    "contracts/zeppelin/upgradable/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma abicoder v2;\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || !initialized, \"Contract instance is already initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}"
    },
    "contracts/zeppelin/upgradable/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma abicoder v2;\n\nimport \"../Initializable.sol\";\n\n/**\n * @title Helps contracts guard against reentrancy attacks.\n * @author Remco Bloemen <remco@2π.com>, Eenae <alexey@mixbytes.io>\n * @dev If you mark a function `nonReentrant`, you should also\n * mark it `external`.\n */\ncontract ReentrancyGuard is Initializable {\n    /// @dev counter to allow mutex lock with only one SSTORE operation\n    uint256 private _guardCounter;\n\n    function initialize() public initializer {\n        // The counter starts at one to prevent changing it from zero to a non-zero\n        // value, which is a more expensive operation.\n        _guardCounter = 1;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _guardCounter += 1;\n        uint256 localCounter = _guardCounter;\n        _;\n        require(localCounter == _guardCounter, \"ReentrancyGuard: no reentrant allowed\");\n    }\n}"
    },
    "contracts/zeppelin/upgradable/lifecycle/UpgradablePausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma abicoder v2;\n\nimport \"../Initializable.sol\";\n\nimport \"../../GSN/Context.sol\";\nimport \"../access/roles/UpgradablePauserRole.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\ncontract UpgradablePausable is Initializable, Context, UpgradablePauserRole {\n    /**\n     * @dev Emitted when the pause is triggered by a pauser (`account`).\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by a pauser (`account`).\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state. Assigns the Pauser role\n     * to the deployer.\n     */\n    function __Pausable_init(address sender) public initializer {\n        UpgradablePauserRole.__PauserRol_init(sender);\n\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     */\n    modifier whenNotPaused() {\n        require(!_paused, \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     */\n    modifier whenPaused() {\n        require(_paused, \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Called by a pauser to pause, triggers stopped state.\n     */\n    function pause() public onlyPauser whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Called by a pauser to unpause, returns to normal state.\n     */\n    function unpause() public onlyPauser whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "contracts/zeppelin/upgradable/ownership/UpgradableOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma abicoder v2;\n\nimport \"../Initializable.sol\";\n\nimport \"../../GSN/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\n * the owner.\n */\ncontract UpgradableOwnable is Initializable, Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function initialize(address sender) public initializer {\n        _owner = sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * > Note: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n\n}\n"
    },
    "contracts/zeppelin/introspection/IERC1820Registry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma abicoder v2;\n\n/**\n * @dev Interface of the global ERC1820 Registry, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1820[EIP]. Accounts may register\n * implementers for interfaces in this registry, as well as query support.\n *\n * Implementers may be shared by multiple accounts, and can also implement more\n * than a single interface for each account. Contracts can implement interfaces\n * for themselves, but externally-owned accounts (EOA) must delegate this to a\n * contract.\n *\n * {IERC165} interfaces can also be queried via the registry.\n *\n * For an in-depth explanation and source code analysis, see the EIP text.\n */\ninterface IERC1820Registry {\n    /**\n     * @dev Sets `newManager` as the manager for `account`. A manager of an\n     * account is able to set interface implementers for it.\n     *\n     * By default, each account is its own manager. Passing a value of `0x0` in\n     * `newManager` will reset the manager to this initial state.\n     *\n     * Emits a {ManagerChanged} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the current manager for `account`.\n     */\n    function setManager(address account, address newManager) external;\n\n    /**\n     * @dev Returns the manager for `account`.\n     *\n     * See {setManager}.\n     */\n    function getManager(address account) external view returns (address);\n\n    /**\n     * @dev Sets the `implementer` contract as `account`'s implementer for\n     * `interfaceHash`.\n     *\n     * `account` being the zero address is an alias for the caller's address.\n     * The zero address can also be used in `implementer` to remove an old one.\n     *\n     * See {interfaceHash} to learn how these are created.\n     *\n     * Emits an {InterfaceImplementerSet} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the current manager for `_account`.\n     * - `_interfaceHash` must not be an {IERC165} interface id (i.e. it must not\n     * end in 28 zeroes).\n     * - `_implementer` must implement {IERC1820Implementer} and return true when\n     * queried for support, unless `implementer` is the caller. See\n     * {IERC1820Implementer-canImplementInterfaceForAddress}.\n     */\n    function setInterfaceImplementer(address _account, bytes32 _interfaceHash, address _implementer) external;\n\n    /**\n     * @dev Returns the implementer of `_interfaceHash` for `_account`. If no such\n     * implementer is registered, returns the zero address.\n     *\n     * If `_interfaceHash` is an {IERC165} interface id (i.e. it ends with 28\n     * zeroes), `_account` will be queried for support of it.\n     *\n     * `account` being the zero address is an alias for the caller's address.\n     */\n    function getInterfaceImplementer(address _account, bytes32 _interfaceHash) external view returns (address);\n\n    /**\n     * @dev Returns the interface hash for an `interfaceName`, as defined in the\n     * corresponding\n     * https://eips.ethereum.org/EIPS/eip-1820#interface-name[section of the EIP].\n     */\n    function interfaceHash(string calldata interfaceName) external pure returns (bytes32);\n\n    /**\n     *  @notice Updates the cache with whether the contract implements an ERC165 interface or not.\n     *  @param account Address of the contract for which to update the cache.\n     *  @param interfaceId ERC165 interface for which to update the cache.\n     */\n    function updateERC165Cache(address account, bytes4 interfaceId) external;\n\n    /**\n     *  @notice Checks whether a contract implements an ERC165 interface or not.\n     *  If the result is not cached a direct lookup on the contract address is performed.\n     *  If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling\n     *  {updateERC165Cache} with the contract address.\n     *  @param account Address of the contract to check.\n     *  @param interfaceId ERC165 interface to check.\n     *  @return True if `account` implements `interfaceId`, false otherwise.\n     */\n    function implementsERC165Interface(address account, bytes4 interfaceId) external view returns (bool);\n\n    /**\n     *  @notice Checks whether a contract implements an ERC165 interface or not without using nor updating the cache.\n     *  @param account Address of the contract to check.\n     *  @param interfaceId ERC165 interface to check.\n     *  @return True if `account` implements `interfaceId`, false otherwise.\n     */\n    function implementsERC165InterfaceNoCache(address account, bytes4 interfaceId) external view returns (bool);\n\n    event InterfaceImplementerSet(address indexed account, bytes32 indexed interfaceHash, address indexed implementer);\n\n    event ManagerChanged(address indexed account, address indexed newManager);\n}\n"
    },
    "contracts/zeppelin/token/ERC777/IERC777Recipient.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma abicoder v2;\n\n/**\n * @dev Interface of the ERC777TokensRecipient standard as defined in the EIP.\n *\n * Accounts can be notified of `IERC777` tokens being sent to them by having a\n * contract implement this interface (contract holders can be their own\n * implementer) and registering it on the\n * [ERC1820 global registry](https://eips.ethereum.org/EIPS/eip-1820).\n *\n * See `IERC1820Registry` and `ERC1820Implementer`.\n */\ninterface IERC777Recipient {\n    /**\n     * @dev Called by an `IERC777` token contract whenever tokens are being\n     * moved or created into a registered account (`to`). The type of operation\n     * is conveyed by `from` being the zero address or not.\n     *\n     * This call occurs _after_ the token contract's state is updated, so\n     * `IERC777.balanceOf`, etc., can be used to query the post-operation state.\n     *\n     * This function may revert to prevent the operation from being executed.\n     */\n    function tokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint amount,\n        bytes calldata userData,\n        bytes calldata operatorData\n    ) external;\n}\n"
    },
    "contracts/zeppelin/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma abicoder v2;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/zeppelin/token/ERC20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma abicoder v2;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve non-zero to non-zero allowance\"\n        );\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves.\n\n        // A Solidity high level call has three parts:\n        //  1. The target address is checked to verify it contains contract code\n        //  2. The call itself is made, and success asserted\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\n        // solhint-disable-next-line max-line-length\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/zeppelin/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma abicoder v2;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/zeppelin/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma abicoder v2;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/zeppelin/token/ERC777/IERC777.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma abicoder v2;\n\n/**\n * @dev Interface of the ERC777Token standard as defined in the EIP.\n *\n * This contract uses the\n * [ERC1820 registry standard](https://eips.ethereum.org/EIPS/eip-1820) to let\n * token holders and recipients react to token movements by using setting implementers\n * for the associated interfaces in said registry. See `IERC1820Registry` and\n * `ERC1820Implementer`.\n */\ninterface IERC777 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the smallest part of the token that is not divisible. This\n     * means all token operations (creation, movement and destruction) must have\n     * amounts that are a multiple of this number.\n     *\n     * For most token contracts, this value will equal 1.\n     */\n    function granularity() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by an account (`owner`).\n     */\n    function balanceOf(address owner) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * If send or receive hooks are registered for the caller and `recipient`,\n     * the corresponding functions will be called with `data` and empty\n     * `operatorData`. See `IERC777Sender` and `IERC777Recipient`.\n     *\n     * Emits a `Sent` event.\n     *\n     * Requirements\n     *\n     * - the caller must have at least `amount` tokens.\n     * - `recipient` cannot be the zero address.\n     * - if `recipient` is a contract, it must implement the `tokensReceived`\n     * interface.\n     */\n    function send(address recipient, uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev Destroys `amount` tokens from the caller's account, reducing the\n     * total supply.\n     *\n     * If a send hook is registered for the caller, the corresponding function\n     * will be called with `data` and empty `operatorData`. See `IERC777Sender`.\n     *\n     * Emits a `Burned` event.\n     *\n     * Requirements\n     *\n     * - the caller must have at least `amount` tokens.\n     */\n    function burn(uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev Returns true if an account is an operator of `tokenHolder`.\n     * Operators can send and burn tokens on behalf of their owners. All\n     * accounts are their own operator.\n     *\n     * See `operatorSend` and `operatorBurn`.\n     */\n    function isOperatorFor(address operator, address tokenHolder) external view returns (bool);\n\n    /**\n     * @dev Make an account an operator of the caller.\n     *\n     * See `isOperatorFor`.\n     *\n     * Emits an `AuthorizedOperator` event.\n     *\n     * Requirements\n     *\n     * - `operator` cannot be calling address.\n     */\n    function authorizeOperator(address operator) external;\n\n    /**\n     * @dev Make an account an operator of the caller.\n     *\n     * See `isOperatorFor` and `defaultOperators`.\n     *\n     * Emits a `RevokedOperator` event.\n     *\n     * Requirements\n     *\n     * - `operator` cannot be calling address.\n     */\n    function revokeOperator(address operator) external;\n\n    /**\n     * @dev Returns the list of default operators. These accounts are operators\n     * for all token holders, even if `authorizeOperator` was never called on\n     * them.\n     *\n     * This list is immutable, but individual holders may revoke these via\n     * `revokeOperator`, in which case `isOperatorFor` will return false.\n     */\n    function defaultOperators() external view returns (address[] memory);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient`. The caller must\n     * be an operator of `sender`.\n     *\n     * If send or receive hooks are registered for `sender` and `recipient`,\n     * the corresponding functions will be called with `data` and\n     * `operatorData`. See `IERC777Sender` and `IERC777Recipient`.\n     *\n     * Emits a `Sent` event.\n     *\n     * Requirements\n     *\n     * - `sender` cannot be the zero address.\n     * - `sender` must have at least `amount` tokens.\n     * - the caller must be an operator for `sender`.\n     * - `recipient` cannot be the zero address.\n     * - if `recipient` is a contract, it must implement the `tokensReceived`\n     * interface.\n     */\n    function operatorSend(\n        address sender,\n        address recipient,\n        uint256 amount,\n        bytes calldata data,\n        bytes calldata operatorData\n    ) external;\n\n    /**\n     * @dev Destoys `amount` tokens from `account`, reducing the total supply.\n     * The caller must be an operator of `account`.\n     *\n     * If a send hook is registered for `account`, the corresponding function\n     * will be called with `data` and `operatorData`. See `IERC777Sender`.\n     *\n     * Emits a `Burned` event.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     * - the caller must be an operator for `account`.\n     */\n    function operatorBurn(\n        address account,\n        uint256 amount,\n        bytes calldata data,\n        bytes calldata operatorData\n    ) external;\n\n    event Sent(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        bytes data,\n        bytes operatorData\n    );\n\n    function decimals() external returns (uint8);\n\n    event Minted(address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData);\n\n    event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);\n\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\n\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\n}\n"
    },
    "contracts/lib/LibEIP712.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma abicoder v2;\n\n// https://github.com/0xProject/0x-monorepo/blob/development/contracts/utils/contracts/src/LibEIP712.sol\nlibrary LibEIP712 {\n\n    // Hash of the EIP712 Domain Separator Schema\n    // keccak256(abi.encodePacked(\n    //     \"EIP712Domain(\",\n    //     \"string name,\",\n    //     \"string version,\",\n    //     \"uint256 chainId,\",\n    //     \"address verifyingContract\",\n    //     \")\"\n    // ))\n    bytes32 constant internal _EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\n\n    /// @dev Calculates a EIP712 domain separator.\n    /// @param name The EIP712 domain name.\n    /// @param version The EIP712 domain version.\n    /// @param verifyingContract The EIP712 verifying contract.\n    /// @return result EIP712 domain separator.\n    function hashEIP712Domain(\n        string memory name,\n        string memory version,\n        uint256 chainId,\n        address verifyingContract\n    )\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        bytes32 schemaHash = _EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH;\n\n        // Assembly for more efficient computing:\n        // keccak256(abi.encodePacked(\n        //     _EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH,\n        //     keccak256(bytes(name)),\n        //     keccak256(bytes(version)),\n        //     chainId,\n        //     uint256(verifyingContract)\n        // ))\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            // Calculate hashes of dynamic data\n            let nameHash := keccak256(add(name, 32), mload(name))\n            let versionHash := keccak256(add(version, 32), mload(version))\n\n            // Load free memory pointer\n            let memPtr := mload(64)\n\n            // Store params in memory\n            mstore(memPtr, schemaHash)\n            mstore(add(memPtr, 32), nameHash)\n            mstore(add(memPtr, 64), versionHash)\n            mstore(add(memPtr, 96), chainId)\n            mstore(add(memPtr, 128), verifyingContract)\n\n            // Compute hash\n            result := keccak256(memPtr, 160)\n        }\n        return result;\n    }\n\n    /// @dev Calculates EIP712 encoding for a hash struct with a given domain hash.\n    /// @param eip712DomainHash Hash of the domain domain separator data, computed\n    ///                         with getDomainHash().\n    /// @param hashStruct The EIP712 hash struct.\n    /// @return result EIP712 hash applied to the given EIP712 Domain.\n    function hashEIP712Message(bytes32 eip712DomainHash, bytes32 hashStruct)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        // Assembly for more efficient computing:\n        // keccak256(abi.encodePacked(\n        //     EIP191_HEADER,\n        //     EIP712_DOMAIN_HASH,\n        //     hashStruct\n        // ));\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            // Load free memory pointer\n            let memPtr := mload(64)\n\n            mstore(memPtr, 0x1901000000000000000000000000000000000000000000000000000000000000)  // EIP191 header\n            mstore(add(memPtr, 2), eip712DomainHash)                                            // EIP712 domain hash\n            mstore(add(memPtr, 34), hashStruct)                                                 // Hash of struct\n\n            // Compute hash\n            result := keccak256(memPtr, 66)\n        }\n        return result;\n    }\n}"
    },
    "contracts/lib/LibUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma abicoder v2;\n\nlibrary LibUtils {\n\n    function decimalsToGranularity(uint8 decimals) internal pure returns (uint256) {\n        require(decimals <= 18, \"LibUtils: Decimals not <= 18\");\n        return uint256(10)**(18-decimals);\n    }\n\n    function getDecimals(address tokenToUse) internal view returns (uint8) {\n        //support decimals as uint256 or uint8\n        (bool success, bytes memory data) = tokenToUse.staticcall(abi.encodeWithSignature(\"decimals()\"));\n        require(success, \"LibUtils: No decimals\");\n        // uint<M>: enc(X) is the big-endian encoding of X,\n        //padded on the higher-order (left) side with zero-bytes such that the length is 32 bytes.\n        return uint8(abi.decode(data, (uint256)));\n    }\n\n    function getGranularity(address tokenToUse) internal view returns (uint256) {\n        //support granularity if ERC777\n        (bool success, bytes memory data) = tokenToUse.staticcall(abi.encodeWithSignature(\"granularity()\"));\n        require(success, \"LibUtils: No granularity\");\n\n        return abi.decode(data, (uint256));\n    }\n\n    function bytesToAddress(bytes memory bys) internal pure returns (address addr) {\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            addr := mload(add(bys,20))\n        }\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_bytes.length >= _start + 20, \"LibUtils: toAddress_outOfBounds\");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\n        require(_bytes.length >= _start + 16, \"LibUtils: toUint128_outOfBounds\");\n        uint128 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x10), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\n\t\trequire(_bytes.length >= _start + 32, \"LibUtils: toUint256_outOfBounds\");\n\t\tuint256 tempUint;\n\n        // solium-disable-next-line security/no-inline-assembly\n\t\tassembly {\n\t\t\ttempUint := mload(add(add(_bytes, 0x20), _start))\n\t\t}\n\n\t\treturn tempUint;\n\t}\n}\n"
    },
    "contracts/interface/IBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma abicoder v2;\ninterface IBridge {\n\n\tstruct ClaimData {\n\t\taddress payable to;\n\t\tuint256 amount;\n\t\tbytes32 blockHash;\n\t\tbytes32 transactionHash;\n\t\tuint32 logIndex;\n\t\tuint256 originChainId;\n\t}\n\n\tstruct OriginalToken {\n\t\taddress tokenAddress;\n\t\tuint256 originChainId;\n\t}\n\t\n\tstruct CreateSideTokenStruct {\n\t\tuint256 _typeId;\n\t\taddress _originalTokenAddress;\n\t\tuint8 _originalTokenDecimals;\n\t\tstring _originalTokenSymbol;\n\t\tstring _originalTokenName;\n\t\tuint256 _originChainId;\n\t}\n\n\tfunction version() external pure returns (string memory);\n\n\tfunction getFeePercentage() external view returns(uint);\n\n\t/**\n\t\t* ERC-20 tokens approve and transferFrom pattern\n\t\t* See https://eips.ethereum.org/EIPS/eip-20#transferfrom\n\t\t*/\n\tfunction receiveTokensTo(uint256 chainId, address tokenToUse, address to, uint256 amount) external;\n\n\t/**\n\t\t* Use network currency and cross it.\n\t\t*/\n\tfunction depositTo(uint256 chainId, address to) external payable;\n\n\t/**\n\t\t* ERC-777 tokensReceived hook allows to send tokens to a contract and notify it in a single transaction\n\t\t* See https://eips.ethereum.org/EIPS/eip-777#motivation for details\n\t\t* @param userData it can be 2 options in the first one you can send the receiver and the chain id of the destination\n\t\t* const userData = web3.eth.abi.encodeParameters(\n    *   [\"address\", \"uint256\"],\n    *   [anAccount.toLowerCase(), chains.ETHEREUM_MAIN_NET_CHAIN_ID]\n    * );\n\t\t* or you also can send only the destination chain id, and the receiver would be the same as the from parameter\n\t\t* const userData = web3.eth.abi.encodeParameters([\"uint256\"], [chains.ETHEREUM_MAIN_NET_CHAIN_ID]);\n\t\t*/\n\tfunction tokensReceived (\n\t\taddress operator,\n\t\taddress from,\n\t\taddress to,\n\t\tuint amount,\n\t\tbytes calldata userData,\n\t\tbytes calldata operatorData\n\t) external;\n\n\t/**\n\t\t* Accepts the transaction from the other chain that was voted and sent by the Federation contract\n\t\t*/\n\tfunction acceptTransfer(\n\t\taddress _originalTokenAddress,\n\t\taddress payable _from,\n\t\taddress payable _to,\n\t\tuint256 _amount,\n\t\tbytes32 _blockHash,\n\t\tbytes32 _transactionHash,\n\t\tuint32 _logIndex,\n\t\tuint256 _originChainId,\n\t\tuint256\t_destinationChainId\n\t) external;\n\n\t/**\n\t\t* Claims the crossed transaction using the hash, this sends the funds to the address indicated in\n\t\t*/\n\tfunction claim(ClaimData calldata _claimData) external returns (uint256 receivedAmount);\n\n\tfunction claimFallback(ClaimData calldata _claimData) external returns (uint256 receivedAmount);\n\n\tfunction claimGasless(\n\t\tClaimData calldata _claimData,\n\t\taddress payable _relayer,\n\t\tuint256 _fee,\n\t\tuint256 _deadline,\n\t\tuint8 _v,\n\t\tbytes32 _r,\n\t\tbytes32 _s\n\t) external returns (uint256 receivedAmount);\n\n\tfunction createSideToken(\n\t\tuint256 _typeId,\n\t\taddress _originalTokenAddress,\n\t\tuint8 _originalTokenDecimals,\n\t\tstring calldata _originalTokenSymbol,\n\t\tstring calldata _originalTokenName,\n\t\tuint256 _chainId\n\t) external;\n\n\tfunction createMultipleSideTokens(\n\t\tCreateSideTokenStruct[] calldata createSideTokenStruct\n\t) external;\n\n\tfunction getTransactionDataHash(\n\t\taddress _to,\n\t\tuint256 _amount,\n\t\tbytes32 _blockHash,\n\t\tbytes32 _transactionHash,\n\t\tuint32 _logIndex,\n\t\tuint256 _originChainId,\n\t\tuint256 _destinationChainId\n\t) external returns(bytes32);\n\n\tevent Cross(\n\t\taddress indexed _tokenAddress,\n\t\taddress indexed _to,\n\t\tuint256 indexed _destinationChainId,\n\t\taddress _from,\n\t\tuint256 _originChainId,\n\t\tuint256 _amount,\n\t\tbytes _userData\n\t);\n\n\tevent NewSideToken(\n\t\taddress indexed _newSideTokenAddress,\n\t\taddress indexed _originalTokenAddress,\n\t\tstring _newSymbol,\n\t\tuint256 _granularity,\n\t\tuint256 _chainId\n\t);\n\tevent AcceptedCrossTransfer(\n\t\tbytes32 indexed _transactionHash,\n\t\taddress indexed _originalTokenAddress,\n\t\taddress indexed _to,\n\t\taddress  _from,\n\t\tuint256 _amount,\n\t\tbytes32 _blockHash,\n\t\tuint256 _logIndex,\n\t\tuint256 _originChainId,\n\t\tuint256\t_destinationChainId\n\t);\n\tevent FeePercentageChanged(uint256 _amount);\n\tevent Claimed(\n\t\tbytes32 indexed _transactionHash,\n\t\taddress indexed _originalTokenAddress,\n\t\taddress indexed _to,\n\t\taddress _sender,\n\t\tuint256 _amount,\n\t\tbytes32 _blockHash,\n\t\tuint256 _logIndex,\n\t\taddress _reciever,\n\t\taddress _relayer,\n\t\tuint256 _fee,\n\t\tuint256 _destinationChainId,\n\t\tuint256 _originChainId\n\t);\n}"
    },
    "contracts/interface/ISideToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma abicoder v2;\n\ninterface ISideToken {\n    function mint(address account, uint256 amount, bytes calldata userData, bytes calldata operatorData) external;\n}"
    },
    "contracts/interface/ISideTokenFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma abicoder v2;\n\ninterface ISideTokenFactory {\n\n    function createSideToken(string calldata name, string calldata symbol, uint256 granularity) external returns(address);\n\n    event SideTokenCreated(address indexed sideToken, string symbol, uint256 granularity);\n}"
    },
    "contracts/interface/IAllowTokens.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma abicoder v2;\ninterface IAllowTokens {\n\n\tstruct Limits {\n\t\tuint256 min;\n\t\tuint256 max;\n\t\tuint256 daily;\n\t\tuint256 mediumAmount;\n\t\tuint256 largeAmount;\n\t}\n\n\tstruct TokenInfo {\n\t\tbool allowed;\n\t\tuint256 typeId;\n\t\tuint256 spentToday;\n\t\tuint256 lastDay;\n\t}\n\n\tstruct TypeInfo {\n\t\tstring description;\n\t\tLimits limits;\n\t}\n\n\tstruct TokensAndType {\n\t\taddress token;\n\t\tuint256 typeId;\n\t}\n\n\tfunction version() external pure returns (string memory);\n\n\tfunction getInfoAndLimits(address token) external view returns (TokenInfo memory info, Limits memory limit);\n\n\tfunction calcMaxWithdraw(address token) external view returns (uint256 maxWithdraw);\n\n\tfunction getTypesLimits() external view returns(Limits[] memory limits);\n\n\tfunction getTypeDescriptionsLength() external view returns(uint256);\n\n\tfunction getTypeDescriptions() external view returns(string[] memory descriptions);\n\n\tfunction setToken(address token, uint256 typeId) external;\n\n\tfunction getConfirmations() external view returns (uint256 smallAmount, uint256 mediumAmount, uint256 largeAmount);\n\n\tfunction isTokenAllowed(address token) external view returns (bool);\n\n\tfunction updateTokenTransfer(address token, uint256 amount) external;\n}"
    },
    "contracts/interface/IWrapped.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma abicoder v2;\ninterface IWrapped {\n    function balanceOf(address) external returns(uint);\n\n    function deposit() external payable;\n\n    function withdraw(uint wad) external;\n\n    function totalSupply() external view returns (uint);\n\n    function approve(address guy, uint wad) external returns (bool);\n\n    function transfer(address dst, uint wad) external returns (bool);\n\n    function transferFrom(address src, address dst, uint wad)\n        external\n        returns (bool);\n}"
    },
    "contracts/zeppelin/GSN/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma abicoder v2;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract  Context {\n\n    function _msgSender() internal view returns (address payable) {\n        return payable(msg.sender);\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "contracts/zeppelin/upgradable/access/roles/UpgradablePauserRole.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma abicoder v2;\n\nimport \"../../Initializable.sol\";\n\nimport \"../../../GSN/Context.sol\";\nimport \"../../../access/Roles.sol\";\n\ncontract UpgradablePauserRole is Initializable, Context {\n    using Roles for Roles.Role;\n\n    event PauserAdded(address indexed account);\n    event PauserRemoved(address indexed account);\n\n    Roles.Role private _pausers;\n\n    function __PauserRol_init(address sender) public initializer {\n        if (!isPauser(sender)) {\n            _addPauser(sender);\n        }\n    }\n\n    modifier onlyPauser() {\n        require(isPauser(_msgSender()), \"PauserRole: caller doesn't have the role\");\n        _;\n    }\n\n    function isPauser(address account) public view returns (bool) {\n        return _pausers.has(account);\n    }\n\n    function addPauser(address account) public onlyPauser {\n        _addPauser(account);\n    }\n\n    function renouncePauser() public {\n        _removePauser(_msgSender());\n    }\n\n    function _addPauser(address account) internal {\n        _pausers.add(account);\n        emit PauserAdded(account);\n    }\n\n    function _removePauser(address account) internal {\n        _pausers.remove(account);\n        emit PauserRemoved(account);\n    }\n}\n"
    },
    "contracts/zeppelin/access/Roles.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma abicoder v2;\n\n/**\n * @title Roles\n * @dev Library for managing addresses assigned to a Role.\n */\nlibrary Roles {\n    struct Role {\n        mapping (address => bool) bearer;\n    }\n\n    /**\n     * @dev Give an account access to this role.\n     */\n    function add(Role storage role, address account) internal {\n        require(!has(role, account), \"Roles: account already has role\");\n        role.bearer[account] = true;\n    }\n\n    /**\n     * @dev Remove an account's access to this role.\n     */\n    function remove(Role storage role, address account) internal {\n        require(has(role, account), \"Roles: account doesn't have role\");\n        role.bearer[account] = false;\n    }\n\n    /**\n     * @dev Check if an account has this role.\n     * @return bool\n     */\n    function has(Role storage role, address account) internal view returns (bool) {\n        require(account != address(0), \"Roles: account is the zero address\");\n        return role.bearer[account];\n    }\n}\n"
    },
    "contracts/SideTokenFactory/SideTokenFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma abicoder v2;\n\nimport \"../zeppelin/ownership/Secondary.sol\";\nimport \"../interface/ISideTokenFactory.sol\";\nimport \"../SideToken/SideToken.sol\";\n\ncontract SideTokenFactory is ISideTokenFactory, Secondary {\n\n    function createSideToken(string calldata name, string calldata symbol, uint256 granularity)\n    external onlyPrimary override returns(address) {\n        address sideToken = address(new SideToken(name, symbol, primary(), granularity));\n        emit SideTokenCreated(sideToken, symbol, granularity);\n        return sideToken;\n    }\n}"
    },
    "contracts/zeppelin/ownership/Secondary.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma abicoder v2;\n\nimport \"../GSN/Context.sol\";\n/**\n * @dev A Secondary contract can only be used by its primary account (the one that created it).\n */\nabstract contract Secondary is Context {\n    address private _primary;\n\n    /**\n     * @dev Emitted when the primary contract changes.\n     */\n    event PrimaryTransferred(\n        address recipient\n    );\n\n    /**\n     * @dev Sets the primary account to the one that is creating the Secondary contract.\n     */\n    constructor () {\n        _primary = _msgSender();\n        emit PrimaryTransferred(_primary);\n    }\n\n    /**\n     * @dev Reverts if called from any account other than the primary.\n     */\n    modifier onlyPrimary() {\n        require(_msgSender() == _primary, \"Secondary: caller is not the primary account\");\n        _;\n    }\n\n    /**\n     * @return the address of the primary.\n     */\n    function primary() public view returns (address) {\n        return _primary;\n    }\n\n    /**\n     * @dev Transfers contract to a new primary.\n     * @param recipient The address of new primary.\n     */\n    function transferPrimary(address recipient) public onlyPrimary {\n        require(recipient != address(0), \"Secondary: new primary is the zero address\");\n        _primary = recipient;\n        emit PrimaryTransferred(_primary);\n    }\n}\n"
    },
    "contracts/SideToken/SideToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma abicoder v2;\n\nimport \"../zeppelin/token/ERC777/ERC777.sol\";\nimport \"../interface/IERC677Receiver.sol\";\nimport \"../interface/ISideToken.sol\";\nimport \"../lib/LibEIP712.sol\";\n\ncontract SideToken is ISideToken, ERC777 {\n    using SafeMath for uint256;\n\n    address public minter;\n    uint256 private _granularity;\n\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-2612.md\n    bytes32 public domainSeparator;\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    mapping(address => uint) public nonces;\n\n    // ERC677 Transfer Event\n    event Transfer(address,address,uint256,bytes);\n\n    constructor(string memory _tokenName, string memory _tokenSymbol, address _minterAddr, uint256 _newGranularity)\n    ERC777(_tokenName, _tokenSymbol, new address[](0)) {\n        require(_minterAddr != address(0), \"SideToken: Empty Minter\");\n        require(_newGranularity >= 1, \"SideToken: Granularity < 1\");\n        minter = _minterAddr;\n        _granularity = _newGranularity;\n\n        domainSeparator = LibEIP712.hashEIP712Domain(\n            name(),\n            \"1\",\n            block.chainid,\n            address(this)\n        );\n    }\n\n    modifier onlyMinter() {\n      require(_msgSender() == minter, \"SideToken: Caller is not the minter\");\n      _;\n    }\n\n    function mint(\n        address account,\n        uint256 amount,\n        bytes calldata userData,\n        bytes calldata operatorData\n    )\n    external onlyMinter override\n    {\n        _mint(_msgSender(), account, amount, userData, operatorData);\n    }\n\n    /**\n    * @dev ERC677 transfer token with additional data if the recipient is a contact.\n    * @param recipient The address to transfer to.\n    * @param amount The amount to be transferred.\n    * @param data The extra data to be passed to the receiving contract.\n    */\n    function transferAndCall(address recipient, uint amount, bytes calldata data)\n        external returns (bool success)\n    {\n        address from = _msgSender();\n\n        _send(from, from, recipient, amount, data, \"\", false);\n        emit Transfer(from, recipient, amount, data);\n        IERC677Receiver(recipient).onTokenTransfer(from, amount, data);\n        return true;\n    }\n\n    function granularity() public view override returns (uint256) {\n        return _granularity;\n    }\n\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-2612.md\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\n        require(deadline >= block.timestamp, \"SideToken: EXPIRED\"); // solhint-disable-line not-rely-on-time\n        bytes32 digest = LibEIP712.hashEIP712Message(\n            domainSeparator,\n            keccak256(\n                abi.encode(\n                    PERMIT_TYPEHASH,\n                    owner,\n                    spender,\n                    value,\n                    nonces[owner]++,\n                    deadline\n                )\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(recoveredAddress != address(0) && recoveredAddress == owner, \"SideToken: INVALID_SIGNATURE\");\n        _approve(owner, spender, value);\n    }\n\n}"
    },
    "contracts/zeppelin/token/ERC777/ERC777.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma abicoder v2;\n\nimport \"../../GSN/Context.sol\";\nimport \"./IERC777.sol\";\nimport \"./IERC777Recipient.sol\";\nimport \"./IERC777Sender.sol\";\nimport \"../../token/ERC20/IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../introspection/IERC1820Registry.sol\";\n\n/**\n * @dev Implementation of the {IERC777} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * Support for ERC20 is included in this contract, as specified by the EIP: both\n * the ERC777 and ERC20 interfaces can be safely used when interacting with it.\n * Both {IERC777-Sent} and {IERC20-Transfer} events are emitted on token\n * movements.\n *\n * Additionally, the {IERC777-granularity} value is hard-coded to `1`, meaning that there\n * are no special restrictions in the amount of tokens that created, moved, or\n * destroyed. This makes integration with ERC20 applications seamless.\n */\ncontract ERC777 is Context, IERC777, IERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    IERC1820Registry constant private _erc1820 = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\n\n    mapping(address => uint256) private _balances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    // We inline the result of the following hashes because Solidity doesn't resolve them at compile time.\n    // See https://github.com/ethereum/solidity/issues/4024.\n\n    // keccak256(\"ERC777TokensSender\")\n    bytes32 constant private TOKENS_SENDER_INTERFACE_HASH =\n        0x29ddb589b1fb5fc7cf394961c1adf5f8c6454761adf795e67fe149f658abe895;\n\n    // keccak256(\"ERC777TokensRecipient\")\n    bytes32 constant private TOKENS_RECIPIENT_INTERFACE_HASH =\n        0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b;\n\n    // This isn't ever read from - it's only used to respond to the defaultOperators query.\n    address[] private _defaultOperatorsArray;\n\n    // Immutable, but accounts may revoke them (tracked in __revokedDefaultOperators).\n    mapping(address => bool) private _defaultOperators;\n\n    // For each account, a mapping of its operators and revoked default operators.\n    mapping(address => mapping(address => bool)) private _operators;\n    mapping(address => mapping(address => bool)) private _revokedDefaultOperators;\n\n    // ERC20-allowances\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    /**\n     * @dev `defaultOperators` may be an empty array.\n     */\n    constructor(\n        string memory aName,\n        string memory aSymbol,\n        address[] memory theDefaultOperators\n    ) {\n        _name = aName;\n        _symbol = aSymbol;\n\n        _defaultOperatorsArray = theDefaultOperators;\n        for (uint256 i = 0; i < _defaultOperatorsArray.length; i++) {\n            _defaultOperators[_defaultOperatorsArray[i]] = true;\n        }\n\n        // register interfaces\n        _erc1820.setInterfaceImplementer(address(this), keccak256(\"ERC777Token\"), address(this));\n        _erc1820.setInterfaceImplementer(address(this), keccak256(\"ERC20Token\"), address(this));\n    }\n\n    /**\n     * @dev See {IERC777-name}.\n     */\n    function name() public view override(IERC777) returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC777-symbol}.\n     */\n    function symbol() public view override(IERC777) returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {ERC20Detailed-decimals}.\n     *\n     * Always returns 18, as per the\n     * [ERC777 EIP](https://eips.ethereum.org/EIPS/eip-777#backward-compatibility).\n     */\n    function decimals() public pure override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC777-granularity}.\n     *\n     * This implementation always returns `1`.\n     */\n    function granularity() public view virtual override(IERC777) returns (uint256) {\n        return 1;\n    }\n\n    /**\n     * @dev See {IERC777-totalSupply}.\n     */\n    function totalSupply() public view override(IERC20, IERC777) returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev Returns the amount of tokens owned by an account (`tokenHolder`).\n     */\n    function balanceOf(address tokenHolder) public view override(IERC20, IERC777) returns (uint256) {\n        return _balances[tokenHolder];\n    }\n\n    /**\n     * @dev See {IERC777-send}.\n     *\n     * Also emits a {Transfer} event for ERC20 compatibility.\n     */\n    function send(address recipient, uint256 amount, bytes calldata data) external override(IERC777) {\n        _send(_msgSender(), _msgSender(), recipient, amount, data, \"\", true);\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Unlike `send`, `recipient` is _not_ required to implement the {IERC777Recipient}\n     * interface if it is a contract.\n     *\n     * Also emits a {Sent} event.\n     */\n    function transfer(address recipient, uint256 amount) external override(IERC20) returns (bool) {\n        require(recipient != address(0), \"ERC777: transfer to zero address\");\n\n        address from = _msgSender();\n\n        _callTokensToSend(from, from, recipient, amount, \"\", \"\");\n\n        _move(from, from, recipient, amount, \"\", \"\");\n\n        _callTokensReceived(from, from, recipient, amount, \"\", \"\", false);\n\n        return true;\n    }\n\n    /**\n     * @dev See {IERC777-burn}.\n     *\n     * Also emits a {Transfer} event for ERC20 compatibility.\n     */\n    function burn(uint256 amount, bytes calldata data) external override(IERC777) {\n        _burn(_msgSender(), _msgSender(), amount, data, \"\");\n    }\n\n    /**\n     * @dev See {IERC777-isOperatorFor}.\n     */\n    function isOperatorFor(\n        address operator,\n        address tokenHolder\n    ) public view override(IERC777) returns (bool) {\n        return operator == tokenHolder ||\n            (_defaultOperators[operator] && !_revokedDefaultOperators[tokenHolder][operator]) ||\n            _operators[tokenHolder][operator];\n    }\n\n    /**\n     * @dev See {IERC777-authorizeOperator}.\n     */\n    function authorizeOperator(address operator) external override(IERC777) {\n        require(_msgSender() != operator, \"ERC777: authorizing self as operator\");\n\n        if (_defaultOperators[operator]) {\n            delete _revokedDefaultOperators[_msgSender()][operator];\n        } else {\n            _operators[_msgSender()][operator] = true;\n        }\n\n        emit AuthorizedOperator(operator, _msgSender());\n    }\n\n    /**\n     * @dev See {IERC777-revokeOperator}.\n     */\n    function revokeOperator(address operator) external override(IERC777) {\n        require(operator != _msgSender(), \"ERC777: revoking self as operator\");\n\n        if (_defaultOperators[operator]) {\n            _revokedDefaultOperators[_msgSender()][operator] = true;\n        } else {\n            delete _operators[_msgSender()][operator];\n        }\n\n        emit RevokedOperator(operator, _msgSender());\n    }\n\n    /**\n     * @dev See {IERC777-defaultOperators}.\n     */\n    function defaultOperators() public view override(IERC777) returns (address[] memory) {\n        return _defaultOperatorsArray;\n    }\n\n    /**\n     * @dev See {IERC777-operatorSend}.\n     *\n     * Emits {Sent} and {Transfer} events.\n     */\n    function operatorSend(\n        address sender,\n        address recipient,\n        uint256 amount,\n        bytes calldata data,\n        bytes calldata operatorData\n    )\n    external override(IERC777)\n    {\n        require(isOperatorFor(_msgSender(), sender), \"ERC777: caller is not an operator\");\n        _send(_msgSender(), sender, recipient, amount, data, operatorData, true);\n    }\n\n    /**\n     * @dev See {IERC777-operatorBurn}.\n     *\n     * Emits {Burned} and {Transfer} events.\n     */\n    function operatorBurn(address account, uint256 amount, bytes calldata data, bytes calldata operatorData)\n    external override(IERC777) {\n        require(isOperatorFor(_msgSender(), account), \"ERC777: caller is not an operator\");\n        _burn(_msgSender(), account, amount, data, operatorData);\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     *\n     * Note that operator and allowance concepts are orthogonal: operators may\n     * not have allowance, and accounts with allowance may not be operators\n     * themselves.\n     */\n    function allowance(address holder, address spender)\n    public view override(IERC20) returns (uint256) {\n        return _allowances[holder][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Note that accounts cannot have allowance issued by their operators.\n     */\n    function approve(address spender, uint256 value) external override(IERC20) returns (bool) {\n        address holder = _msgSender();\n        _approve(holder, spender, value);\n        return true;\n    }\n\n   /**\n    * @dev See {IERC20-transferFrom}.\n    *\n    * Note that operator and allowance concepts are orthogonal: operators cannot\n    * call `transferFrom` (unless they have allowance), and accounts with\n    * allowance cannot call `operatorSend` (unless they are operators).\n    *\n    * Emits {Sent}, {Transfer} and {Approval} events.\n    */\n    function transferFrom(address holder, address recipient, uint256 amount)\n    external override(IERC20) returns (bool) {\n        require(recipient != address(0), \"ERC777: transfer to zero address\");\n        require(holder != address(0), \"ERC777: transfer from zero address\");\n\n        address spender = _msgSender();\n\n        _callTokensToSend(spender, holder, recipient, amount, \"\", \"\");\n\n        _move(spender, holder, recipient, amount, \"\", \"\");\n        _approve(holder, spender, _allowances[holder][spender].sub(amount, \"ERC777: transfer amount exceeds allowance\"));\n\n        _callTokensReceived(spender, holder, recipient, amount, \"\", \"\", false);\n\n        return true;\n    }\n\n    /**\n     * @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * If a send hook is registered for `account`, the corresponding function\n     * will be called with `operator`, `data` and `operatorData`.\n     *\n     * See {IERC777Sender} and {IERC777Recipient}.\n     *\n     * Emits {Minted} and {Transfer} events.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - if `account` is a contract, it must implement the {IERC777Recipient}\n     * interface.\n     */\n    function _mint(\n        address operator,\n        address account,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData\n    )\n    internal\n    {\n        require(account != address(0), \"ERC777: mint to zero address\");\n\n        // Update state variables\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n\n        _callTokensReceived(operator, address(0), account, amount, userData, operatorData, true);\n\n        emit Minted(operator, account, amount, userData, operatorData);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Send tokens\n     * @param operator address operator requesting the transfer\n     * @param from address token holder address\n     * @param to address recipient address\n     * @param amount uint256 amount of tokens to transfer\n     * @param userData bytes extra information provided by the token holder (if any)\n     * @param operatorData bytes extra information provided by the operator (if any)\n     * @param requireReceptionAck if true, contract recipients are required to implement ERC777TokensRecipient\n     */\n    function _send(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData,\n        bool requireReceptionAck\n    )\n        internal\n    {\n        require(from != address(0), \"ERC777: send from zero address\");\n        require(to != address(0), \"ERC777: send to zero address\");\n\n        _callTokensToSend(operator, from, to, amount, userData, operatorData);\n\n        _move(operator, from, to, amount, userData, operatorData);\n\n        _callTokensReceived(operator, from, to, amount, userData, operatorData, requireReceptionAck);\n    }\n\n    /**\n     * @dev Burn tokens\n     * @param operator address operator requesting the operation\n     * @param from address token holder address\n     * @param amount uint256 amount of tokens to burn\n     * @param data bytes extra information provided by the token holder\n     * @param operatorData bytes extra information provided by the operator (if any)\n     */\n    function _burn(\n        address operator,\n        address from,\n        uint256 amount,\n        bytes memory data,\n        bytes memory operatorData\n    )\n        internal\n    {\n        require(from != address(0), \"ERC777: burn from zero address\");\n\n        _callTokensToSend(operator, from, address(0), amount, data, operatorData);\n\n        // Update state variables\n        _balances[from] = _balances[from].sub(amount, \"ERC777: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n\n        emit Burned(operator, from, amount, data, operatorData);\n        emit Transfer(from, address(0), amount);\n    }\n\n    function _move(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData\n    )\n        internal\n    {\n        _balances[from] = _balances[from].sub(amount, \"ERC777: transfer amount exceeds balance\");\n        _balances[to] = _balances[to].add(amount);\n\n        emit Sent(operator, from, to, amount, userData, operatorData);\n        emit Transfer(from, to, amount);\n    }\n\n    function _approve(address holder, address spender, uint256 value) internal {\n        // TODO: restore this require statement if this function becomes internal, or is called at a new callsite. It is\n        // currently unnecessary.\n        //require(holder != address(0), \"ERC777: approve from the zero address\");\n        require(spender != address(0), \"ERC777: approve to zero address\");\n\n        _allowances[holder][spender] = value;\n        emit Approval(holder, spender, value);\n    }\n\n    /**\n     * @dev Call from.tokensToSend() if the interface is registered\n     * @param operator address operator requesting the transfer\n     * @param from address token holder address\n     * @param to address recipient address\n     * @param amount uint256 amount of tokens to transfer\n     * @param userData bytes extra information provided by the token holder (if any)\n     * @param operatorData bytes extra information provided by the operator (if any)\n     */\n    function _callTokensToSend(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData\n    )\n        internal\n    {\n        address implementer = _erc1820.getInterfaceImplementer(from, TOKENS_SENDER_INTERFACE_HASH);\n        if (implementer != address(0)) {\n            IERC777Sender(implementer).tokensToSend(operator, from, to, amount, userData, operatorData);\n        }\n    }\n\n    /**\n     * @dev Call to.tokensReceived() if the interface is registered. Reverts if the recipient is a contract but\n     * tokensReceived() was not registered for the recipient\n     * @param operator address operator requesting the transfer\n     * @param from address token holder address\n     * @param to address recipient address\n     * @param amount uint256 amount of tokens to transfer\n     * @param userData bytes extra information provided by the token holder (if any)\n     * @param operatorData bytes extra information provided by the operator (if any)\n     * @param requireReceptionAck if true, contract recipients are required to implement ERC777TokensRecipient\n     */\n    function _callTokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData,\n        bool requireReceptionAck\n    )\n        private\n    {\n         address implementer = _erc1820.getInterfaceImplementer(to, TOKENS_RECIPIENT_INTERFACE_HASH);\n        if (implementer != address(0)) {\n            IERC777Recipient(implementer).tokensReceived(operator, from, to, amount, userData, operatorData);\n        } else if (requireReceptionAck) {\n            require(!to.isContract(), \"ERC777: token recipient contract has no implementer for ERC777TokensRecipient\");\n        }\n    }\n}\n"
    },
    "contracts/interface/IERC677Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma abicoder v2;\n\ninterface IERC677Receiver {\n  function onTokenTransfer(address _sender, uint _value, bytes calldata _data) external;\n}"
    },
    "contracts/zeppelin/token/ERC777/IERC777Sender.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma abicoder v2;\n\n/**\n * @dev Interface of the ERC777TokensSender standard as defined in the EIP.\n *\n * `IERC777` Token holders can be notified of operations performed on their\n * tokens by having a contract implement this interface (contract holders can be\n *  their own implementer) and registering it on the\n * [ERC1820 global registry](https://eips.ethereum.org/EIPS/eip-1820).\n *\n * See `IERC1820Registry` and `ERC1820Implementer`.\n */\ninterface IERC777Sender {\n    /**\n     * @dev Called by an `IERC777` token contract whenever a registered holder's\n     * (`from`) tokens are about to be moved or destroyed. The type of operation\n     * is conveyed by `to` being the zero address or not.\n     *\n     * This call occurs _before_ the token contract's state is updated, so\n     * `IERC777.balanceOf`, etc., can be used to query the pre-operation state.\n     *\n     * This function may revert to prevent the operation from being executed.\n     */\n    function tokensToSend(\n        address operator,\n        address from,\n        address to,\n        uint amount,\n        bytes calldata userData,\n        bytes calldata operatorData\n    ) external;\n}\n"
    },
    "contracts/zeppelin/upgradable/proxy/ProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\npragma abicoder v2;\n\nimport \"../../ownership/Ownable.sol\";\nimport \"./TransparentUpgradeableProxy.sol\";\n\n/**\n * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an\n * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.\n */\ncontract ProxyAdmin is Ownable {\n\n    /**\n     * @dev Returns the current implementation of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyImplementation(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"implementation()\")) == 0x5c60da1b\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"5c60da1b\");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Returns the current admin of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyAdmin(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"admin()\")) == 0xf851a440\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"f851a440\");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Changes the admin of `proxy` to `newAdmin`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the current admin of `proxy`.\n     */\n    function changeProxyAdmin(TransparentUpgradeableProxy proxy, address newAdmin) public virtual onlyOwner {\n        proxy.changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgrade(TransparentUpgradeableProxy proxy, address implementation) public virtual onlyOwner {\n        proxy.upgradeTo(implementation);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See\n     * {TransparentUpgradeableProxy-upgradeToAndCall}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgradeAndCall(TransparentUpgradeableProxy proxy, address implementation, bytes memory data) public payable virtual onlyOwner {\n        proxy.upgradeToAndCall{value: msg.value}(implementation, data);\n    }\n}\n"
    },
    "contracts/zeppelin/ownership/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma abicoder v2;\n\nimport \"../GSN/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () {\n        _owner = _msgSender();\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "contracts/zeppelin/upgradable/proxy/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma abicoder v2;\n\nimport \"./UpgradeableProxy.sol\";\n\n/**\n * @dev This contract implements a proxy that is upgradeable by an admin.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n * \"admin cannot fallback to proxy target\".\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n */\ncontract TransparentUpgradeableProxy is UpgradeableProxy {\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {UpgradeableProxy-constructor}.\n     */\n    constructor(address _logic, address admin_, bytes memory _data) payable UpgradeableProxy(_logic, _data) {\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n        _setAdmin(admin_);\n    }\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 private constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _admin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function admin() external ifAdmin returns (address admin_) {\n        admin_ = _admin();\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function implementation() external ifAdmin returns (address implementation_) {\n        implementation_ = _implementation();\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\n     */\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\n        require(newAdmin != address(0), \"TransparentUpgradeableProxy: new admin is the zero address\");\n        emit AdminChanged(_admin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\n     */\n    function upgradeTo(address newImplementation) external virtual ifAdmin {\n        _upgradeTo(newImplementation);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable virtual ifAdmin {\n        _upgradeTo(newImplementation);\n        Address.functionDelegateCall(newImplementation, data);\n    }\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _admin() internal view virtual returns (address adm) {\n        bytes32 slot = _ADMIN_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            adm := sload(slot)\n        }\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        bytes32 slot = _ADMIN_SLOT;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(slot, newAdmin)\n        }\n    }\n\n    /**\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\n     */\n    function _beforeFallback() internal virtual override {\n        require(msg.sender != _admin(), \"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");\n        super._beforeFallback();\n    }\n}\n"
    },
    "contracts/zeppelin/upgradable/proxy/UpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma abicoder v2;\n\nimport \"./Proxy.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n *\n * Upgradeability is only provided internally through {_upgradeTo}. For an externally upgradeable proxy see\n * {TransparentUpgradeableProxy}.\n */\ncontract UpgradeableProxy is Proxy {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializating the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n        _setImplementation(_logic);\n        if(_data.length > 0) {\n            Address.functionDelegateCall(_logic, _data);\n        }\n    }\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 private constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        bytes32 slot = _IMPLEMENTATION_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            impl := sload(slot)\n        }\n    }\n\n    /**\n     * @dev Upgrades the proxy to a new implementation.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal virtual {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"UpgradeableProxy: new implementation is not a contract\");\n\n        bytes32 slot = _IMPLEMENTATION_SLOT;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(slot, newImplementation)\n        }\n    }\n}\n"
    },
    "contracts/zeppelin/upgradable/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma abicoder v2;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 { revert(0, returndatasize()) }\n            default { return(0, returndatasize()) }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback () external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive () external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overriden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {\n    }\n}\n"
    },
    "contracts/Federation/Federation.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma abicoder v2;\n\n// Upgradables\nimport \"../zeppelin/upgradable/Initializable.sol\";\nimport \"../zeppelin/upgradable/ownership/UpgradableOwnable.sol\";\n\nimport \"../interface/IBridge.sol\";\nimport \"../interface/IFederation.sol\";\ncontract Federation is Initializable, UpgradableOwnable, IFederation {\n\tuint constant public MAX_MEMBER_COUNT = 50;\n\taddress constant private NULL_ADDRESS = address(0);\n\n\tIBridge public bridge;\n\taddress[] public members;\n\n\t/**\n\t\t@notice The minimum amount of votes to approve a transaction\n\t\t@dev It should have at least the required amount of members\n\t\t*/\n\tuint public required;\n\n\t/**\n\t\t@notice All the addresses that are members of the federation\n\t\t@dev The address should be a member to vote in transactions\n\t\t*/\n\tmapping (address => bool) public isMember;\n\n\t/**\n\t\t(bytes32) transactionId = keccak256(\n\t\t\tabi.encodePacked(\n\t\t\t\toriginalTokenAddress,\n\t\t\t\tsender,\n\t\t\t\treceiver,\n\t\t\t\tamount,\n\t\t\t\tblockHash,\n\t\t\t\ttransactionHash,\n\t\t\t\tlogIndex\n\t\t\t)\n\t\t) => (\n\t\t\t(address) members => (bool) voted\n\t\t)\n\t\t@notice Votes by members by the transaction ID\n\t\t@dev the members should approve the transaction by 50% + 1\n\t\t*/\n\tmapping (bytes32 => mapping (address => bool)) public votes;\n\n\t/**\n\t\t(bytes32) transactionId => (bool) voted\n\t\t@notice Check if that transaction was already processed\n\t*/\n\tmapping(bytes32 => bool) public processed;\n\n\tmodifier onlyMember() {\n\t\trequire(isMember[_msgSender()], \"Federation: Not Federator\");\n\t\t_;\n\t}\n\n\tmodifier validRequirement(uint membersCount, uint _required) {\n\t\trequire(_required <= membersCount && _required != 0 && membersCount != 0, \"Federation: Invalid requirements\");\n\t\t_;\n\t}\n\n\tfunction initialize(\n\t\taddress[] calldata _members,\n\t\tuint _required,\n\t\taddress _bridge,\n\t\taddress owner\n\t) public validRequirement(_members.length, _required) initializer {\n\t\tUpgradableOwnable.initialize(owner);\n\t\trequire(_members.length <= MAX_MEMBER_COUNT, \"Federation: Too many members\");\n\t\tmembers = _members;\n\t\tfor (uint i = 0; i < _members.length; i++) {\n\t\t\trequire(!isMember[_members[i]] && _members[i] != NULL_ADDRESS, \"Federation: Invalid members\");\n\t\t\tisMember[_members[i]] = true;\n\t\t\temit MemberAddition(_members[i]);\n\t\t}\n\t\trequired = _required;\n\t\temit RequirementChange(required);\n\t\t_setBridge(_bridge);\n\t}\n\n\t/**\n\t\t@notice Current version of the contract\n\t\t@return version in v{Number}\n\t\t*/\n\tfunction version() external pure override returns (string memory) {\n\t\treturn \"v3\";\n\t}\n\n\t/**\n\t\t@notice Sets a new bridge contract\n\t\t@dev Emits BridgeChanged event\n\t\t@param _bridge the new bridge contract address that should implement the IBridge interface\n\t\t*/\n\tfunction setBridge(address _bridge) external onlyOwner override {\n\t\t_setBridge(_bridge);\n\t}\n\n\tfunction _setBridge(address _bridge) internal {\n\t\trequire(_bridge != NULL_ADDRESS, \"Federation: Empty bridge\");\n\t\tbridge = IBridge(_bridge);\n\t\temit BridgeChanged(_bridge);\n\t}\n\n\tfunction validateTransaction(bytes32 transactionId, bytes32 transactionIdMultichain) internal view returns(bool) {\n\t\tuint256 minimumVotes = getMinimalNumberOfVotes();\n\t\tuint256 amountVotes = 0;\n\n    for (uint256 i = 0; i < members.length; i++) {\n      if (votes[transactionIdMultichain][members[i]]) {\n        amountVotes += 1;\n\t\t\t} else if (votes[transactionId][members[i]]) {\n        amountVotes += 1;\n\t\t\t}\n\n\t\t\tif (amountVotes >= minimumVotes && amountVotes >= required) {\n\t\t\t\treturn true;\n\t\t\t}\n    }\n\n\t\treturn false;\n\t}\n\n\tfunction getMinimalNumberOfVotes() internal view returns(uint256) {\n\t\treturn members.length / 2 + 1;\n\t}\n\n\tfunction isProcessed(bytes32 transactionId, bytes32 transactionIdMultichain) public view returns(bool) {\n\t\treturn processed[transactionIdMultichain] || processed[transactionId];\n\t}\n\n\tfunction isVoted(bytes32 transactionId, bytes32 transactionIdMultichain) public view returns(bool) {\n\t\treturn votes[transactionIdMultichain][_msgSender()] || votes[transactionId][_msgSender()];\n\t}\n\n\tfunction shouldBeCurrentChainId(uint256 chainId) internal view {\n\t\trequire(chainId == block.chainid, \"Federation: Not block.chainid\");\n\t}\n\n\t/**\n\t\t@notice Vote in a transaction, if it has enough votes it accepts the transfer\n\t\t@param originalTokenAddress The address of the token in the origin (main) chain\n\t\t@param sender The address who solicited the cross token\n\t\t@param receiver Who is going to receive the token in the opposite chain\n\t\t@param value Amount\n\t\t@param blockHash The block hash in which the transaction with the cross event occurred\n\t\t@param transactionHash The transaction in which the cross event occurred\n\t\t@param logIndex Index of the event in the logs\n\t\t@param originChainId Is chainId of the original chain\n\t\t@param destinationChainId Is chainId of the destination chain\n\t\t*/\n\tfunction voteTransaction(\n\t\taddress originalTokenAddress,\n\t\taddress payable sender,\n\t\taddress payable receiver,\n\t\tuint256 value,\n\t\tbytes32 blockHash,\n\t\tbytes32 transactionHash,\n\t\tuint32 logIndex,\n\t\tuint256 originChainId,\n\t\tuint256\tdestinationChainId\n\t) external onlyMember override {\n\t\tshouldBeCurrentChainId(destinationChainId);\n\t\tbytes32 transactionId = keccak256(\n\t\t\tabi.encodePacked(\n\t\t\t\toriginalTokenAddress,\n\t\t\t\tsender,\n\t\t\t\treceiver,\n\t\t\t\tvalue,\n\t\t\t\tblockHash,\n\t\t\t\ttransactionHash,\n\t\t\t\tlogIndex\n\t\t\t)\n\t\t);\n\n\t\tbytes32 transactionIdMultichain = getTransactionId(\n\t\t\toriginalTokenAddress,\n\t\t\tsender,\n\t\t\treceiver,\n\t\t\tvalue,\n\t\t\tblockHash,\n\t\t\ttransactionHash,\n\t\t\tlogIndex,\n\t\t\toriginChainId,\n\t\t\tdestinationChainId\n\t\t);\n\n\t\tif (isProcessed(transactionId, transactionIdMultichain))\n\t\t\treturn;\n\n\t\tif (isVoted(transactionId, transactionIdMultichain))\n\t\t\treturn;\n\n\t\tvotes[transactionIdMultichain][_msgSender()] = true;\n\t\temit Voted(\n\t\t\t_msgSender(),\n\t\t\ttransactionHash,\n\t\t\ttransactionIdMultichain,\n\t\t\toriginalTokenAddress,\n\t\t\tsender,\n\t\t\treceiver,\n\t\t\tvalue,\n\t\t\tblockHash,\n\t\t\tlogIndex,\n\t\t\toriginChainId,\n\t\t\tdestinationChainId\n\t\t);\n\n\t\tif (validateTransaction(transactionId, transactionIdMultichain)) {\n\t\t\tprocessed[transactionIdMultichain] = true;\n\n\t\t\tacceptTransfer(\n\t\t\t\toriginalTokenAddress,\n\t\t\t\tsender,\n\t\t\t\treceiver,\n\t\t\t\tvalue,\n\t\t\t\tblockHash,\n\t\t\t\ttransactionHash,\n\t\t\t\tlogIndex,\n\t\t\t\t\n\t\t\t\toriginChainId,\n\t\t\t\tdestinationChainId\n\t\t\t);\n\n\t\t\temit Executed(\n\t\t\t\t_msgSender(),\n\t\t\t\ttransactionHash,\n\t\t\t\ttransactionIdMultichain,\n\t\t\t\toriginalTokenAddress,\n\t\t\t\tsender,\n\t\t\t\treceiver,\n\t\t\t\tvalue,\n\t\t\t\tblockHash,\n\t\t\t\tlogIndex,\n\t\t\t\toriginChainId,\n\t\t\t\tdestinationChainId\n\t\t\t);\n\t\t}\n\t}\n\n  function acceptTransfer(\n    address originalTokenAddress,\n    address payable sender,\n    address payable receiver,\n    uint256 value,\n    bytes32 blockHash,\n    bytes32 transactionHash,\n    uint32 logIndex,\n\tuint256 originChainId,\n\tuint256\tdestinationChainId\n  ) internal {\n\t  bridge.acceptTransfer(\n\t\toriginalTokenAddress,\n\t\tsender,\n\t\treceiver,\n\t\tvalue,\n\t\tblockHash,\n\t\ttransactionHash,\n\t\tlogIndex,\n\t\toriginChainId,\n\t\tdestinationChainId\n\t  );\n  }\n\n  /**\n    @notice Get the amount of approved votes for that transactionId\n    @param transactionId The transaction hashed from getTransactionId function\n   */\n  function getTransactionCount(bytes32 transactionId) public view returns(uint) {\n    uint count = 0;\n    for (uint i = 0; i < members.length; i++) {\n      if (votes[transactionId][members[i]])\n        count += 1;\n    }\n    return count;\n  }\n\n\tfunction hasVoted(bytes32 transactionId) external view returns(bool) {\n\t\treturn votes[transactionId][_msgSender()];\n\t}\n\n\tfunction transactionWasProcessed(bytes32 transactionId) external view returns(bool) {\n\t\treturn processed[transactionId];\n\t}\n\n\t/**\n\t\t@notice Gets the hash of transaction from the following parameters encoded and keccaked\n\t\t@dev It encodes and applies keccak256 to the parameters received in the same order\n\t\t@param originalTokenAddress The address of the token in the origin (main) chain\n\t\t@param sender The address who solicited the cross token\n\t\t@param receiver Who is going to receive the token in the opposite chain\n\t\t@param amount Could be the amount or the tokenId\n\t\t@param blockHash The block hash in which the transaction with the cross event occurred\n\t\t@param transactionHash The transaction in which the cross event occurred\n\t\t@param logIndex Index of the event in the logs\n\t\t@param originChainId Is chainId of the original chain\n\t\t@param destinationChainId Is chainId of the destination chain\n\t\t@return The hash generated by the parameters.\n\t*/\n\tfunction getTransactionId(\n\t\taddress originalTokenAddress,\n\t\taddress sender,\n\t\taddress receiver,\n\t\tuint256 amount,\n\t\tbytes32 blockHash,\n\t\tbytes32 transactionHash,\n\t\tuint32 logIndex,\n\t\tuint256 originChainId,\n\t\tuint256\tdestinationChainId\n\t) public pure returns(bytes32) {\n\t\treturn keccak256(\n\t\t\tabi.encodePacked(\n\t\t\t\toriginalTokenAddress,\n\t\t\t\tsender,\n\t\t\t\treceiver,\n\t\t\t\tamount,\n\t\t\t\tblockHash,\n\t\t\t\ttransactionHash,\n\t\t\t\tlogIndex,\n\t\t\t\toriginChainId,\n\t\t\t\tdestinationChainId\n\t\t\t)\n\t\t);\n\t}\n\n\tfunction addMember(address _newMember) external onlyOwner override {\n\t\trequire(_newMember != NULL_ADDRESS, \"Federation: Empty member\");\n\t\trequire(!isMember[_newMember], \"Federation: Member already exists\");\n\t\trequire(members.length < MAX_MEMBER_COUNT, \"Federation: Max members reached\");\n\n\t\tisMember[_newMember] = true;\n\t\tmembers.push(_newMember);\n\t\temit MemberAddition(_newMember);\n\t}\n\n\tfunction removeMember(address _oldMember) external onlyOwner override {\n\t\trequire(_oldMember != NULL_ADDRESS, \"Federation: Empty member\");\n\t\trequire(isMember[_oldMember], \"Federation: Member doesn't exists\");\n\t\trequire(members.length > 1, \"Federation: Can't remove all the members\");\n\t\trequire(members.length - 1 >= required, \"Federation: Can't have less than required members\");\n\n\t\tisMember[_oldMember] = false;\n\t\tfor (uint i = 0; i < members.length - 1; i++) {\n\t\t\tif (members[i] == _oldMember) {\n\t\t\t\tmembers[i] = members[members.length - 1];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmembers.pop(); // remove an element from the end of the array.\n\t\temit MemberRemoval(_oldMember);\n\t}\n\n\t/**\n\t\t@notice Return all the current members of the federation\n\t\t@return Current members\n\t\t*/\n\tfunction getMembers() external view override returns (address[] memory) {\n\t\treturn members;\n\t}\n\n\t/**\n\t\t@notice Changes the number of required members to vote and approve an transaction\n\t\t@dev Emits the RequirementChange event\n\t\t@param _required the number of minimum members to approve an transaction, it has to be bigger than 1\n\t\t*/\n\tfunction changeRequirement(uint _required) external onlyOwner validRequirement(members.length, _required) override {\n\t\trequire(_required >= 2, \"Federation: Requires at least 2\");\n\t\trequired = _required;\n\t\temit RequirementChange(_required);\n\t}\n\n\t/**\n\t\t@notice It emits an HeartBeat like an health check\n\t\t@dev Emits HeartBeat event\n\t\t*/\n\tfunction emitHeartbeat(\n\t\tstring calldata fedVersion,\n\t\tuint256[] calldata fedChainsIds,\n\t\tuint256[] calldata fedChainsBlocks,\n\t\tstring[] calldata fedChainsInfo\n\t) external onlyMember override {\n\t\trequire(fedChainsIds.length == fedChainsBlocks.length &&\n\t\t\tfedChainsIds.length == fedChainsInfo.length, \"Federation: Length missmatch\");\n\t\temit HeartBeat(\n\t\t\t_msgSender(),\n\t\t\tblock.chainid,\n\t\t\tblock.number,\n\t\t\tfedVersion,\n\t\t\tfedChainsIds,\n\t\t\tfedChainsBlocks,\n\t\t\tfedChainsInfo\n\t\t);\n\t}\n}\n"
    },
    "contracts/interface/IFederation.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\npragma abicoder v2;\n\ninterface IFederation {\n\n  /**\n    @notice Current version of the contract\n    @return version in v{Number}\n    */\n  function version() external pure returns (string memory);\n\n  /**\n    @notice Sets a new bridge contract\n    @param _bridge the new bridge contract address that should implement the IBridge interface\n  */\n  function setBridge(address _bridge) external;\n\n  /**\n    @notice Vote in a transaction, if it has enough votes it accepts the transfer\n    @param originalTokenAddress The address of the token in the origin (main) chain\n    @param sender The address who solicited the cross token\n    @param receiver Who is going to receive the token in the opposite chain\n    @param value Amount\n    @param blockHash The block hash in which the transaction with the cross event occurred\n    @param transactionHash The transaction in which the cross event occurred\n    @param logIndex Index of the event in the logs\n\t\t@param originChainId Is chainId of the original chain\n\t\t@param destinationChainId Is chainId of the destination chain\n  */\n  function voteTransaction(\n    address originalTokenAddress,\n    address payable sender,\n    address payable receiver,\n    uint256 value,\n    bytes32 blockHash,\n    bytes32 transactionHash,\n    uint32 logIndex,\n\t  uint256 originChainId,\n\t  uint256\tdestinationChainId\n  ) external;\n\n  /**\n    @notice Add a new member to the federation\n    @param _newMember address of the new member\n  */\n  function addMember(address _newMember) external;\n\n  /**\n    @notice Remove a member of the federation\n    @param _oldMember address of the member to be removed from federation\n  */\n  function removeMember(address _oldMember) external;\n\n  /**\n    @notice Return all the current members of the federation\n    @return Current members\n  */\n  function getMembers() external view returns (address[] memory);\n\n  /**\n    @notice Changes the number of required members to vote and approve an transaction\n    @param _required the number of minimum members to approve an transaction, it has to be bigger than 1\n  */\n  function changeRequirement(uint _required) external;\n\n  /**\n    @notice It emmits an HeartBeat like an healthy check\n  */\n  function emitHeartbeat(\n    string calldata federatorVersion,\n\t\tuint256[] calldata fedChainsIds,\n\t\tuint256[] calldata fedChainsBlocks,\n\t\tstring[] calldata fedChainsInfo\n  ) external;\n\n  event Executed(\n    address indexed federator,\n    bytes32 indexed transactionHash,\n    bytes32 indexed transactionId,\n    address originalTokenAddress,\n    address sender,\n    address receiver,\n    uint256 amount,\n    bytes32 blockHash,\n    uint32 logIndex,\n\t\tuint256 originChainId,\n\t\tuint256\tdestinationChainId\n  );\n  event MemberAddition(address indexed member);\n  event MemberRemoval(address indexed member);\n  event RequirementChange(uint required);\n  event BridgeChanged(address bridge);\n  event Voted(\n    address indexed federator,\n    bytes32 indexed transactionHash,\n    bytes32 indexed transactionId,\n    address originalTokenAddress,\n    address sender,\n    address receiver,\n    uint256 amount,\n    bytes32 blockHash,\n    uint32 logIndex,\n    uint256 originChainId,\n\t\tuint256\tdestinationChainId\n  );\n  event HeartBeat(\n    address indexed sender,\n    uint256 currentChainId,\n    uint256 currentBlock,\n    string fedVersion,\n    uint256[] fedChainsIds,\n\t\tuint256[] fedChainsBlocks,\n\t\tstring[] fedChainsInfo\n  );\n\n}\n"
    },
    "contracts/Proxies.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma abicoder v2;\n\nimport \"./zeppelin/upgradable/proxy/TransparentUpgradeableProxy.sol\";\n\ncontract BridgeProxy is TransparentUpgradeableProxy {\n  // solhint-disable-next-line no-empty-blocks\n  constructor(address _logic, address _admin, bytes memory _data) TransparentUpgradeableProxy(_logic,_admin, _data) payable {}\n}\n\ncontract AllowTokensProxy is TransparentUpgradeableProxy {\n  // solhint-disable-next-line no-empty-blocks\n  constructor(address _logic, address _admin, bytes memory _data) TransparentUpgradeableProxy(_logic,_admin, _data) payable {}\n}\n\ncontract FederationProxy is TransparentUpgradeableProxy {\n  // solhint-disable-next-line no-empty-blocks\n  constructor(address _logic, address _admin, bytes memory _data) TransparentUpgradeableProxy(_logic,_admin, _data) payable {}\n}"
    },
    "contracts/MultiSigWallet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma abicoder v2;\n\n/// @title Multisignature wallet - Allows multiple parties to agree on transactions before execution.\n/// @author Stefan George - <stefan.george@consensys.net>\ncontract MultiSigWallet {\n\n    /*\n     *  Events\n     */\n    event Confirmation(address indexed sender, uint indexed transactionId);\n    event Revocation(address indexed sender, uint indexed transactionId);\n    event Submission(uint indexed transactionId);\n    event Execution(uint indexed transactionId);\n    event ExecutionFailure(uint indexed transactionId);\n    event Deposit(address indexed sender, uint value);\n    event OwnerAddition(address indexed owner);\n    event OwnerRemoval(address indexed owner);\n    event RequirementChange(uint required);\n\n    /*\n     *  views\n     */\n    uint constant public MAX_OWNER_COUNT = 50;\n\n    /*\n     *  Storage\n     */\n    mapping (uint => Transaction) public transactions;\n    mapping (uint => mapping (address => bool)) public confirmations;\n    mapping (address => bool) public isOwner;\n    address[] public owners;\n    uint public required;\n    uint public transactionCount;\n\n    struct Transaction {\n        address destination;\n        uint value;\n        bytes data;\n        bool executed;\n    }\n\n    /*\n     *  Modifiers\n     */\n    modifier onlyWallet() {\n        require(msg.sender == address(this), \"Only wallet allowed\");\n        _;\n    }\n\n    modifier ownerDoesNotExist(address owner) {\n        require(!isOwner[owner], \"The owner already exists\");\n        _;\n    }\n\n    modifier ownerExists(address owner) {\n        require(isOwner[owner], \"The owner does not exist\");\n        _;\n    }\n\n    modifier transactionExists(uint transactionId) {\n        require(transactions[transactionId].destination != address(0), \"Transaction does not exist\");\n        _;\n    }\n\n    modifier confirmed(uint transactionId, address owner) {\n        require(confirmations[transactionId][owner], \"Transaction is not confirmed by owner\");\n        _;\n    }\n\n    modifier notConfirmed(uint transactionId, address owner) {\n        require(!confirmations[transactionId][owner], \"Transaction is already confirmed by owner\");\n        _;\n    }\n\n    modifier notExecuted(uint transactionId) {\n        require(!transactions[transactionId].executed, \"Transaction was already executed\");\n        _;\n    }\n\n    modifier notNull(address _address) {\n        require(_address != address(0), \"Address cannot be empty\");\n        _;\n    }\n\n    modifier validRequirement(uint ownerCount, uint _required) {\n        // solium-disable-next-line max-len\n        require(ownerCount <= MAX_OWNER_COUNT && _required <= ownerCount && _required != 0 && ownerCount != 0, \"Required value is invalid for the current owners count\");\n        _;\n    }\n\n    /// @dev Fallback function allows to deposit ether.\n    receive ()\n        external\n        payable\n    {\n        if (msg.value > 0)\n            emit Deposit(msg.sender, msg.value);\n    }\n\n    /*\n     * Public functions\n     */\n    /// @dev Contract constructor sets initial owners and required number of confirmations.\n    /// @param _owners List of initial owners.\n    /// @param _required Number of required confirmations.\n    constructor(address[] memory _owners, uint _required)\n        validRequirement(_owners.length, _required)\n    {\n        for (uint i = 0; i < _owners.length; i++) {\n            require(!isOwner[_owners[i]] && _owners[i] != address(0), \"Owners addresses are invalid\");\n            isOwner[_owners[i]] = true;\n        }\n        owners = _owners;\n        required = _required;\n    }\n\n    /// @dev Allows to add a new owner. Transaction has to be sent by wallet.\n    /// @param owner Address of new owner.\n    function addOwner(address owner)\n        public\n        onlyWallet\n        ownerDoesNotExist(owner)\n        notNull(owner)\n        validRequirement(owners.length + 1, required)\n    {\n        isOwner[owner] = true;\n        owners.push(owner);\n        emit OwnerAddition(owner);\n    }\n\n    /// @dev Allows to remove an owner. Transaction has to be sent by wallet.\n    /// @param owner Address of owner.\n    function removeOwner(address owner)\n        public\n        onlyWallet\n        ownerExists(owner)\n    {\n        isOwner[owner] = false;\n        for (uint i = 0; i < owners.length - 1; i++)\n            if (owners[i] == owner) {\n                owners[i] = owners[owners.length - 1];\n                break;\n            }\n        owners.pop(); // remove an element from the end of the array.\n        if (required > owners.length)\n            changeRequirement(owners.length);\n        emit OwnerRemoval(owner);\n    }\n\n    /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet.\n    /// @param owner Address of owner to be replaced.\n    /// @param newOwner Address of new owner.\n    function replaceOwner(address owner, address newOwner)\n        public\n        onlyWallet\n        ownerExists(owner)\n        ownerDoesNotExist(newOwner)\n    {\n        for (uint i = 0; i < owners.length; i++)\n            if (owners[i] == owner) {\n                owners[i] = newOwner;\n                break;\n            }\n        isOwner[owner] = false;\n        isOwner[newOwner] = true;\n        emit OwnerRemoval(owner);\n        emit OwnerAddition(newOwner);\n    }\n\n    /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet.\n    /// @param _required Number of required confirmations.\n    function changeRequirement(uint _required)\n        public\n        onlyWallet\n        validRequirement(owners.length, _required)\n    {\n        required = _required;\n        emit RequirementChange(_required);\n    }\n\n    /// @dev Allows an owner to submit and confirm a transaction.\n    /// @param destination Transaction target address.\n    /// @param value Transaction ether value.\n    /// @param data Transaction data payload.\n    /// @return transactionId Returns transaction ID.\n    function submitTransaction(address destination, uint value, bytes memory data)\n        public\n        returns (uint transactionId)\n    {\n        transactionId = addTransaction(destination, value, data);\n        confirmTransaction(transactionId);\n    }\n\n    /// @dev Allows an owner to confirm a transaction.\n    /// @param transactionId Transaction ID.\n    function confirmTransaction(uint transactionId)\n        public\n        ownerExists(msg.sender)\n        transactionExists(transactionId)\n        notConfirmed(transactionId, msg.sender)\n    {\n        confirmations[transactionId][msg.sender] = true;\n        emit Confirmation(msg.sender, transactionId);\n        executeTransaction(transactionId);\n    }\n\n    /// @dev Allows an owner to revoke a confirmation for a transaction.\n    /// @param transactionId Transaction ID.\n    function revokeConfirmation(uint transactionId)\n        public\n        ownerExists(msg.sender)\n        confirmed(transactionId, msg.sender)\n        notExecuted(transactionId)\n    {\n        confirmations[transactionId][msg.sender] = false;\n        emit Revocation(msg.sender, transactionId);\n    }\n\n    /// @dev Allows anyone to execute a confirmed transaction.\n    /// @param transactionId Transaction ID.\n    function executeTransaction(uint transactionId)\n        public\n        ownerExists(msg.sender)\n        confirmed(transactionId, msg.sender)\n        notExecuted(transactionId)\n    {\n        if (isConfirmed(transactionId)) {\n            Transaction storage txn = transactions[transactionId];\n            txn.executed = true;\n            if (external_call(txn.destination, txn.value, txn.data.length, txn.data))\n                emit Execution(transactionId);\n            else {\n                emit ExecutionFailure(transactionId);\n                txn.executed = false;\n            }\n        }\n    }\n\n    // call has been separated into its own function in order to take advantage\n    // of the Solidity's code generator to produce a loop that copies tx.data into memory.\n    function external_call(address destination, uint value, uint dataLength, bytes memory data) internal returns (bool) {\n        bool result;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            let x := mload(0x40)   // \"Allocate\" memory for output (0x40 is where \"free memory\" pointer is stored by convention)\n            let d := add(data, 32) // First 32 bytes are the padded length of data, so exclude that\n            result := call(\n                sub(gas(), 34710),   // 34710 is the value that solidity is currently emitting\n                                   // It includes callGas (700) + callVeryLow (3, to pay for SUB) + callValueTransferGas (9000) +\n                                   // callNewAccountGas (25000, in case the destination address does not exist and needs creating)\n                destination,\n                value,\n                d,\n                dataLength,        // Size of the input (in bytes) - this is what fixes the padding problem\n                x,\n                0                  // Output is ignored, therefore the output size is zero\n            )\n        }\n        return result;\n    }\n\n    /// @dev Returns the confirmation status of a transaction.\n    /// @param transactionId Transaction ID.\n    /// @return Confirmation status.\n    function isConfirmed(uint transactionId)\n        public\n        view\n        returns (bool)\n    {\n        uint count = 0;\n        for (uint i = 0; i < owners.length; i++) {\n            if (confirmations[transactionId][owners[i]])\n                count += 1;\n            if (count == required)\n                return true;\n        }\n        return false;\n    }\n\n    /*\n     * Internal functions\n     */\n    /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet.\n    /// @param destination Transaction target address.\n    /// @param value Transaction ether value.\n    /// @param data Transaction data payload.\n    /// @return transactionId Returns transaction ID.\n    function addTransaction(address destination, uint value, bytes memory data)\n        internal\n        notNull(destination)\n        returns (uint transactionId)\n    {\n        transactionId = transactionCount;\n        transactions[transactionId] = Transaction({\n            destination: destination,\n            value: value,\n            data: data,\n            executed: false\n        });\n        transactionCount += 1;\n        emit Submission(transactionId);\n    }\n\n    /*\n     * Web3 call functions\n     */\n    /// @dev Returns number of confirmations of a transaction.\n    /// @param transactionId Transaction ID.\n    /// @return count Number of confirmations.\n    function getConfirmationCount(uint transactionId)\n        public\n        view\n        returns (uint count)\n    {\n        for (uint i = 0; i < owners.length; i++) {\n            if (confirmations[transactionId][owners[i]]) {\n                count += 1;\n            }\n        }\n    }\n\n    /// @dev Returns total number of transactions after filers are applied.\n    /// @param pending Include pending transactions.\n    /// @param executed Include executed transactions.\n    /// @return count Total number of transactions after filters are applied.\n    function getTransactionCount(bool pending, bool executed)\n        public\n        view\n        returns (uint count)\n    {\n        for (uint i = 0; i < transactionCount; i++) {\n            if ( pending && !transactions[i].executed || executed && transactions[i].executed) {\n                count += 1;\n            }\n        }\n    }\n\n    /// @dev Returns list of owners.\n    /// @return List of owner addresses.\n    function getOwners()\n        public\n        view\n        returns (address[] memory)\n    {\n        return owners;\n    }\n\n    /// @dev Returns array with owner addresses, which confirmed transaction.\n    /// @param transactionId Transaction ID.\n    /// @return _confirmations Returns array of owner addresses.\n    function getConfirmations(uint transactionId)\n        public\n        view\n        returns (address[] memory _confirmations)\n    {\n        address[] memory confirmationsTemp = new address[](owners.length);\n        uint count = 0;\n        uint i;\n        for (i = 0; i < owners.length; i++)\n            if (confirmations[transactionId][owners[i]]) {\n                confirmationsTemp[count] = owners[i];\n                count += 1;\n            }\n        _confirmations = new address[](count);\n        for (i = 0; i < count; i++)\n            _confirmations[i] = confirmationsTemp[i];\n    }\n\n    /// @dev Returns list of transaction IDs in defined range.\n    /// @param from Index start position of transaction array.\n    /// @param to Index end position of transaction array.\n    /// @param pending Include pending transactions.\n    /// @param executed Include executed transactions.\n    /// @return _transactionIds Returns array of transaction IDs.\n    function getTransactionIds(uint from, uint to, bool pending, bool executed)\n        public\n        view\n        returns (uint[] memory _transactionIds)\n    {\n        uint[] memory transactionIdsTemp = new uint[](transactionCount);\n        uint count = 0;\n        uint i;\n        for (i = 0; i < transactionCount; i++)\n            if (   pending && !transactions[i].executed || executed && transactions[i].executed)\n            {\n                transactionIdsTemp[count] = i;\n                count += 1;\n            }\n        _transactionIds = new uint[](to - from);\n        for (i = from; i < to; i++)\n            _transactionIds[i - from] = transactionIdsTemp[i];\n    }\n}"
    }
  },
  "settings": {
    "evmVersion": "istanbul",
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}