{
  "language": "Solidity",
  "sources": {
    "contracts/AllowTokens/AllowTokens.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\npragma abicoder v2;\n\nimport \"../zeppelin/math/SafeMath.sol\";\n// Upgradables\nimport \"../zeppelin/upgradable/Initializable.sol\";\nimport \"../zeppelin/upgradable/ownership/UpgradableOwnable.sol\";\nimport \"../zeppelin/upgradable/ownership/UpgradableSecondary.sol\";\n\nimport \"../interface/IAllowTokens.sol\";\n\ncontract AllowTokens is Initializable, UpgradableOwnable, UpgradableSecondary, IAllowTokens {\n    using SafeMath for uint256;\n\n    address constant private NULL_ADDRESS = address(0);\n    uint256 constant public MAX_TYPES = 250;\n    mapping (address => TokenInfo) public allowedTokens;\n    mapping (uint256 => Limits) public typeLimits;\n    uint256 public smallAmountConfirmations;\n    uint256 public mediumAmountConfirmations;\n    uint256 public largeAmountConfirmations;\n    string[] public typeDescriptions;\n\n    event SetToken(address indexed _tokenAddress, uint256 _typeId);\n    event AllowedTokenRemoved(address indexed _tokenAddress);\n    event TokenTypeAdded(uint256 indexed _typeId, string _typeDescription);\n    event TypeLimitsChanged(uint256 indexed _typeId, Limits limits);\n    event UpdateTokensTransfered(address indexed _tokenAddress, uint256 _lastDay, uint256 _spentToday);\n    event ConfirmationsChanged(uint256 _smallAmountConfirmations, uint256 _mediumAmountConfirmations, uint256 _largeAmountConfirmations);\n\n\n    modifier notNull(address _address) {\n        require(_address != NULL_ADDRESS, \"AllowTokens: Null Address\");\n        _;\n    }\n\n    function initialize(\n        address _manager,\n        address _primary,\n        uint256 _smallAmountConfirmations,\n        uint256 _mediumAmountConfirmations,\n        uint256 _largeAmountConfirmations,\n        TypeInfo[] memory typesInfo) public initializer {\n        UpgradableOwnable.initialize(_manager);\n        UpgradableSecondary.__Secondary_init(_primary);\n        _setConfirmations(_smallAmountConfirmations, _mediumAmountConfirmations, _largeAmountConfirmations);\n        for(uint i = 0; i < typesInfo.length; i = i + 1) {\n            _addTokenType(typesInfo[i].description, typesInfo[i].limits);\n        }\n    }\n\n    function version() override external pure returns (string memory) {\n        return \"v1\";\n    }\n\n    function getInfoAndLimits(address token) override public view\n    returns (TokenInfo memory info, Limits memory limit) {\n        info = allowedTokens[token];\n        limit = typeLimits[info.typeId];\n        return (info, limit);\n    }\n    function calcMaxWithdraw(address token) override public view returns (uint256 maxWithdraw) {\n        (TokenInfo memory info, Limits memory limits) = getInfoAndLimits(token);\n        return _calcMaxWithdraw(info, limits);\n    }\n\n    function _calcMaxWithdraw(TokenInfo memory info, Limits memory limits) private view returns (uint256 maxWithdraw) {\n        // solium-disable-next-line security/no-block-members\n        if (block.timestamp > info.lastDay + 24 hours) { // solhint-disable-line not-rely-on-time\n            info.spentToday = 0;\n        }\n        if (limits.daily <= info.spentToday)\n            return 0;\n        maxWithdraw = limits.daily - info.spentToday;\n        if(maxWithdraw > limits.max)\n            maxWithdraw = limits.max;\n        return maxWithdraw;\n    }\n\n    // solium-disable-next-line max-len\n    function updateTokenTransfer(address token, uint256 amount) override external onlyPrimary {\n        (TokenInfo memory info, Limits memory limit) = getInfoAndLimits(token);\n        require(isTokenAllowed(token), \"AllowTokens: Not whitelisted\");\n        require(amount >= limit.min, \"AllowTokens: Lower than limit\");\n\n        // solium-disable-next-line security/no-block-members\n        if (block.timestamp > info.lastDay + 24 hours) { // solhint-disable-line not-rely-on-time\n            // solium-disable-next-line security/no-block-members\n            info.lastDay = block.timestamp; // solhint-disable-line not-rely-on-time\n            info.spentToday = 0;\n        }\n        uint maxWithdraw = _calcMaxWithdraw(info, limit);\n        require(amount <= maxWithdraw, \"AllowTokens: Exceeded limit\");\n        info.spentToday = info.spentToday.add(amount);\n        allowedTokens[token] = info;\n\n        emit UpdateTokensTransfered(token, info.lastDay, info.spentToday);\n    }\n\n    function _addTokenType(string memory description, Limits memory limits) private returns(uint256 len) {\n        require(bytes(description).length > 0, \"AllowTokens: Empty description\");\n        len = typeDescriptions.length;\n        require(len + 1 <= MAX_TYPES, \"AllowTokens: Reached MAX_TYPES\");\n        typeDescriptions.push(description);\n        _setTypeLimits(len, limits);\n        emit TokenTypeAdded(len, description);\n        return len;\n    }\n\n    function addTokenType(string calldata description, Limits calldata limits) external onlyOwner returns(uint256 len) {\n        return _addTokenType(description, limits);\n    }\n\n    function _setTypeLimits(uint256 typeId, Limits memory limits) private {\n        require(typeId < typeDescriptions.length, \"AllowTokens: bigger than typeDescriptions\");\n        require(limits.max >= limits.min, \"AllowTokens: maxTokens smaller than minTokens\");\n        require(limits.daily >= limits.max, \"AllowTokens: dailyLimit smaller than maxTokens\");\n        require(limits.mediumAmount > limits.min, \"AllowTokens: limits.mediumAmount smaller than min\");\n        require(limits.largeAmount > limits.mediumAmount, \"AllowTokens: limits.largeAmount smaller than mediumAmount\");\n        typeLimits[typeId] = limits;\n        emit TypeLimitsChanged(typeId, limits);\n    }\n\n    function setTypeLimits(uint256 typeId, Limits memory limits) public onlyOwner {\n        _setTypeLimits(typeId, limits);\n    }\n\n    function getTypesLimits() external view override returns(Limits[] memory limits) {\n        limits = new Limits[](typeDescriptions.length);\n        for (uint256 i = 0; i < typeDescriptions.length; i++) {\n            limits[i] = typeLimits[i];\n        }\n        return limits;\n    }\n\n    function getTypeDescriptionsLength() external view override returns(uint256) {\n        return typeDescriptions.length;\n    }\n\n    function getTypeDescriptions() external view override returns(string[] memory descriptions) {\n        descriptions = new string[](typeDescriptions.length);\n        for (uint256 i = 0; i < typeDescriptions.length; i++) {\n            descriptions[i] = typeDescriptions[i];\n        }\n        return descriptions;\n    }\n\n    function isTokenAllowed(address token) public view notNull(token) override returns (bool) {\n        return allowedTokens[token].allowed;\n    }\n\n    function setToken(address token, uint256 typeId) override public notNull(token) {\n        require(isOwner() || _msgSender() == primary(), \"AllowTokens: unauthorized sender\");\n        require(typeId < typeDescriptions.length, \"AllowTokens: typeId does not exist\");\n        TokenInfo memory info = allowedTokens[token];\n        info.allowed = true;\n        info.typeId = typeId;\n        allowedTokens[token] = info;\n        emit SetToken(token, typeId);\n    }\n\n    function setMultipleTokens(TokensAndType[] calldata tokensAndTypes) external onlyOwner {\n        require(tokensAndTypes.length > 0, \"AllowTokens: empty tokens\");\n        for(uint256 i = 0; i < tokensAndTypes.length; i = i + 1) {\n            setToken(tokensAndTypes[i].token, tokensAndTypes[i].typeId);\n        }\n    }\n\n    function removeAllowedToken(address token) external notNull(token) onlyOwner {\n        TokenInfo memory info = allowedTokens[token];\n        require(info.allowed, \"AllowTokens: Not Allowed\");\n        info.allowed = false;\n        allowedTokens[token] = info;\n        emit AllowedTokenRemoved(token);\n    }\n\n    function setConfirmations(\n        uint256 _smallAmountConfirmations,\n        uint256 _mediumAmountConfirmations,\n        uint256 _largeAmountConfirmations) external onlyOwner {\n        _setConfirmations(_smallAmountConfirmations, _mediumAmountConfirmations, _largeAmountConfirmations);\n    }\n\n    function _setConfirmations(\n        uint256 _smallAmountConfirmations,\n        uint256 _mediumAmountConfirmations,\n        uint256 _largeAmountConfirmations) private {\n        require(_smallAmountConfirmations <= _mediumAmountConfirmations, \"AllowTokens: small bigger than medium confirmations\");\n        require(_mediumAmountConfirmations <= _largeAmountConfirmations, \"AllowTokens: medium bigger than large confirmations\");\n        smallAmountConfirmations = _smallAmountConfirmations;\n        mediumAmountConfirmations = _mediumAmountConfirmations;\n        largeAmountConfirmations = _largeAmountConfirmations;\n        emit ConfirmationsChanged(_smallAmountConfirmations, _mediumAmountConfirmations, _largeAmountConfirmations);\n    }\n\n    function getConfirmations() external view override\n    returns (uint256 smallAmount, uint256 mediumAmount, uint256 largeAmount) {\n        return (smallAmountConfirmations, mediumAmountConfirmations, largeAmountConfirmations);\n    }\n\n}\n"
    },
    "contracts/zeppelin/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\npragma abicoder v2;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/zeppelin/upgradable/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\npragma abicoder v2;\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || !initialized, \"Contract instance is already initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}"
    },
    "contracts/zeppelin/upgradable/ownership/UpgradableOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\npragma abicoder v2;\n\nimport \"../Initializable.sol\";\n\nimport \"../../GSN/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\n * the owner.\n */\ncontract UpgradableOwnable is Initializable, Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function initialize(address sender) public initializer {\n        _owner = sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * > Note: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n\n}\n"
    },
    "contracts/zeppelin/upgradable/ownership/UpgradableSecondary.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\npragma abicoder v2;\n\nimport \"../Initializable.sol\";\n\nimport \"../../GSN/Context.sol\";\n\n/**\n * @dev A Secondary contract can only be used by its primary account (the one that created it).\n */\ncontract UpgradableSecondary is Initializable, Context {\n    address private _primary;\n\n    /**\n     * @dev Emitted when the primary contract changes.\n     */\n    event PrimaryTransferred(\n        address recipient\n    );\n\n    /**\n     * @dev Sets the primary account to the one that is creating the Secondary contract.\n     */\n    function __Secondary_init(address sender) public initializer {\n        _primary = sender;\n        emit PrimaryTransferred(_primary);\n    }\n\n    /**\n     * @dev Reverts if called from any account other than the primary.\n     */\n    modifier onlyPrimary() {\n        require(_msgSender() == _primary, \"Secondary: caller is not the primary account\");\n        _;\n    }\n\n    /**\n     * @return the address of the primary.\n     */\n    function primary() public view returns (address) {\n        return _primary;\n    }\n\n    /**\n     * @dev Transfers contract to a new primary.\n     * @param recipient The address of new primary.\n     */\n    function transferPrimary(address recipient) public onlyPrimary {\n        require(recipient != address(0), \"Secondary: new primary is the zero address\");\n        _primary = recipient;\n        emit PrimaryTransferred(recipient);\n    }\n\n}"
    },
    "contracts/interface/IAllowTokens.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\npragma abicoder v2;\ninterface IAllowTokens {\n\n    struct Limits {\n        uint256 min;\n        uint256 max;\n        uint256 daily;\n        uint256 mediumAmount;\n        uint256 largeAmount;\n    }\n\n    struct TokenInfo {\n        bool allowed;\n        uint256 typeId;\n        uint256 spentToday;\n        uint256 lastDay;\n    }\n\n    struct TypeInfo {\n        string description;\n        Limits limits;\n    }\n\n    struct TokensAndType {\n        address token;\n        uint256 typeId;\n    }\n\n    function version() external pure returns (string memory);\n\n    function getInfoAndLimits(address token) external view returns (TokenInfo memory info, Limits memory limit);\n\n    function calcMaxWithdraw(address token) external view returns (uint256 maxWithdraw);\n\n    function getTypesLimits() external view returns(Limits[] memory limits);\n\n    function getTypeDescriptionsLength() external view returns(uint256);\n\n    function getTypeDescriptions() external view returns(string[] memory descriptions);\n\n    function setToken(address token, uint256 typeId) external;\n\n    function getConfirmations() external view returns (uint256 smallAmount, uint256 mediumAmount, uint256 largeAmount);\n\n    function isTokenAllowed(address token) external view returns (bool);\n\n    function updateTokenTransfer(address token, uint256 amount) external;\n}"
    },
    "contracts/zeppelin/GSN/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\npragma abicoder v2;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract  Context {\n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "contracts/nftbridge/NFTBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\npragma abicoder v2;\n\n// Import base Initializable contract\nimport \"../zeppelin/upgradable/Initializable.sol\";\n// Import interface and library from OpenZeppelin contracts\nimport \"../zeppelin/upgradable/utils/ReentrancyGuard.sol\";\nimport \"../zeppelin/upgradable/lifecycle/UpgradablePausable.sol\";\nimport \"../zeppelin/upgradable/ownership/UpgradableOwnable.sol\";\n\nimport \"../zeppelin/introspection/IERC1820Registry.sol\";\nimport \"../zeppelin/token/ERC20/IERC20.sol\";\nimport \"../zeppelin/token/ERC20/SafeERC20.sol\";\nimport \"../zeppelin/token/ERC721/IERC721.sol\";\nimport \"../zeppelin/token/ERC721/IERC721Metadata.sol\";\nimport \"../zeppelin/token/ERC721/IERC721Enumerable.sol\";\nimport \"../zeppelin/token/ERC721/IERC721Receiver.sol\";\nimport \"../zeppelin/token/ERC721/ERC721Burnable.sol\";\nimport \"../zeppelin/utils/Address.sol\";\nimport \"../zeppelin/math/SafeMath.sol\";\n\nimport \"../lib/LibEIP712.sol\";\nimport \"../lib/LibUtils.sol\";\n\nimport \"./INFTBridge.sol\";\nimport \"./ISideNFTToken.sol\";\nimport \"./ISideNFTTokenFactory.sol\";\nimport \"../interface/IAllowTokens.sol\";\nimport \"../interface/IWrapped.sol\";\n\n// solhint-disable-next-line max-states-count\ncontract NFTBridge is\n  Initializable,\n  INFTBridge,\n  UpgradablePausable,\n  UpgradableOwnable,\n  ReentrancyGuard,\n  IERC721Receiver {\n  using SafeMath for uint256;\n  using SafeERC20 for IERC20;\n  using Address for address;\n\n  address internal constant NULL_ADDRESS = address(0);\n  bytes32 internal constant NULL_HASH = bytes32(0);\n  IERC1820Registry internal constant ERC1820 =\n      IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\n\n  address payable internal federation;\n  uint256 internal fixedFee;\n  string public symbolPrefix;\n\n  mapping(address => address) public sideTokenAddressByOriginalTokenAddress;\n  mapping(address => address) public originalTokenAddressBySideTokenAddress;\n  mapping(address => bool) public isAddressFromCrossedOriginalToken; // address => returns true if it's an original token address crossed previously (whether it comes from main or side chain)\n  mapping(bytes32 => bool) public claimed; // transactionDataHash => true // previously named processed\n  IAllowTokens public allowTokens;\n  ISideNFTTokenFactory public sideTokenFactory;\n  bool public isUpgrading;\n  mapping(bytes32 => bytes32) public transactionDataHashes; // transactionHash => transactionDataHash\n\n  event AllowTokensChanged(address _newAllowTokens);\n  event FederationChanged(address _newFederation);\n  event SideTokenFactoryChanged(address _newSideNFTTokenFactory);\n  event Upgrading(bool _isUpgrading);\n\n  function initialize(\n    address _manager,\n    address payable _federation,\n    address _allowTokens,\n    address _sideTokenFactory,\n    string memory _symbolPrefix\n  ) public initializer {\n    UpgradableOwnable.initialize(_manager);\n    UpgradablePausable.__Pausable_init(_manager);\n    symbolPrefix = _symbolPrefix;\n    allowTokens = IAllowTokens(_allowTokens);\n    sideTokenFactory = ISideNFTTokenFactory(_sideTokenFactory);\n    federation = _federation;\n    ERC1820.setInterfaceImplementer(\n      address(this),\n      0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b,\n      address(this)\n    );\n  }\n\n  function version() external pure override returns (string memory) {\n    return \"v1\";\n  }\n\n  modifier whenNotUpgrading() {\n    require(!isUpgrading, \"Bridge: Upgrading\");\n    _;\n  }\n\n  function acceptTransfer(\n    address _tokenAddress,\n    address payable _from,\n    address payable _to,\n    uint256 _tokenId,\n    bytes32 _blockHash,\n    bytes32 _transactionHash,\n    uint32 _logIndex\n  ) external override whenNotPaused nonReentrant {\n    require(_msgSender() == federation, \"NFTBridge: Not Federation\");\n    require(\n      isAddressFromCrossedOriginalToken[_tokenAddress] ||\n          sideTokenAddressByOriginalTokenAddress[_tokenAddress] != NULL_ADDRESS,\n      \"NFTBridge: Unknown token\"\n    );\n    require(_to != NULL_ADDRESS, \"NFTBridge: Null To\");\n    require(_from != NULL_ADDRESS, \"NFTBridge: Null From\");\n    require(_blockHash != NULL_HASH, \"NFTBridge: Null BlockHash\");\n    require(_transactionHash != NULL_HASH, \"NFTBridge: Null TxHash\");\n    require(\n      transactionDataHashes[_transactionHash] == bytes32(0),\n      \"NFTBridge: Already accepted\"\n    );\n\n    bytes32 _transactionDataHash = getTransactionDataHash(\n      _to,\n      _from,\n      _tokenId,\n      _tokenAddress,\n      _blockHash,\n      _transactionHash,\n      _logIndex\n    );\n    // Do not remove, claimed will also have transactions previously processed using older bridge versions\n    require(!claimed[_transactionDataHash], \"NFTBridge: Already claimed\");\n\n    transactionDataHashes[_transactionHash] = _transactionDataHash;\n//    tokenAddressByTransactionHash[_transactionHash] = _tokenAddress;\n//    senderAddresses[_transactionHash] = _from;\n\n    emit AcceptedNFTCrossTransfer(\n      _transactionHash,\n      _tokenAddress,\n      _to,\n      _from,\n      _tokenId,\n      _blockHash,\n      _logIndex\n    );\n  }\n\n  function createSideNFTToken(\n    address _originalTokenAddress,\n    string calldata _originalTokenSymbol,\n    string calldata _originalTokenName,\n    string calldata _baseURI,\n    string calldata _contractURI\n  ) external onlyOwner {\n    require(_originalTokenAddress != NULL_ADDRESS, \"NFTBridge: Null original token address\");\n    address sideTokenAddress = sideTokenAddressByOriginalTokenAddress[_originalTokenAddress];\n    require(sideTokenAddress == NULL_ADDRESS, \"NFTBridge: Side token already exists\");\n    string memory sideTokenSymbol = string(abi.encodePacked(symbolPrefix, _originalTokenSymbol));\n\n    // Create side token\n    sideTokenAddress = sideTokenFactory.createSideNFTToken(_originalTokenName, sideTokenSymbol, _baseURI, _contractURI);\n\n    sideTokenAddressByOriginalTokenAddress[_originalTokenAddress] = sideTokenAddress;\n    originalTokenAddressBySideTokenAddress[sideTokenAddress] = _originalTokenAddress;\n    emit NewSideNFTToken(sideTokenAddress, _originalTokenAddress, sideTokenSymbol);\n  }\n\n  function claim(NFTClaimData calldata _claimData) external override {\n    _claim(_claimData, _claimData.to);\n  }\n\n  function claimFallback(NFTClaimData calldata _claimData) external override {\n    require(_msgSender() == _claimData.from, \"NFTBridge: invalid sender\");\n    _claim(_claimData, _msgSender());\n  }\n\n  function _claim(\n    NFTClaimData calldata _claimData,\n    address payable _receiver\n  ) internal {\n    address tokenAddress = _claimData.tokenAddress;\n    uint256 tokenId = _claimData.tokenId;\n\n    bytes32 transactionDataHash = getTransactionDataHash(\n      _claimData.to,\n      _claimData.from,\n      tokenId,\n      tokenAddress,\n      _claimData.blockHash,\n      _claimData.transactionHash,\n      _claimData.logIndex\n    );\n    require(\n      transactionDataHashes[_claimData.transactionHash] == transactionDataHash,\n      \"NFTBridge: Wrong txDataHash\"\n    );\n    require(!claimed[transactionDataHash], \"NFTBridge: Already claimed\");\n\n    claimed[transactionDataHash] = true;\n    bool isClaimBeingRequestedInMainChain = isAddressFromCrossedOriginalToken[tokenAddress];\n    if (isClaimBeingRequestedInMainChain) {\n      IERC721(tokenAddress).safeTransferFrom(address(this), _receiver, tokenId);\n    } else {\n      address sideTokenAddress = sideTokenAddressByOriginalTokenAddress[tokenAddress];\n      ISideNFTToken(sideTokenAddress).mint(_receiver, tokenId);\n    }\n\n    emit ClaimedNFTToken(\n      _claimData.transactionHash,\n      tokenAddress,\n      _claimData.to,\n      _claimData.from,\n      _claimData.tokenId,\n      _claimData.blockHash,\n      _claimData.logIndex,\n      _receiver\n    );\n  }\n\n  function getTokenCreator(address tokenAddress, uint256 tokenId) public view returns (address) {\n    (bool success, bytes memory data) = tokenAddress.staticcall(abi.encodeWithSignature(\"creator()\"));\n    if (success) {\n      return abi.decode(data, (address));\n    }\n\n    return IERC721(tokenAddress).ownerOf(tokenId);\n  }\n\n  /**\n    * ERC-20 tokens approve and transferFrom pattern\n    * See https://eips.ethereum.org/EIPS/eip-20#transferfrom\n    */\n  function receiveTokensTo(\n    address tokenAddress,\n    address to,\n    uint256 tokenId\n  ) public payable override {\n    address tokenCreator = getTokenCreator(tokenAddress, tokenId);\n\n    address payable sender = _msgSender();\n    // Transfer the tokens on IERC721, they should be already Approved for the bridge Address to use them\n    IERC721(tokenAddress).transferFrom(sender, address(this), tokenId);\n\n    crossTokens(tokenAddress, to, tokenCreator, \"\", tokenId);\n\n    if (fixedFee > 0) {\n      require(msg.value >= fixedFee, \"NFTBridge: value is smaller than fixed fee\");\n\n      // Send the payment to the MultiSig of the Federation\n      federation.transfer(fixedFee);\n      if (msg.value > fixedFee) { // refund of unused value\n        sender.transfer(msg.value.sub(fixedFee));\n      }\n    }\n  }\n\n  function crossTokens(\n    address tokenAddress,\n    address to,\n    address tokenCreator,\n    bytes memory userData,\n    uint256 tokenId\n  ) internal whenNotUpgrading whenNotPaused nonReentrant {\n    isAddressFromCrossedOriginalToken[tokenAddress] = true;\n\n    IERC721Enumerable enumerable = IERC721Enumerable(tokenAddress);\n    IERC721Metadata metadataIERC = IERC721Metadata(tokenAddress);\n    string memory tokenURI = metadataIERC.tokenURI(tokenId);\n\n    address originalTokenAddress = tokenAddress;\n    if (originalTokenAddressBySideTokenAddress[tokenAddress] != NULL_ADDRESS) {\n      originalTokenAddress = originalTokenAddressBySideTokenAddress[tokenAddress];\n      ERC721Burnable(tokenAddress).burn(tokenId);\n    }\n\n    emit Cross(\n      originalTokenAddress,\n      _msgSender(),\n      to,\n      tokenCreator,\n      userData,\n      enumerable.totalSupply(),\n      tokenId,\n      tokenURI\n    );\n  }\n\n  function getTransactionDataHash(\n    address _to,\n    address _from,\n    uint256 _tokenId,\n    address _tokenAddress,\n    bytes32 _blockHash,\n    bytes32 _transactionHash,\n    uint32 _logIndex\n  ) public pure override returns (bytes32) {\n    return keccak256(\n      abi.encodePacked(\n        _blockHash,\n        _transactionHash,\n        _to,\n        _from,\n        _tokenId,\n        _tokenAddress,\n        _logIndex\n      )\n    );\n  }\n\n  function setFixedFee(uint256 amount) external onlyOwner {\n    fixedFee = amount;\n    emit FixedFeeNFTChanged(fixedFee);\n  }\n\n  function getFixedFee() external view override returns (uint256) {\n    return fixedFee;\n  }\n\n  function changeFederation(address payable newFederation) external onlyOwner {\n    require(newFederation != NULL_ADDRESS, \"NFTBridge: Federation is empty\");\n    federation = newFederation;\n    emit FederationChanged(federation);\n  }\n\n  function changeAllowTokens(address newAllowTokens) external onlyOwner {\n    require(newAllowTokens != NULL_ADDRESS, \"NFTBridge: AllowTokens is empty\");\n    allowTokens = IAllowTokens(newAllowTokens);\n    emit AllowTokensChanged(newAllowTokens);\n  }\n\n  function getFederation() external view returns (address) {\n    return federation;\n  }\n\n  function changeSideTokenFactory(address newSideNFTTokenFactory) external onlyOwner {\n    require(\n      newSideNFTTokenFactory != NULL_ADDRESS,\n      \"NFTBridge: empty SideTokenFactory\"\n    );\n    sideTokenFactory = ISideNFTTokenFactory(newSideNFTTokenFactory);\n    emit SideTokenFactoryChanged(newSideNFTTokenFactory);\n  }\n\n  function setUpgrading(bool _isUpgrading) external onlyOwner {\n    isUpgrading = _isUpgrading;\n    emit Upgrading(isUpgrading);\n  }\n\n  function hasCrossed(bytes32 transactionHash) public view returns (bool) {\n    return transactionDataHashes[transactionHash] != bytes32(0);\n  }\n\n  function hasBeenClaimed(bytes32 transactionHash) public view returns (bool) {\n    return claimed[transactionDataHashes[transactionHash]];\n  }\n\n  /**\n    * Always returns `IERC721Receiver.onERC721Received.selector`.\n    */\n  function onERC721Received(\n    address,\n    address,\n    uint256,\n    bytes memory\n  ) public virtual override returns (bytes4) {\n    return this.onERC721Received.selector;\n  }\n\n}\n"
    },
    "contracts/zeppelin/upgradable/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\npragma abicoder v2;\n\nimport \"../Initializable.sol\";\n\n/**\n * @title Helps contracts guard against reentrancy attacks.\n * @author Remco Bloemen <remco@2π.com>, Eenae <alexey@mixbytes.io>\n * @dev If you mark a function `nonReentrant`, you should also\n * mark it `external`.\n */\ncontract ReentrancyGuard is Initializable {\n    /// @dev counter to allow mutex lock with only one SSTORE operation\n    uint256 private _guardCounter;\n\n    function initialize() public initializer {\n        // The counter starts at one to prevent changing it from zero to a non-zero\n        // value, which is a more expensive operation.\n        _guardCounter = 1;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _guardCounter += 1;\n        uint256 localCounter = _guardCounter;\n        _;\n        require(localCounter == _guardCounter, \"ReentrancyGuard: no reentrant allowed\");\n    }\n}"
    },
    "contracts/zeppelin/upgradable/lifecycle/UpgradablePausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\npragma abicoder v2;\n\nimport \"../Initializable.sol\";\n\nimport \"../../GSN/Context.sol\";\nimport \"../access/roles/UpgradablePauserRole.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\ncontract UpgradablePausable is Initializable, Context, UpgradablePauserRole {\n    /**\n     * @dev Emitted when the pause is triggered by a pauser (`account`).\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by a pauser (`account`).\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state. Assigns the Pauser role\n     * to the deployer.\n     */\n    function __Pausable_init(address sender) public initializer {\n        UpgradablePauserRole.__PauserRol_init(sender);\n\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     */\n    modifier whenNotPaused() {\n        require(!_paused, \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     */\n    modifier whenPaused() {\n        require(_paused, \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Called by a pauser to pause, triggers stopped state.\n     */\n    function pause() public onlyPauser whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Called by a pauser to unpause, returns to normal state.\n     */\n    function unpause() public onlyPauser whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "contracts/zeppelin/introspection/IERC1820Registry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\npragma abicoder v2;\n\n/**\n * @dev Interface of the global ERC1820 Registry, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1820[EIP]. Accounts may register\n * implementers for interfaces in this registry, as well as query support.\n *\n * Implementers may be shared by multiple accounts, and can also implement more\n * than a single interface for each account. Contracts can implement interfaces\n * for themselves, but externally-owned accounts (EOA) must delegate this to a\n * contract.\n *\n * {IERC165} interfaces can also be queried via the registry.\n *\n * For an in-depth explanation and source code analysis, see the EIP text.\n */\ninterface IERC1820Registry {\n    /**\n     * @dev Sets `newManager` as the manager for `account`. A manager of an\n     * account is able to set interface implementers for it.\n     *\n     * By default, each account is its own manager. Passing a value of `0x0` in\n     * `newManager` will reset the manager to this initial state.\n     *\n     * Emits a {ManagerChanged} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the current manager for `account`.\n     */\n    function setManager(address account, address newManager) external;\n\n    /**\n     * @dev Returns the manager for `account`.\n     *\n     * See {setManager}.\n     */\n    function getManager(address account) external view returns (address);\n\n    /**\n     * @dev Sets the `implementer` contract as `account`'s implementer for\n     * `interfaceHash`.\n     *\n     * `account` being the zero address is an alias for the caller's address.\n     * The zero address can also be used in `implementer` to remove an old one.\n     *\n     * See {interfaceHash} to learn how these are created.\n     *\n     * Emits an {InterfaceImplementerSet} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the current manager for `_account`.\n     * - `_interfaceHash` must not be an {IERC165} interface id (i.e. it must not\n     * end in 28 zeroes).\n     * - `_implementer` must implement {IERC1820Implementer} and return true when\n     * queried for support, unless `implementer` is the caller. See\n     * {IERC1820Implementer-canImplementInterfaceForAddress}.\n     */\n    function setInterfaceImplementer(address _account, bytes32 _interfaceHash, address _implementer) external;\n\n    /**\n     * @dev Returns the implementer of `_interfaceHash` for `_account`. If no such\n     * implementer is registered, returns the zero address.\n     *\n     * If `_interfaceHash` is an {IERC165} interface id (i.e. it ends with 28\n     * zeroes), `_account` will be queried for support of it.\n     *\n     * `account` being the zero address is an alias for the caller's address.\n     */\n    function getInterfaceImplementer(address _account, bytes32 _interfaceHash) external view returns (address);\n\n    /**\n     * @dev Returns the interface hash for an `interfaceName`, as defined in the\n     * corresponding\n     * https://eips.ethereum.org/EIPS/eip-1820#interface-name[section of the EIP].\n     */\n    function interfaceHash(string calldata interfaceName) external pure returns (bytes32);\n\n    /**\n     *  @notice Updates the cache with whether the contract implements an ERC165 interface or not.\n     *  @param account Address of the contract for which to update the cache.\n     *  @param interfaceId ERC165 interface for which to update the cache.\n     */\n    function updateERC165Cache(address account, bytes4 interfaceId) external;\n\n    /**\n     *  @notice Checks whether a contract implements an ERC165 interface or not.\n     *  If the result is not cached a direct lookup on the contract address is performed.\n     *  If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling\n     *  {updateERC165Cache} with the contract address.\n     *  @param account Address of the contract to check.\n     *  @param interfaceId ERC165 interface to check.\n     *  @return True if `account` implements `interfaceId`, false otherwise.\n     */\n    function implementsERC165Interface(address account, bytes4 interfaceId) external view returns (bool);\n\n    /**\n     *  @notice Checks whether a contract implements an ERC165 interface or not without using nor updating the cache.\n     *  @param account Address of the contract to check.\n     *  @param interfaceId ERC165 interface to check.\n     *  @return True if `account` implements `interfaceId`, false otherwise.\n     */\n    function implementsERC165InterfaceNoCache(address account, bytes4 interfaceId) external view returns (bool);\n\n    event InterfaceImplementerSet(address indexed account, bytes32 indexed interfaceHash, address indexed implementer);\n\n    event ManagerChanged(address indexed account, address indexed newManager);\n}\n"
    },
    "contracts/zeppelin/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\npragma abicoder v2;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/zeppelin/token/ERC20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\npragma abicoder v2;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve non-zero to non-zero allowance\"\n        );\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves.\n\n        // A Solidity high level call has three parts:\n        //  1. The target address is checked to verify it contains contract code\n        //  2. The call itself is made, and success asserted\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\n        // solhint-disable-next-line max-line-length\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/zeppelin/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"../../introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\n      *\n      * Requirements:\n      *\n      * - `from` cannot be the zero address.\n      * - `to` cannot be the zero address.\n      * - `tokenId` token must exist and be owned by `from`.\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n      *\n      * Emits a {Transfer} event.\n      */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n}\n"
    },
    "contracts/zeppelin/token/ERC721/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"./IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "contracts/zeppelin/token/ERC721/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"./IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "contracts/zeppelin/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\n}\n"
    },
    "contracts/zeppelin/token/ERC721/ERC721Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"../../GSN/Context.sol\";\nimport \"./ERC721.sol\";\n\n/**\n * @title ERC721 Burnable Token\n * @dev ERC721 Token that can be irreversibly burned (destroyed).\n */\nabstract contract ERC721Burnable is Context, ERC721 {\n    /**\n     * @dev Burns `tokenId`. See {ERC721-_burn}.\n     *\n     * Requirements:\n     *\n     * - The caller must own `tokenId` or be an approved operator.\n     */\n    function burn(uint256 tokenId) public virtual {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721Burnable: caller is not owner nor approved\");\n        _burn(tokenId);\n    }\n}\n"
    },
    "contracts/zeppelin/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\npragma abicoder v2;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/lib/LibEIP712.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\npragma abicoder v2;\n\n// https://github.com/0xProject/0x-monorepo/blob/development/contracts/utils/contracts/src/LibEIP712.sol\nlibrary LibEIP712 {\n\n    // Hash of the EIP712 Domain Separator Schema\n    // keccak256(abi.encodePacked(\n    //     \"EIP712Domain(\",\n    //     \"string name,\",\n    //     \"string version,\",\n    //     \"uint256 chainId,\",\n    //     \"address verifyingContract\",\n    //     \")\"\n    // ))\n    bytes32 constant internal _EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\n\n    /// @dev Calculates a EIP712 domain separator.\n    /// @param name The EIP712 domain name.\n    /// @param version The EIP712 domain version.\n    /// @param verifyingContract The EIP712 verifying contract.\n    /// @return result EIP712 domain separator.\n    function hashEIP712Domain(\n        string memory name,\n        string memory version,\n        uint256 chainId,\n        address verifyingContract\n    )\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        bytes32 schemaHash = _EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH;\n\n        // Assembly for more efficient computing:\n        // keccak256(abi.encodePacked(\n        //     _EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH,\n        //     keccak256(bytes(name)),\n        //     keccak256(bytes(version)),\n        //     chainId,\n        //     uint256(verifyingContract)\n        // ))\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            // Calculate hashes of dynamic data\n            let nameHash := keccak256(add(name, 32), mload(name))\n            let versionHash := keccak256(add(version, 32), mload(version))\n\n            // Load free memory pointer\n            let memPtr := mload(64)\n\n            // Store params in memory\n            mstore(memPtr, schemaHash)\n            mstore(add(memPtr, 32), nameHash)\n            mstore(add(memPtr, 64), versionHash)\n            mstore(add(memPtr, 96), chainId)\n            mstore(add(memPtr, 128), verifyingContract)\n\n            // Compute hash\n            result := keccak256(memPtr, 160)\n        }\n        return result;\n    }\n\n    /// @dev Calculates EIP712 encoding for a hash struct with a given domain hash.\n    /// @param eip712DomainHash Hash of the domain domain separator data, computed\n    ///                         with getDomainHash().\n    /// @param hashStruct The EIP712 hash struct.\n    /// @return result EIP712 hash applied to the given EIP712 Domain.\n    function hashEIP712Message(bytes32 eip712DomainHash, bytes32 hashStruct)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        // Assembly for more efficient computing:\n        // keccak256(abi.encodePacked(\n        //     EIP191_HEADER,\n        //     EIP712_DOMAIN_HASH,\n        //     hashStruct\n        // ));\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            // Load free memory pointer\n            let memPtr := mload(64)\n\n            mstore(memPtr, 0x1901000000000000000000000000000000000000000000000000000000000000)  // EIP191 header\n            mstore(add(memPtr, 2), eip712DomainHash)                                            // EIP712 domain hash\n            mstore(add(memPtr, 34), hashStruct)                                                 // Hash of struct\n\n            // Compute hash\n            result := keccak256(memPtr, 66)\n        }\n        return result;\n    }\n}"
    },
    "contracts/lib/LibUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\npragma abicoder v2;\n\nlibrary LibUtils {\n\n    function decimalsToGranularity(uint8 decimals) internal pure returns (uint256) {\n        require(decimals <= 18, \"LibUtils: Decimals not <= 18\");\n        return uint256(10)**(18-decimals);\n    }\n\n    function getDecimals(address tokenToUse) internal view returns (uint8) {\n        //support decimals as uint256 or uint8\n        (bool success, bytes memory data) = tokenToUse.staticcall(abi.encodeWithSignature(\"decimals()\"));\n        require(success, \"LibUtils: No decimals\");\n        // uint<M>: enc(X) is the big-endian encoding of X,\n        //padded on the higher-order (left) side with zero-bytes such that the length is 32 bytes.\n        return uint8(abi.decode(data, (uint256)));\n    }\n\n    function getGranularity(address tokenToUse) internal view returns (uint256) {\n        //support granularity if ERC777\n        (bool success, bytes memory data) = tokenToUse.staticcall(abi.encodeWithSignature(\"granularity()\"));\n        require(success, \"LibUtils: No granularity\");\n\n        return abi.decode(data, (uint256));\n    }\n\n    function bytesToAddress(bytes memory bys) internal pure returns (address addr) {\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            addr := mload(add(bys,20))\n        }\n    }\n\n}\n"
    },
    "contracts/nftbridge/INFTBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\npragma abicoder v2;\n\ninterface INFTBridge {\n  struct NFTClaimData {\n    address payable to;\n    address from;\n    uint256 tokenId;\n    address tokenAddress;\n    bytes32 blockHash;\n    bytes32 transactionHash;\n    uint32 logIndex;\n  }\n\n  function version() external pure returns (string memory);\n\n  function getFixedFee() external view returns (uint256);\n\n  function receiveTokensTo(\n    address tokenAddress,\n    address to,\n    uint256 tokenId\n  ) external payable;\n\n  /**\n    * Accepts the transaction from the other chain that was voted and sent by the Federation contract\n    */\n  function acceptTransfer(\n    address _originalTokenAddress,\n    address payable _from,\n    address payable _to,\n    uint256 _tokenId,\n    bytes32 _blockHash,\n    bytes32 _transactionHash,\n    uint32 _logIndex\n  ) external;\n\n  /**\n    * Claims the crossed transaction using the hash, this sends the token to the address specified in the claim data\n    */\n  function claim(NFTClaimData calldata _claimData) external;\n\n  function claimFallback(NFTClaimData calldata _claimData) external;\n\n  function getTransactionDataHash(\n    address _to,\n    address _from,\n    uint256 _tokenId,\n    address _tokenAddress,\n    bytes32 _blockHash,\n    bytes32 _transactionHash,\n    uint32 _logIndex\n  ) external returns (bytes32);\n\n  event Cross(\n    address indexed _originalTokenAddress,\n    address indexed _from,\n    address indexed _to,\n    address _tokenCreator,\n    bytes _userData,\n    uint256 _totalSupply,\n    uint256 _tokenId,\n    string _tokenURI\n  );\n  event NewSideNFTToken(\n    address indexed _newSideNFTTokenAddress,\n    address indexed _originalTokenAddress,\n    string _newSymbol\n  );\n  event AcceptedNFTCrossTransfer(\n    bytes32 indexed _transactionHash,\n    address indexed _originalTokenAddress,\n    address indexed _to,\n    address _from,\n    uint256 _tokenId,\n    bytes32 _blockHash,\n    uint256 _logIndex\n  );\n  event FixedFeeNFTChanged(uint256 _amount);\n  event ClaimedNFTToken(\n    bytes32 indexed _transactionHash,\n    address indexed _originalTokenAddress,\n    address indexed _to,\n    address _sender,\n    uint256 _tokenId,\n    bytes32 _blockHash,\n    uint256 _logIndex,\n    address _receiver\n  );\n}\n"
    },
    "contracts/nftbridge/ISideNFTToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\ninterface ISideNFTToken {\n  function mint(address account, uint256 tokenId) external;\n}"
    },
    "contracts/nftbridge/ISideNFTTokenFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\ninterface ISideNFTTokenFactory {\n\n    function createSideNFTToken(string calldata name, string calldata symbol, string calldata baseURI,\n        string calldata contractURI) external returns(address);\n\n    event SideNFTTokenCreated(address indexed sideTokenAddress, string symbol, string baseURI, string contractURI);\n}"
    },
    "contracts/interface/IWrapped.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\npragma abicoder v2;\ninterface IWrapped {\n    function balanceOf(address) external returns(uint);\n\n    function deposit() external payable;\n\n    function withdraw(uint wad) external;\n\n    function totalSupply() external view returns (uint);\n\n    function approve(address guy, uint wad) external returns (bool);\n\n    function transfer(address dst, uint wad) external returns (bool);\n\n    function transferFrom(address src, address dst, uint wad)\n        external\n        returns (bool);\n}"
    },
    "contracts/zeppelin/upgradable/access/roles/UpgradablePauserRole.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\npragma abicoder v2;\n\nimport \"../../Initializable.sol\";\n\nimport \"../../../GSN/Context.sol\";\nimport \"../../../access/Roles.sol\";\n\ncontract UpgradablePauserRole is Initializable, Context {\n    using Roles for Roles.Role;\n\n    event PauserAdded(address indexed account);\n    event PauserRemoved(address indexed account);\n\n    Roles.Role private _pausers;\n\n    function __PauserRol_init(address sender) public initializer {\n        if (!isPauser(sender)) {\n            _addPauser(sender);\n        }\n    }\n\n    modifier onlyPauser() {\n        require(isPauser(_msgSender()), \"PauserRole: caller doesn't have the role\");\n        _;\n    }\n\n    function isPauser(address account) public view returns (bool) {\n        return _pausers.has(account);\n    }\n\n    function addPauser(address account) public onlyPauser {\n        _addPauser(account);\n    }\n\n    function renouncePauser() public {\n        _removePauser(_msgSender());\n    }\n\n    function _addPauser(address account) internal {\n        _pausers.add(account);\n        emit PauserAdded(account);\n    }\n\n    function _removePauser(address account) internal {\n        _pausers.remove(account);\n        emit PauserRemoved(account);\n    }\n}\n"
    },
    "contracts/zeppelin/access/Roles.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\npragma abicoder v2;\n\n/**\n * @title Roles\n * @dev Library for managing addresses assigned to a Role.\n */\nlibrary Roles {\n    struct Role {\n        mapping (address => bool) bearer;\n    }\n\n    /**\n     * @dev Give an account access to this role.\n     */\n    function add(Role storage role, address account) internal {\n        require(!has(role, account), \"Roles: account already has role\");\n        role.bearer[account] = true;\n    }\n\n    /**\n     * @dev Remove an account's access to this role.\n     */\n    function remove(Role storage role, address account) internal {\n        require(has(role, account), \"Roles: account doesn't have role\");\n        role.bearer[account] = false;\n    }\n\n    /**\n     * @dev Check if an account has this role.\n     * @return bool\n     */\n    function has(Role storage role, address account) internal view returns (bool) {\n        require(account != address(0), \"Roles: account is the zero address\");\n        return role.bearer[account];\n    }\n}\n"
    },
    "contracts/zeppelin/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/zeppelin/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"../../GSN/Context.sol\";\nimport \"./IERC721.sol\";\nimport \"./IERC721Metadata.sol\";\nimport \"./IERC721Enumerable.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"../../introspection/ERC165.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/EnumerableSet.sol\";\nimport \"../../utils/EnumerableMap.sol\";\nimport \"../../utils/Strings.sol\";\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic implementation\n * @dev see https://eips.ethereum.org/EIPS/eip-721\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata, IERC721Enumerable {\n    using SafeMath for uint256;\n    using Address for address;\n    using EnumerableSet for EnumerableSet.UintSet;\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n    using Strings for uint256;\n\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n\n    // Mapping from holder address to their (enumerable) set of owned tokens\n    mapping (address => EnumerableSet.UintSet) private _holderTokens;\n\n    // Enumerable mapping from token ids to their owners\n    EnumerableMap.UintToAddressMap private _tokenOwners;\n\n    // Mapping from token ID to approved address\n    mapping (uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Optional mapping for token URIs\n    mapping (uint256 => string) private _tokenURIs;\n\n    // Base URI\n    string private _baseURI;\n\n    /*\n     *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231\n     *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e\n     *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3\n     *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde\n     *\n     *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\n     *        0xa22cb465 ^ 0xe985e9c5 ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n\n    /*\n     *     bytes4(keccak256('name()')) == 0x06fdde03\n     *     bytes4(keccak256('symbol()')) == 0x95d89b41\n     *     bytes4(keccak256('tokenURI(uint256)')) == 0xc87b56dd\n     *\n     *     => 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\n\n    /*\n     *     bytes4(keccak256('totalSupply()')) == 0x18160ddd\n     *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) == 0x2f745c59\n     *     bytes4(keccak256('tokenByIndex(uint256)')) == 0x4f6ccce7\n     *\n     *     => 0x18160ddd ^ 0x2f745c59 ^ 0x4f6ccce7 == 0x780e9d63\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor (string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n\n        // register the supported interfaces to conform to ERC721 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721);\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\n        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _holderTokens[owner].length();\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        return _tokenOwners.get(tokenId, \"ERC721: owner query for nonexistent token\");\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory _tokenURI = _tokenURIs[tokenId];\n        string memory base = baseURI();\n\n        // If there is no base URI, return the token URI.\n        if (bytes(base).length == 0) {\n            return _tokenURI;\n        }\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\n        if (bytes(_tokenURI).length > 0) {\n            return string(abi.encodePacked(base, _tokenURI));\n        }\n        // If there is a baseURI but no tokenURI, concatenate the tokenID to the baseURI.\n        return string(abi.encodePacked(base, tokenId.toString()));\n    }\n\n    /**\n    * @dev Returns the base URI set via {_setBaseURI}. This will be\n    * automatically added as a prefix in {tokenURI} to each token's URI, or\n    * to the token ID if no specific URI is set for that token ID.\n    */\n    function baseURI() public view virtual returns (string memory) {\n        return _baseURI;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        return _holderTokens[owner].at(index);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        // _tokenOwners are indexed by tokenIds, so .length() returns the number of tokenIds\n        return _tokenOwners.length();\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        (uint256 tokenId, ) = _tokenOwners.at(index);\n        return tokenId;\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(_msgSender() == owner || ERC721.isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(operator != _msgSender(), \"ERC721: approve to caller\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _tokenOwners.contains(tokenId);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || ERC721.isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     d*\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {\n        _mint(to, tokenId);\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _holderTokens[to].add(tokenId);\n\n        _tokenOwners.set(tokenId, to);\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId); // internal owner\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        // Clear metadata (if any)\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n\n        _holderTokens[owner].remove(tokenId);\n\n        _tokenOwners.remove(tokenId);\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\"); // internal owner\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _holderTokens[from].remove(tokenId);\n        _holderTokens[to].add(tokenId);\n\n        _tokenOwners.set(tokenId, to);\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n        require(_exists(tokenId), \"ERC721Metadata: URI set of nonexistent token\");\n        _tokenURIs[tokenId] = _tokenURI;\n    }\n\n    /**\n     * @dev Internal function to set the base URI for all token IDs. It is\n     * automatically added as a prefix to the value returned in {tokenURI},\n     * or to the token ID if {tokenURI} is empty.\n     */\n    function _setBaseURI(string memory baseURI_) internal virtual {\n        _baseURI = baseURI_;\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n        private returns (bool)\n    {\n        if (!to.isContract()) {\n            return true;\n        }\n        bytes memory returndata = to.functionCall(abi.encodeWithSelector(\n            IERC721Receiver(to).onERC721Received.selector,\n            _msgSender(),\n            from,\n            tokenId,\n            _data\n        ), \"ERC721: transfer to non ERC721Receiver implementer\");\n        bytes4 retval = abi.decode(returndata, (bytes4));\n        return (retval == _ERC721_RECEIVED);\n    }\n\n    function _approve(address to, uint256 tokenId) private {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId); // internal owner\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual { }\n}\n"
    },
    "contracts/zeppelin/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts may inherit from this and call {_registerInterface} to declare\n * their support of an interface.\n */\nabstract contract ERC165 is IERC165 {\n    /*\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\n     */\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n\n    /**\n     * @dev Mapping of interface ids to whether or not it's supported.\n     */\n    mapping(bytes4 => bool) private _supportedInterfaces;\n\n    constructor () {\n        // Derived contracts need only register support for their own interfaces,\n        // we register support for ERC165 itself here\n        _registerInterface(_INTERFACE_ID_ERC165);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     *\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @dev Registers the contract as an implementer of the interface defined by\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\n     * registering its interface id is not required.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * Requirements:\n     *\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\n     */\n    function _registerInterface(bytes4 interfaceId) internal virtual {\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n        _supportedInterfaces[interfaceId] = true;\n    }\n}\n"
    },
    "contracts/zeppelin/utils/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n"
    },
    "contracts/zeppelin/utils/EnumerableMap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * As of v3.0.0, only maps of type `uint256 -> address` (`UintToAddressMap`) are\n * supported.\n */\nlibrary EnumerableMap {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Map type with\n    // bytes32 keys and values.\n    // The Map implementation uses private functions, and user-facing\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\n    // the underlying Map.\n    // This means that we can only create new EnumerableMaps for types that fit\n    // in bytes32.\n\n    struct MapEntry {\n        bytes32 _key;\n        bytes32 _value;\n    }\n\n    struct Map {\n        // Storage of map keys and values\n        MapEntry[] _entries;\n\n        // Position of the entry defined by a key in the `entries` array, plus 1\n        // because index 0 means a key is not in the map.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function _set(Map storage map, bytes32 key, bytes32 value) private returns (bool) {\n        // We read and store the key's index to prevent multiple reads from the same storage slot\n        uint256 keyIndex = map._indexes[key];\n\n        if (keyIndex == 0) { // Equivalent to !contains(map, key)\n            map._entries.push(MapEntry({ _key: key, _value: value }));\n            // The entry is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            map._indexes[key] = map._entries.length;\n            return true;\n        } else {\n            map._entries[keyIndex - 1]._value = value;\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\n        // We read and store the key's index to prevent multiple reads from the same storage slot\n        uint256 keyIndex = map._indexes[key];\n\n        if (keyIndex != 0) { // Equivalent to contains(map, key)\n            // To delete a key-value pair from the _entries array in O(1), we swap the entry to delete with the last one\n            // in the array, and then remove the last entry (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = keyIndex - 1;\n            uint256 lastIndex = map._entries.length - 1;\n\n            // When the entry to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            MapEntry storage lastEntry = map._entries[lastIndex];\n\n            // Move the last entry to the index where the entry to delete is\n            map._entries[toDeleteIndex] = lastEntry;\n            // Update the index for the moved entry\n            map._indexes[lastEntry._key] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved entry was stored\n            map._entries.pop();\n\n            // Delete the index for the deleted slot\n            delete map._indexes[key];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function _contains(Map storage map, bytes32 key) private view returns (bool) {\n        return map._indexes[key] != 0;\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function _length(Map storage map) private view returns (uint256) {\n        return map._entries.length;\n    }\n\n   /**\n    * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n    *\n    * Note that there are no guarantees on the ordering of entries inside the\n    * array, and it may change when more entries are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {\n        require(map._entries.length > index, \"EnumerableMap: index out of bounds\");\n\n        MapEntry storage entry = map._entries[index];\n        return (entry._key, entry._value);\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function _tryGet(Map storage map, bytes32 key) private view returns (bool, bytes32) {\n        uint256 keyIndex = map._indexes[key];\n        if (keyIndex == 0) return (false, 0); // Equivalent to contains(map, key)\n        return (true, map._entries[keyIndex - 1]._value); // All indexes are 1-based\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\n        uint256 keyIndex = map._indexes[key];\n        require(keyIndex != 0, \"EnumerableMap: nonexistent key\"); // Equivalent to contains(map, key)\n        return map._entries[keyIndex - 1]._value; // All indexes are 1-based\n    }\n\n    /**\n     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {_tryGet}.\n     */\n    function _get(Map storage map, bytes32 key, string memory errorMessage) private view returns (bytes32) {\n        uint256 keyIndex = map._indexes[key];\n        require(keyIndex != 0, errorMessage); // Equivalent to contains(map, key)\n        return map._entries[keyIndex - 1]._value; // All indexes are 1-based\n    }\n\n    // UintToAddressMap\n\n    struct UintToAddressMap {\n        Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\n        return _set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n        return _remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return _contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\n        return _length(map._inner);\n    }\n\n   /**\n    * @dev Returns the element stored at position `index` in the set. O(1).\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\n        return (uint256(key), address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     *\n     * _Available since v3.4._\n     */\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\n        (bool success, bytes32 value) = _tryGet(map._inner, bytes32(key));\n        return (success, address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key)))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(UintToAddressMap storage map, uint256 key, string memory errorMessage) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key), errorMessage))));\n    }\n}\n"
    },
    "contracts/zeppelin/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        uint256 index = digits - 1;\n        temp = value;\n        while (temp != 0) {\n            buffer[index--] = bytes1(uint8(48 + temp % 10));\n            temp /= 10;\n        }\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/test/WRBTC.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"../interface/IWrapped.sol\";\n\ncontract WRBTC is IWrapped {\n    string public name     = \"Wrapped RBTC\";\n    string public symbol   = \"WRBTC\";\n    uint8  public decimals = 18;\n\n    event  Approval(address indexed src, address indexed guy, uint wad);\n    event  Transfer(address indexed src, address indexed dst, uint wad);\n    event  Deposit(address indexed dst, uint wad);\n    event  Withdrawal(address indexed src, uint wad);\n\n    mapping (address => uint) override public balanceOf;\n    mapping (address => mapping (address => uint)) public allowance;\n\n    receive () external payable {\n        deposit();\n    }\n    function deposit() override public payable {\n        balanceOf[msg.sender] += msg.value;\n        emit Deposit(msg.sender, msg.value);\n    }\n    function withdraw(uint wad) override public {\n        require(balanceOf[msg.sender] >= wad, \"WRBTC: Balance less than wad\");\n        balanceOf[msg.sender] -= wad;\n        msg.sender.transfer(wad);\n        emit Withdrawal(msg.sender, wad);\n    }\n\n    function totalSupply() override public view returns (uint) {\n        return address(this).balance;\n    }\n\n    function approve(address guy, uint wad) override public returns (bool) {\n        allowance[msg.sender][guy] = wad;\n        emit Approval(msg.sender, guy, wad);\n        return true;\n    }\n\n    function transfer(address dst, uint wad) override public returns (bool) {\n        return transferFrom(msg.sender, dst, wad);\n    }\n\n    function transferFrom(address src, address dst, uint wad)\n        override public\n        returns (bool)\n    {\n        require(balanceOf[src] >= wad, \"WRBTC: Balance less than wad\");\n\n        if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {\n            require(allowance[src][msg.sender] >= wad, \"WRBTC: Allowance less than wad\");\n            allowance[src][msg.sender] -= wad;\n        }\n\n        balanceOf[src] -= wad;\n        balanceOf[dst] += wad;\n\n        emit Transfer(src, dst, wad);\n\n        return true;\n    }\n}"
    },
    "contracts/Bridge/Bridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\npragma abicoder v2;\n\n// Import base Initializable contract\nimport \"../zeppelin/upgradable/Initializable.sol\";\n// Import interface and library from OpenZeppelin contracts\nimport \"../zeppelin/upgradable/utils/ReentrancyGuard.sol\";\nimport \"../zeppelin/upgradable/lifecycle/UpgradablePausable.sol\";\nimport \"../zeppelin/upgradable/ownership/UpgradableOwnable.sol\";\n\nimport \"../zeppelin/introspection/IERC1820Registry.sol\";\nimport \"../zeppelin/token/ERC777/IERC777Recipient.sol\";\nimport \"../zeppelin/token/ERC20/IERC20.sol\";\nimport \"../zeppelin/token/ERC20/SafeERC20.sol\";\nimport \"../zeppelin/utils/Address.sol\";\nimport \"../zeppelin/math/SafeMath.sol\";\nimport \"../zeppelin/token/ERC777/IERC777.sol\";\n\nimport \"../lib/LibEIP712.sol\";\nimport \"../lib/LibUtils.sol\";\n\nimport \"../interface/IBridge.sol\";\nimport \"../interface/ISideToken.sol\";\nimport \"../interface/ISideTokenFactory.sol\";\nimport \"../interface/IAllowTokens.sol\";\nimport \"../interface/IWrapped.sol\";\n\n// solhint-disable-next-line max-states-count\ncontract Bridge is Initializable, IBridge, IERC777Recipient, UpgradablePausable, UpgradableOwnable, ReentrancyGuard {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    using Address for address;\n\n    address constant internal NULL_ADDRESS = address(0);\n    bytes32 constant internal NULL_HASH = bytes32(0);\n    IERC1820Registry constant internal ERC1820 = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\n\n    address internal federation;\n    uint256 internal feePercentage;\n    string public symbolPrefix;\n    // replaces uint256 internal _depprecatedLastDay;\n    bytes32 public domainSeparator;\n    uint256 internal _deprecatedSpentToday;\n\n    mapping (address => address) public mappedTokens; // OirignalToken => SideToken\n    mapping (address => address) public originalTokens; // SideToken => OriginalToken\n    mapping (address => bool) public knownTokens; // OriginalToken => true\n    mapping (bytes32 => bool) public claimed; // transactionDataHash => true // previously named processed\n    IAllowTokens public allowTokens;\n    ISideTokenFactory public sideTokenFactory;\n    //Bridge_v1 variables\n    bool public isUpgrading;\n    // Percentage with up to 2 decimals\n    uint256 constant public feePercentageDivider = 10000; // solhint-disable-line const-name-snakecase\n    //Bridge_v3 variables\n    bytes32 constant internal _erc777Interface = keccak256(\"ERC777Token\"); // solhint-disable-line const-name-snakecase\n    IWrapped public wrappedCurrency;\n    mapping (bytes32 => bytes32) public transactionsDataHashes; // transactionHash => transactionDataHash\n    mapping (bytes32 => address) public originalTokenAddresses; // transactionHash => originalTokenAddress\n    mapping (bytes32 => address) public senderAddresses; // transactionHash => senderAddress\n\n    // keccak256(\"Claim(address to,uint256 amount,bytes32 transactionHash,address relayer,uint256 fee,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant CLAIM_TYPEHASH = 0xf18ceda3f6355f78c234feba066041a50f6557bfb600201e2a71a89e2dd80433;\n    mapping(address => uint) public nonces;\n\n    event AllowTokensChanged(address _newAllowTokens);\n    event FederationChanged(address _newFederation);\n    event SideTokenFactoryChanged(address _newSideTokenFactory);\n    event Upgrading(bool _isUpgrading);\n    event WrappedCurrencyChanged(address _wrappedCurrency);\n\n    function initialize(\n        address _manager,\n        address _federation,\n        address _allowTokens,\n        address _sideTokenFactory,\n        string memory _symbolPrefix\n    ) public initializer {\n        UpgradableOwnable.initialize(_manager);\n        UpgradablePausable.__Pausable_init(_manager);\n        symbolPrefix = _symbolPrefix;\n        allowTokens = IAllowTokens(_allowTokens);\n        sideTokenFactory = ISideTokenFactory(_sideTokenFactory);\n        federation = _federation;\n        //keccak256(\"ERC777TokensRecipient\")\n        ERC1820.setInterfaceImplementer(address(this), 0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b, address(this));\n        initDomainSeparator();\n    }\n\n    receive () external payable {\n        // The fallback function is needed to use WRBTC\n        require(_msgSender() == address(wrappedCurrency), \"Bridge: not wrappedCurrency\");\n    }\n\n    function version() override external pure returns (string memory) {\n        return \"v3\";\n    }\n\n    function initDomainSeparator() public {\n        uint chainId;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            chainId := chainid()\n        }\n        domainSeparator = LibEIP712.hashEIP712Domain(\n            \"RSK Token Bridge\",\n            \"1\",\n            chainId,\n            address(this)\n        );\n    }\n\n    modifier whenNotUpgrading() {\n        require(!isUpgrading, \"Bridge: Upgrading\");\n        _;\n    }\n\n    function acceptTransfer(\n        address _originalTokenAddress,\n        address payable _from,\n        address payable _to,\n        uint256 _amount,\n        bytes32 _blockHash,\n        bytes32 _transactionHash,\n        uint32 _logIndex\n    ) external whenNotPaused nonReentrant override {\n        require(_msgSender() == federation, \"Bridge: Not Federation\");\n        require(knownTokens[_originalTokenAddress] ||\n            mappedTokens[_originalTokenAddress] != NULL_ADDRESS,\n            \"Bridge: Unknown token\"\n        );\n        require(_to != NULL_ADDRESS, \"Bridge: Null To\");\n        require(_amount > 0, \"Bridge: Amount 0\");\n        require(_blockHash != NULL_HASH, \"Bridge: Null BlockHash\");\n        require(_transactionHash != NULL_HASH, \"Bridge: Null TxHash\");\n        require(transactionsDataHashes[_transactionHash] == bytes32(0), \"Bridge: Already accepted\");\n\n        bytes32 _transactionDataHash = getTransactionDataHash(\n            _to,\n            _amount,\n            _blockHash,\n            _transactionHash,\n            _logIndex\n        );\n        // Do not remove, claimed also has the previously processed using the older bridge version\n        // https://github.com/rsksmart/tokenbridge/blob/TOKENBRIDGE-1.2.0/bridge/contracts/Bridge.sol#L41\n        require(!claimed[_transactionDataHash], \"Bridge: Already claimed\");\n\n        transactionsDataHashes[_transactionHash] = _transactionDataHash;\n        originalTokenAddresses[_transactionHash] = _originalTokenAddress;\n        senderAddresses[_transactionHash] = _from;\n\n        emit AcceptedCrossTransfer(\n            _transactionHash,\n            _originalTokenAddress,\n            _to,\n            _from,\n            _amount,\n            _blockHash,\n            _logIndex\n        );\n    }\n\n\n    function createSideToken(\n        uint256 _typeId,\n        address _originalTokenAddress,\n        uint8 _originalTokenDecimals,\n        string calldata _originalTokenSymbol,\n        string calldata _originalTokenName\n    ) external onlyOwner {\n        require(_originalTokenAddress != NULL_ADDRESS, \"Bridge: Null token\");\n        address sideToken = mappedTokens[_originalTokenAddress];\n        require(sideToken == NULL_ADDRESS, \"Bridge: Already exists\");\n        uint256 granularity = LibUtils.decimalsToGranularity(_originalTokenDecimals);\n        string memory newSymbol = string(abi.encodePacked(symbolPrefix, _originalTokenSymbol));\n\n        // Create side token\n        sideToken = sideTokenFactory.createSideToken(_originalTokenName, newSymbol, granularity);\n\n        mappedTokens[_originalTokenAddress] = sideToken;\n        originalTokens[sideToken] = _originalTokenAddress;\n        allowTokens.setToken(sideToken, _typeId);\n\n        emit NewSideToken(sideToken, _originalTokenAddress, newSymbol, granularity);\n    }\n\n    function claim(ClaimData calldata _claimData)\n    external override returns (uint256 receivedAmount) {\n\n        receivedAmount = _claim(\n            _claimData,\n            _claimData.to,\n            payable(address(0)),\n            0\n        );\n        return receivedAmount;\n    }\n\n    function claimFallback(ClaimData calldata _claimData)\n    external override returns (uint256 receivedAmount) {\n        require(_msgSender() == senderAddresses[_claimData.transactionHash],\"Bridge: invalid sender\");\n        receivedAmount = _claim(\n            _claimData,\n            _msgSender(),\n            payable(address(0)),\n            0\n        );\n        return receivedAmount;\n    }\n\n    function getDigest(\n        ClaimData memory _claimData,\n        address payable _relayer,\n        uint256 _fee,\n        uint256 _deadline\n    ) internal returns (bytes32) {\n        return LibEIP712.hashEIP712Message(\n            domainSeparator,\n            keccak256(\n                abi.encode(\n                    CLAIM_TYPEHASH,\n                    _claimData.to,\n                    _claimData.amount,\n                    _claimData.transactionHash,\n                    _relayer,\n                    _fee,\n                    nonces[_claimData.to]++,\n                    _deadline\n                )\n            )\n        );\n    }\n\n    // Inspired by https://github.com/dapphub/ds-dach/blob/master/src/dach.sol\n    function claimGasless(\n        ClaimData calldata _claimData,\n        address payable _relayer,\n        uint256 _fee,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external override returns (uint256 receivedAmount) {\n        require(_deadline >= block.timestamp, \"Bridge: EXPIRED\"); // solhint-disable-line not-rely-on-time\n\n        bytes32 digest = getDigest(_claimData, _relayer, _fee, _deadline);\n        address recoveredAddress = ecrecover(digest, _v, _r, _s);\n        require(_claimData.to != address(0) && recoveredAddress == _claimData.to, \"Bridge: INVALID_SIGNATURE\");\n\n        receivedAmount = _claim(\n            _claimData,\n            _claimData.to,\n            _relayer,\n            _fee\n        );\n        return receivedAmount;\n    }\n\n    function _claim(\n        ClaimData calldata _claimData,\n        address payable _reciever,\n        address payable _relayer,\n        uint256 _fee\n    ) internal nonReentrant returns (uint256 receivedAmount) {\n        address originalTokenAddress = originalTokenAddresses[_claimData.transactionHash];\n        require(originalTokenAddress != NULL_ADDRESS, \"Bridge: Tx not crossed\");\n\n        bytes32 transactionDataHash = getTransactionDataHash(\n            _claimData.to,\n            _claimData.amount,\n            _claimData.blockHash,\n            _claimData.transactionHash,\n            _claimData.logIndex\n        );\n        require(transactionsDataHashes[_claimData.transactionHash] == transactionDataHash, \"Bridge: Wrong transactionDataHash\");\n        require(!claimed[transactionDataHash], \"Bridge: Already claimed\");\n\n        claimed[transactionDataHash] = true;\n        if (knownTokens[originalTokenAddress]) {\n            receivedAmount =_claimCrossBackToToken(\n                originalTokenAddress,\n                _reciever,\n                _claimData.amount,\n                _relayer,\n                _fee\n            );\n        } else {\n            receivedAmount =_claimCrossToSideToken(\n                originalTokenAddress,\n                _reciever,\n                _claimData.amount,\n                _relayer,\n                _fee\n            );\n        }\n        emit Claimed(\n            _claimData.transactionHash,\n            originalTokenAddress,\n            _claimData.to,\n            senderAddresses[_claimData.transactionHash],\n            _claimData.amount,\n            _claimData.blockHash,\n            _claimData.logIndex,\n            _reciever,\n            _relayer,\n            _fee\n        );\n        return receivedAmount;\n    }\n\n    function _claimCrossToSideToken(\n        address _originalTokenAddress,\n        address payable _receiver,\n        uint256 _amount,\n        address payable _relayer,\n        uint256 _fee\n    ) internal returns (uint256 receivedAmount) {\n        address sideToken = mappedTokens[_originalTokenAddress];\n        uint256 granularity = IERC777(sideToken).granularity();\n        uint256 formattedAmount = _amount.mul(granularity);\n        require(_fee <= formattedAmount, \"Bridge: fee too high\");\n        receivedAmount = formattedAmount - _fee;\n        ISideToken(sideToken).mint(_receiver, receivedAmount, \"\", \"\");\n        if(_fee > 0) {\n            ISideToken(sideToken).mint(_relayer, _fee, \"\", \"relayer fee\");\n        }\n        return receivedAmount;\n    }\n\n    function _claimCrossBackToToken(\n        address _originalTokenAddress,\n        address payable _receiver,\n        uint256 _amount,\n        address payable _relayer,\n        uint256 _fee\n    ) internal returns (uint256 receivedAmount) {\n        uint256 decimals = LibUtils.getDecimals(_originalTokenAddress);\n        //As side tokens are ERC777 they will always have 18 decimals\n        uint256 formattedAmount = _amount.div(uint256(10) ** (18 - decimals));\n        require(_fee <= formattedAmount, \"Bridge: fee too high\");\n        receivedAmount = formattedAmount - _fee;\n        if(address(wrappedCurrency) == _originalTokenAddress) {\n            wrappedCurrency.withdraw(formattedAmount);\n            _receiver.transfer(receivedAmount);\n            if(_fee > 0) {\n                _relayer.transfer(_fee);\n            }\n        } else {\n            IERC20(_originalTokenAddress).safeTransfer(_receiver, receivedAmount);\n            if(_fee > 0) {\n                IERC20(_originalTokenAddress).safeTransfer(_relayer, _fee);\n            }\n        }\n        return receivedAmount;\n    }\n\n    /**\n     * ERC-20 tokens approve and transferFrom pattern\n     * See https://eips.ethereum.org/EIPS/eip-20#transferfrom\n     */\n    function receiveTokensTo(address tokenToUse, address to, uint256 amount) override public {\n        address sender = _msgSender();\n        //Transfer the tokens on IERC20, they should be already Approved for the bridge Address to use them\n        IERC20(tokenToUse).safeTransferFrom(sender, address(this), amount);\n        crossTokens(tokenToUse, sender, to, amount, \"\");\n    }\n\n    /**\n     * Use network currency and cross it.\n     */\n    function depositTo(address to) override external payable {\n        address sender = _msgSender();\n        require(address(wrappedCurrency) != NULL_ADDRESS, \"Bridge: wrappedCurrency empty\");\n        wrappedCurrency.deposit{ value: msg.value }();\n        crossTokens(address(wrappedCurrency), sender, to, msg.value, \"\");\n    }\n\n    /**\n     * ERC-777 tokensReceived hook allows to send tokens to a contract and notify it in a single transaction\n     * See https://eips.ethereum.org/EIPS/eip-777#motivation for details\n     */\n    function tokensReceived (\n        address operator,\n        address from,\n        address to,\n        uint amount,\n        bytes calldata userData,\n        bytes calldata\n    ) external override(IBridge, IERC777Recipient){\n        //Hook from ERC777address\n        if(operator == address(this)) return; // Avoid loop from bridge calling to ERC77transferFrom\n        require(to == address(this), \"Bridge: Not to this address\");\n        address tokenToUse = _msgSender();\n        require(ERC1820.getInterfaceImplementer(tokenToUse, _erc777Interface) != NULL_ADDRESS, \"Bridge: Not ERC777 token\");\n        require(userData.length != 0 || !from.isContract(), \"Bridge: Specify receiver address in data\");\n        address receiver = userData.length == 0 ? from : LibUtils.bytesToAddress(userData);\n        crossTokens(tokenToUse, from, receiver, amount, userData);\n    }\n\n    function crossTokens(address tokenToUse, address from, address to, uint256 amount, bytes memory userData)\n    internal whenNotUpgrading whenNotPaused nonReentrant {\n        knownTokens[tokenToUse] = true;\n        uint256 fee = amount.mul(feePercentage).div(feePercentageDivider);\n        uint256 amountMinusFees = amount.sub(fee);\n        uint8 decimals = LibUtils.getDecimals(tokenToUse);\n        uint formattedAmount = amount;\n        if(decimals != 18) {\n            formattedAmount = amount.mul(uint256(10)**(18-decimals));\n        }\n        // We consider the amount before fees converted to 18 decimals to check the limits\n        // updateTokenTransfer revert if token not allowed\n        allowTokens.updateTokenTransfer(tokenToUse, formattedAmount);\n        address originalTokenAddress = tokenToUse;\n        if (originalTokens[tokenToUse] != NULL_ADDRESS) {\n            //Side Token Crossing\n            originalTokenAddress = originalTokens[tokenToUse];\n            uint256 granularity = LibUtils.getGranularity(tokenToUse);\n            uint256 modulo = amountMinusFees.mod(granularity);\n            fee = fee.add(modulo);\n            amountMinusFees = amountMinusFees.sub(modulo);\n            IERC777(tokenToUse).burn(amountMinusFees, userData);\n        }\n\n        emit Cross(\n            originalTokenAddress,\n            from,\n            to,\n            amountMinusFees,\n            userData\n        );\n\n        if (fee > 0) {\n            //Send the payment to the MultiSig of the Federation\n            IERC20(tokenToUse).safeTransfer(owner(), fee);\n        }\n    }\n\n    function getTransactionDataHash(\n        address _to,\n        uint256 _amount,\n        bytes32 _blockHash,\n        bytes32 _transactionHash,\n        uint32 _logIndex\n    )\n        public pure override returns(bytes32)\n    {\n        return keccak256(abi.encodePacked(_blockHash, _transactionHash, _to, _amount, _logIndex));\n    }\n\n    function setFeePercentage(uint amount) external onlyOwner {\n        require(amount < (feePercentageDivider/10), \"Bridge: bigger than 10%\");\n        feePercentage = amount;\n        emit FeePercentageChanged(feePercentage);\n    }\n\n    function getFeePercentage() external view override returns(uint) {\n        return feePercentage;\n    }\n\n    function changeFederation(address newFederation) external onlyOwner {\n        require(newFederation != NULL_ADDRESS, \"Bridge: Federation is empty\");\n        federation = newFederation;\n        emit FederationChanged(federation);\n    }\n\n\n    function changeAllowTokens(address newAllowTokens) external onlyOwner {\n        require(newAllowTokens != NULL_ADDRESS, \"Bridge: AllowTokens is empty\");\n        allowTokens = IAllowTokens(newAllowTokens);\n        emit AllowTokensChanged(newAllowTokens);\n    }\n\n    function getFederation() external view returns(address) {\n        return federation;\n    }\n\n    function changeSideTokenFactory(address newSideTokenFactory) external onlyOwner {\n        require(newSideTokenFactory != NULL_ADDRESS, \"Bridge: SideTokenFactory is empty\");\n        sideTokenFactory = ISideTokenFactory(newSideTokenFactory);\n        emit SideTokenFactoryChanged(newSideTokenFactory);\n    }\n\n    function setUpgrading(bool _isUpgrading) external onlyOwner {\n        isUpgrading = _isUpgrading;\n        emit Upgrading(isUpgrading);\n    }\n\n    function setWrappedCurrency(address _wrappedCurrency) external onlyOwner {\n        require(_wrappedCurrency != NULL_ADDRESS, \"Bridge: wrapp is empty\");\n        wrappedCurrency = IWrapped(_wrappedCurrency);\n        emit WrappedCurrencyChanged(_wrappedCurrency);\n    }\n\n    function hasCrossed(bytes32 transactionHash) public view returns (bool) {\n        return transactionsDataHashes[transactionHash] != bytes32(0);\n    }\n\n    function hasBeenClaimed(bytes32 transactionHash) public view returns (bool) {\n        return claimed[transactionsDataHashes[transactionHash]];\n    }\n\n}\n"
    },
    "contracts/zeppelin/token/ERC777/IERC777Recipient.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\npragma abicoder v2;\n\n/**\n * @dev Interface of the ERC777TokensRecipient standard as defined in the EIP.\n *\n * Accounts can be notified of `IERC777` tokens being sent to them by having a\n * contract implement this interface (contract holders can be their own\n * implementer) and registering it on the\n * [ERC1820 global registry](https://eips.ethereum.org/EIPS/eip-1820).\n *\n * See `IERC1820Registry` and `ERC1820Implementer`.\n */\ninterface IERC777Recipient {\n    /**\n     * @dev Called by an `IERC777` token contract whenever tokens are being\n     * moved or created into a registered account (`to`). The type of operation\n     * is conveyed by `from` being the zero address or not.\n     *\n     * This call occurs _after_ the token contract's state is updated, so\n     * `IERC777.balanceOf`, etc., can be used to query the post-operation state.\n     *\n     * This function may revert to prevent the operation from being executed.\n     */\n    function tokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint amount,\n        bytes calldata userData,\n        bytes calldata operatorData\n    ) external;\n}\n"
    },
    "contracts/zeppelin/token/ERC777/IERC777.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\npragma abicoder v2;\n\n/**\n * @dev Interface of the ERC777Token standard as defined in the EIP.\n *\n * This contract uses the\n * [ERC1820 registry standard](https://eips.ethereum.org/EIPS/eip-1820) to let\n * token holders and recipients react to token movements by using setting implementers\n * for the associated interfaces in said registry. See `IERC1820Registry` and\n * `ERC1820Implementer`.\n */\ninterface IERC777 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the smallest part of the token that is not divisible. This\n     * means all token operations (creation, movement and destruction) must have\n     * amounts that are a multiple of this number.\n     *\n     * For most token contracts, this value will equal 1.\n     */\n    function granularity() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by an account (`owner`).\n     */\n    function balanceOf(address owner) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * If send or receive hooks are registered for the caller and `recipient`,\n     * the corresponding functions will be called with `data` and empty\n     * `operatorData`. See `IERC777Sender` and `IERC777Recipient`.\n     *\n     * Emits a `Sent` event.\n     *\n     * Requirements\n     *\n     * - the caller must have at least `amount` tokens.\n     * - `recipient` cannot be the zero address.\n     * - if `recipient` is a contract, it must implement the `tokensReceived`\n     * interface.\n     */\n    function send(address recipient, uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev Destroys `amount` tokens from the caller's account, reducing the\n     * total supply.\n     *\n     * If a send hook is registered for the caller, the corresponding function\n     * will be called with `data` and empty `operatorData`. See `IERC777Sender`.\n     *\n     * Emits a `Burned` event.\n     *\n     * Requirements\n     *\n     * - the caller must have at least `amount` tokens.\n     */\n    function burn(uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev Returns true if an account is an operator of `tokenHolder`.\n     * Operators can send and burn tokens on behalf of their owners. All\n     * accounts are their own operator.\n     *\n     * See `operatorSend` and `operatorBurn`.\n     */\n    function isOperatorFor(address operator, address tokenHolder) external view returns (bool);\n\n    /**\n     * @dev Make an account an operator of the caller.\n     *\n     * See `isOperatorFor`.\n     *\n     * Emits an `AuthorizedOperator` event.\n     *\n     * Requirements\n     *\n     * - `operator` cannot be calling address.\n     */\n    function authorizeOperator(address operator) external;\n\n    /**\n     * @dev Make an account an operator of the caller.\n     *\n     * See `isOperatorFor` and `defaultOperators`.\n     *\n     * Emits a `RevokedOperator` event.\n     *\n     * Requirements\n     *\n     * - `operator` cannot be calling address.\n     */\n    function revokeOperator(address operator) external;\n\n    /**\n     * @dev Returns the list of default operators. These accounts are operators\n     * for all token holders, even if `authorizeOperator` was never called on\n     * them.\n     *\n     * This list is immutable, but individual holders may revoke these via\n     * `revokeOperator`, in which case `isOperatorFor` will return false.\n     */\n    function defaultOperators() external view returns (address[] memory);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient`. The caller must\n     * be an operator of `sender`.\n     *\n     * If send or receive hooks are registered for `sender` and `recipient`,\n     * the corresponding functions will be called with `data` and\n     * `operatorData`. See `IERC777Sender` and `IERC777Recipient`.\n     *\n     * Emits a `Sent` event.\n     *\n     * Requirements\n     *\n     * - `sender` cannot be the zero address.\n     * - `sender` must have at least `amount` tokens.\n     * - the caller must be an operator for `sender`.\n     * - `recipient` cannot be the zero address.\n     * - if `recipient` is a contract, it must implement the `tokensReceived`\n     * interface.\n     */\n    function operatorSend(\n        address sender,\n        address recipient,\n        uint256 amount,\n        bytes calldata data,\n        bytes calldata operatorData\n    ) external;\n\n    /**\n     * @dev Destoys `amount` tokens from `account`, reducing the total supply.\n     * The caller must be an operator of `account`.\n     *\n     * If a send hook is registered for `account`, the corresponding function\n     * will be called with `data` and `operatorData`. See `IERC777Sender`.\n     *\n     * Emits a `Burned` event.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     * - the caller must be an operator for `account`.\n     */\n    function operatorBurn(\n        address account,\n        uint256 amount,\n        bytes calldata data,\n        bytes calldata operatorData\n    ) external;\n\n    event Sent(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        bytes data,\n        bytes operatorData\n    );\n\n    function decimals() external returns (uint8);\n\n    event Minted(address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData);\n\n    event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);\n\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\n\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\n}\n"
    },
    "contracts/interface/IBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\npragma abicoder v2;\ninterface IBridge {\n\n    struct ClaimData {\n        address payable to;\n        uint256 amount;\n        bytes32 blockHash;\n        bytes32 transactionHash;\n        uint32 logIndex;\n    }\n\n    function version() external pure returns (string memory);\n\n    function getFeePercentage() external view returns(uint);\n\n    /**\n     * ERC-20 tokens approve and transferFrom pattern\n     * See https://eips.ethereum.org/EIPS/eip-20#transferfrom\n     */\n    function receiveTokensTo(address tokenToUse, address to, uint256 amount) external;\n\n    /**\n     * Use network currency and cross it.\n     */\n    function depositTo(address to) external payable;\n\n    /**\n     * ERC-777 tokensReceived hook allows to send tokens to a contract and notify it in a single transaction\n     * See https://eips.ethereum.org/EIPS/eip-777#motivation for details\n     */\n    function tokensReceived (\n        address operator,\n        address from,\n        address to,\n        uint amount,\n        bytes calldata userData,\n        bytes calldata operatorData\n    ) external;\n\n    /**\n     * Accepts the transaction from the other chain that was voted and sent by the Federation contract\n     */\n    function acceptTransfer(\n        address _originalTokenAddress,\n        address payable _from,\n        address payable _to,\n        uint256 _amount,\n        bytes32 _blockHash,\n        bytes32 _transactionHash,\n        uint32 _logIndex\n    ) external;\n\n    /**\n     * Claims the crossed transaction using the hash, this sends the funds to the address indicated in\n     */\n    function claim(ClaimData calldata _claimData) external returns (uint256 receivedAmount);\n\n    function claimFallback(ClaimData calldata _claimData) external returns (uint256 receivedAmount);\n\n    function claimGasless(\n        ClaimData calldata _claimData,\n        address payable _relayer,\n        uint256 _fee,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external returns (uint256 receivedAmount);\n\n    function getTransactionDataHash(\n        address _to,\n        uint256 _amount,\n        bytes32 _blockHash,\n        bytes32 _transactionHash,\n        uint32 _logIndex\n    ) external returns(bytes32);\n\n    event Cross(\n        address indexed _tokenAddress,\n        address indexed _from,\n        address indexed _to,\n        uint256 _amount,\n        bytes _userData\n    );\n    event NewSideToken(\n        address indexed _newSideTokenAddress,\n        address indexed _originalTokenAddress,\n        string _newSymbol,\n        uint256 _granularity\n    );\n    event AcceptedCrossTransfer(\n        bytes32 indexed _transactionHash,\n        address indexed _originalTokenAddress,\n        address indexed _to,\n        address  _from,\n        uint256 _amount,\n        bytes32 _blockHash,\n        uint256 _logIndex\n    );\n    event FeePercentageChanged(uint256 _amount);\n    event Claimed(\n        bytes32 indexed _transactionHash,\n        address indexed _originalTokenAddress,\n        address indexed _to,\n        address _sender,\n        uint256 _amount,\n        bytes32 _blockHash,\n        uint256 _logIndex,\n        address _reciever,\n        address _relayer,\n        uint256 _fee\n    );\n}"
    },
    "contracts/interface/ISideToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\npragma abicoder v2;\n\ninterface ISideToken {\n    function mint(address account, uint256 amount, bytes calldata userData, bytes calldata operatorData) external;\n}"
    },
    "contracts/interface/ISideTokenFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\npragma abicoder v2;\n\ninterface ISideTokenFactory {\n\n    function createSideToken(string calldata name, string calldata symbol, uint256 granularity) external returns(address);\n\n    event SideTokenCreated(address indexed sideToken, string symbol, uint256 granularity);\n}"
    },
    "contracts/SideTokenFactory/SideTokenFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\npragma abicoder v2;\n\nimport \"../zeppelin/ownership/Secondary.sol\";\nimport \"../interface/ISideTokenFactory.sol\";\nimport \"../SideToken/SideToken.sol\";\n\ncontract SideTokenFactory is ISideTokenFactory, Secondary {\n\n    function createSideToken(string calldata name, string calldata symbol, uint256 granularity)\n    external onlyPrimary override returns(address) {\n        address sideToken = address(new SideToken(name, symbol, primary(), granularity));\n        emit SideTokenCreated(sideToken, symbol, granularity);\n        return sideToken;\n    }\n}"
    },
    "contracts/zeppelin/ownership/Secondary.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\npragma abicoder v2;\n\nimport \"../GSN/Context.sol\";\n/**\n * @dev A Secondary contract can only be used by its primary account (the one that created it).\n */\nabstract contract Secondary is Context {\n    address private _primary;\n\n    /**\n     * @dev Emitted when the primary contract changes.\n     */\n    event PrimaryTransferred(\n        address recipient\n    );\n\n    /**\n     * @dev Sets the primary account to the one that is creating the Secondary contract.\n     */\n    constructor () {\n        _primary = _msgSender();\n        emit PrimaryTransferred(_primary);\n    }\n\n    /**\n     * @dev Reverts if called from any account other than the primary.\n     */\n    modifier onlyPrimary() {\n        require(_msgSender() == _primary, \"Secondary: caller is not the primary account\");\n        _;\n    }\n\n    /**\n     * @return the address of the primary.\n     */\n    function primary() public view returns (address) {\n        return _primary;\n    }\n\n    /**\n     * @dev Transfers contract to a new primary.\n     * @param recipient The address of new primary.\n     */\n    function transferPrimary(address recipient) public onlyPrimary {\n        require(recipient != address(0), \"Secondary: new primary is the zero address\");\n        _primary = recipient;\n        emit PrimaryTransferred(_primary);\n    }\n}\n"
    },
    "contracts/SideToken/SideToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\npragma abicoder v2;\n\nimport \"../zeppelin/token/ERC777/ERC777.sol\";\nimport \"../interface/IERC677Receiver.sol\";\nimport \"../interface/ISideToken.sol\";\nimport \"../lib/LibEIP712.sol\";\n\ncontract SideToken is ISideToken, ERC777 {\n    using Address for address;\n    using SafeMath for uint256;\n\n    address public minter;\n    uint256 private _granularity;\n\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-2612.md\n    bytes32 public domainSeparator;\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    mapping(address => uint) public nonces;\n\n    // ERC677 Transfer Event\n    event Transfer(address,address,uint256,bytes);\n\n    constructor(string memory _tokenName, string memory _tokenSymbol, address _minterAddr, uint256 _newGranularity)\n    ERC777(_tokenName, _tokenSymbol, new address[](0)) {\n        require(_minterAddr != address(0), \"SideToken: Empty Minter\");\n        require(_newGranularity >= 1, \"SideToken: Granularity < 1\");\n        minter = _minterAddr;\n        _granularity = _newGranularity;\n\n        uint chainId;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            chainId := chainid()\n        }\n        domainSeparator = LibEIP712.hashEIP712Domain(\n            name(),\n            \"1\",\n            chainId,\n            address(this)\n        );\n    }\n\n    modifier onlyMinter() {\n      require(_msgSender() == minter, \"SideToken: Caller is not the minter\");\n      _;\n    }\n\n    function mint(\n        address account,\n        uint256 amount,\n        bytes calldata userData,\n        bytes calldata operatorData\n    )\n    external onlyMinter override\n    {\n        _mint(_msgSender(), account, amount, userData, operatorData);\n    }\n\n    /**\n    * @dev ERC677 transfer token with additional data if the recipient is a contact.\n    * @param recipient The address to transfer to.\n    * @param amount The amount to be transferred.\n    * @param data The extra data to be passed to the receiving contract.\n    */\n    function transferAndCall(address recipient, uint amount, bytes calldata data)\n        external returns (bool success)\n    {\n        address from = _msgSender();\n\n        _send(from, from, recipient, amount, data, \"\", false);\n        emit Transfer(from, recipient, amount, data);\n        IERC677Receiver(recipient).onTokenTransfer(from, amount, data);\n        return true;\n    }\n\n    function granularity() public view override returns (uint256) {\n        return _granularity;\n    }\n\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-2612.md\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\n        require(deadline >= block.timestamp, \"SideToken: EXPIRED\"); // solhint-disable-line not-rely-on-time\n        bytes32 digest = LibEIP712.hashEIP712Message(\n            domainSeparator,\n            keccak256(\n                abi.encode(\n                    PERMIT_TYPEHASH,\n                    owner,\n                    spender,\n                    value,\n                    nonces[owner]++,\n                    deadline\n                )\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(recoveredAddress != address(0) && recoveredAddress == owner, \"SideToken: INVALID_SIGNATURE\");\n        _approve(owner, spender, value);\n    }\n\n}"
    },
    "contracts/zeppelin/token/ERC777/ERC777.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\npragma abicoder v2;\n\nimport \"../../GSN/Context.sol\";\nimport \"./IERC777.sol\";\nimport \"./IERC777Recipient.sol\";\nimport \"./IERC777Sender.sol\";\nimport \"../../token/ERC20/IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../introspection/IERC1820Registry.sol\";\n\n/**\n * @dev Implementation of the {IERC777} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * Support for ERC20 is included in this contract, as specified by the EIP: both\n * the ERC777 and ERC20 interfaces can be safely used when interacting with it.\n * Both {IERC777-Sent} and {IERC20-Transfer} events are emitted on token\n * movements.\n *\n * Additionally, the {IERC777-granularity} value is hard-coded to `1`, meaning that there\n * are no special restrictions in the amount of tokens that created, moved, or\n * destroyed. This makes integration with ERC20 applications seamless.\n */\ncontract ERC777 is Context, IERC777, IERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    IERC1820Registry constant private _erc1820 = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\n\n    mapping(address => uint256) private _balances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    // We inline the result of the following hashes because Solidity doesn't resolve them at compile time.\n    // See https://github.com/ethereum/solidity/issues/4024.\n\n    // keccak256(\"ERC777TokensSender\")\n    bytes32 constant private TOKENS_SENDER_INTERFACE_HASH =\n        0x29ddb589b1fb5fc7cf394961c1adf5f8c6454761adf795e67fe149f658abe895;\n\n    // keccak256(\"ERC777TokensRecipient\")\n    bytes32 constant private TOKENS_RECIPIENT_INTERFACE_HASH =\n        0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b;\n\n    // This isn't ever read from - it's only used to respond to the defaultOperators query.\n    address[] private _defaultOperatorsArray;\n\n    // Immutable, but accounts may revoke them (tracked in __revokedDefaultOperators).\n    mapping(address => bool) private _defaultOperators;\n\n    // For each account, a mapping of its operators and revoked default operators.\n    mapping(address => mapping(address => bool)) private _operators;\n    mapping(address => mapping(address => bool)) private _revokedDefaultOperators;\n\n    // ERC20-allowances\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    /**\n     * @dev `defaultOperators` may be an empty array.\n     */\n    constructor(\n        string memory aName,\n        string memory aSymbol,\n        address[] memory theDefaultOperators\n    ) {\n        _name = aName;\n        _symbol = aSymbol;\n\n        _defaultOperatorsArray = theDefaultOperators;\n        for (uint256 i = 0; i < _defaultOperatorsArray.length; i++) {\n            _defaultOperators[_defaultOperatorsArray[i]] = true;\n        }\n\n        // register interfaces\n        _erc1820.setInterfaceImplementer(address(this), keccak256(\"ERC777Token\"), address(this));\n        _erc1820.setInterfaceImplementer(address(this), keccak256(\"ERC20Token\"), address(this));\n    }\n\n    /**\n     * @dev See {IERC777-name}.\n     */\n    function name() public view override(IERC777) returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC777-symbol}.\n     */\n    function symbol() public view override(IERC777) returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {ERC20Detailed-decimals}.\n     *\n     * Always returns 18, as per the\n     * [ERC777 EIP](https://eips.ethereum.org/EIPS/eip-777#backward-compatibility).\n     */\n    function decimals() public pure override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC777-granularity}.\n     *\n     * This implementation always returns `1`.\n     */\n    function granularity() public view virtual override(IERC777) returns (uint256) {\n        return 1;\n    }\n\n    /**\n     * @dev See {IERC777-totalSupply}.\n     */\n    function totalSupply() public view override(IERC20, IERC777) returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev Returns the amount of tokens owned by an account (`tokenHolder`).\n     */\n    function balanceOf(address tokenHolder) public view override(IERC20, IERC777) returns (uint256) {\n        return _balances[tokenHolder];\n    }\n\n    /**\n     * @dev See {IERC777-send}.\n     *\n     * Also emits a {Transfer} event for ERC20 compatibility.\n     */\n    function send(address recipient, uint256 amount, bytes calldata data) external override(IERC777) {\n        _send(_msgSender(), _msgSender(), recipient, amount, data, \"\", true);\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Unlike `send`, `recipient` is _not_ required to implement the {IERC777Recipient}\n     * interface if it is a contract.\n     *\n     * Also emits a {Sent} event.\n     */\n    function transfer(address recipient, uint256 amount) external override(IERC20) returns (bool) {\n        require(recipient != address(0), \"ERC777: transfer to zero address\");\n\n        address from = _msgSender();\n\n        _callTokensToSend(from, from, recipient, amount, \"\", \"\");\n\n        _move(from, from, recipient, amount, \"\", \"\");\n\n        _callTokensReceived(from, from, recipient, amount, \"\", \"\", false);\n\n        return true;\n    }\n\n    /**\n     * @dev See {IERC777-burn}.\n     *\n     * Also emits a {Transfer} event for ERC20 compatibility.\n     */\n    function burn(uint256 amount, bytes calldata data) external override(IERC777) {\n        _burn(_msgSender(), _msgSender(), amount, data, \"\");\n    }\n\n    /**\n     * @dev See {IERC777-isOperatorFor}.\n     */\n    function isOperatorFor(\n        address operator,\n        address tokenHolder\n    ) public view override(IERC777) returns (bool) {\n        return operator == tokenHolder ||\n            (_defaultOperators[operator] && !_revokedDefaultOperators[tokenHolder][operator]) ||\n            _operators[tokenHolder][operator];\n    }\n\n    /**\n     * @dev See {IERC777-authorizeOperator}.\n     */\n    function authorizeOperator(address operator) external override(IERC777) {\n        require(_msgSender() != operator, \"ERC777: authorizing self as operator\");\n\n        if (_defaultOperators[operator]) {\n            delete _revokedDefaultOperators[_msgSender()][operator];\n        } else {\n            _operators[_msgSender()][operator] = true;\n        }\n\n        emit AuthorizedOperator(operator, _msgSender());\n    }\n\n    /**\n     * @dev See {IERC777-revokeOperator}.\n     */\n    function revokeOperator(address operator) external override(IERC777) {\n        require(operator != _msgSender(), \"ERC777: revoking self as operator\");\n\n        if (_defaultOperators[operator]) {\n            _revokedDefaultOperators[_msgSender()][operator] = true;\n        } else {\n            delete _operators[_msgSender()][operator];\n        }\n\n        emit RevokedOperator(operator, _msgSender());\n    }\n\n    /**\n     * @dev See {IERC777-defaultOperators}.\n     */\n    function defaultOperators() public view override(IERC777) returns (address[] memory) {\n        return _defaultOperatorsArray;\n    }\n\n    /**\n     * @dev See {IERC777-operatorSend}.\n     *\n     * Emits {Sent} and {Transfer} events.\n     */\n    function operatorSend(\n        address sender,\n        address recipient,\n        uint256 amount,\n        bytes calldata data,\n        bytes calldata operatorData\n    )\n    external override(IERC777)\n    {\n        require(isOperatorFor(_msgSender(), sender), \"ERC777: caller is not an operator\");\n        _send(_msgSender(), sender, recipient, amount, data, operatorData, true);\n    }\n\n    /**\n     * @dev See {IERC777-operatorBurn}.\n     *\n     * Emits {Burned} and {Transfer} events.\n     */\n    function operatorBurn(address account, uint256 amount, bytes calldata data, bytes calldata operatorData)\n    external override(IERC777) {\n        require(isOperatorFor(_msgSender(), account), \"ERC777: caller is not an operator\");\n        _burn(_msgSender(), account, amount, data, operatorData);\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     *\n     * Note that operator and allowance concepts are orthogonal: operators may\n     * not have allowance, and accounts with allowance may not be operators\n     * themselves.\n     */\n    function allowance(address holder, address spender)\n    public view override(IERC20) returns (uint256) {\n        return _allowances[holder][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Note that accounts cannot have allowance issued by their operators.\n     */\n    function approve(address spender, uint256 value) external override(IERC20) returns (bool) {\n        address holder = _msgSender();\n        _approve(holder, spender, value);\n        return true;\n    }\n\n   /**\n    * @dev See {IERC20-transferFrom}.\n    *\n    * Note that operator and allowance concepts are orthogonal: operators cannot\n    * call `transferFrom` (unless they have allowance), and accounts with\n    * allowance cannot call `operatorSend` (unless they are operators).\n    *\n    * Emits {Sent}, {Transfer} and {Approval} events.\n    */\n    function transferFrom(address holder, address recipient, uint256 amount)\n    external override(IERC20) returns (bool) {\n        require(recipient != address(0), \"ERC777: transfer to zero address\");\n        require(holder != address(0), \"ERC777: transfer from zero address\");\n\n        address spender = _msgSender();\n\n        _callTokensToSend(spender, holder, recipient, amount, \"\", \"\");\n\n        _move(spender, holder, recipient, amount, \"\", \"\");\n        _approve(holder, spender, _allowances[holder][spender].sub(amount, \"ERC777: transfer amount exceeds allowance\"));\n\n        _callTokensReceived(spender, holder, recipient, amount, \"\", \"\", false);\n\n        return true;\n    }\n\n    /**\n     * @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * If a send hook is registered for `account`, the corresponding function\n     * will be called with `operator`, `data` and `operatorData`.\n     *\n     * See {IERC777Sender} and {IERC777Recipient}.\n     *\n     * Emits {Minted} and {Transfer} events.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - if `account` is a contract, it must implement the {IERC777Recipient}\n     * interface.\n     */\n    function _mint(\n        address operator,\n        address account,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData\n    )\n    internal\n    {\n        require(account != address(0), \"ERC777: mint to zero address\");\n\n        // Update state variables\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n\n        _callTokensReceived(operator, address(0), account, amount, userData, operatorData, true);\n\n        emit Minted(operator, account, amount, userData, operatorData);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Send tokens\n     * @param operator address operator requesting the transfer\n     * @param from address token holder address\n     * @param to address recipient address\n     * @param amount uint256 amount of tokens to transfer\n     * @param userData bytes extra information provided by the token holder (if any)\n     * @param operatorData bytes extra information provided by the operator (if any)\n     * @param requireReceptionAck if true, contract recipients are required to implement ERC777TokensRecipient\n     */\n    function _send(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData,\n        bool requireReceptionAck\n    )\n        internal\n    {\n        require(from != address(0), \"ERC777: send from zero address\");\n        require(to != address(0), \"ERC777: send to zero address\");\n\n        _callTokensToSend(operator, from, to, amount, userData, operatorData);\n\n        _move(operator, from, to, amount, userData, operatorData);\n\n        _callTokensReceived(operator, from, to, amount, userData, operatorData, requireReceptionAck);\n    }\n\n    /**\n     * @dev Burn tokens\n     * @param operator address operator requesting the operation\n     * @param from address token holder address\n     * @param amount uint256 amount of tokens to burn\n     * @param data bytes extra information provided by the token holder\n     * @param operatorData bytes extra information provided by the operator (if any)\n     */\n    function _burn(\n        address operator,\n        address from,\n        uint256 amount,\n        bytes memory data,\n        bytes memory operatorData\n    )\n        internal\n    {\n        require(from != address(0), \"ERC777: burn from zero address\");\n\n        _callTokensToSend(operator, from, address(0), amount, data, operatorData);\n\n        // Update state variables\n        _balances[from] = _balances[from].sub(amount, \"ERC777: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n\n        emit Burned(operator, from, amount, data, operatorData);\n        emit Transfer(from, address(0), amount);\n    }\n\n    function _move(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData\n    )\n        internal\n    {\n        _balances[from] = _balances[from].sub(amount, \"ERC777: transfer amount exceeds balance\");\n        _balances[to] = _balances[to].add(amount);\n\n        emit Sent(operator, from, to, amount, userData, operatorData);\n        emit Transfer(from, to, amount);\n    }\n\n    function _approve(address holder, address spender, uint256 value) internal {\n        // TODO: restore this require statement if this function becomes internal, or is called at a new callsite. It is\n        // currently unnecessary.\n        //require(holder != address(0), \"ERC777: approve from the zero address\");\n        require(spender != address(0), \"ERC777: approve to zero address\");\n\n        _allowances[holder][spender] = value;\n        emit Approval(holder, spender, value);\n    }\n\n    /**\n     * @dev Call from.tokensToSend() if the interface is registered\n     * @param operator address operator requesting the transfer\n     * @param from address token holder address\n     * @param to address recipient address\n     * @param amount uint256 amount of tokens to transfer\n     * @param userData bytes extra information provided by the token holder (if any)\n     * @param operatorData bytes extra information provided by the operator (if any)\n     */\n    function _callTokensToSend(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData\n    )\n        internal\n    {\n        address implementer = _erc1820.getInterfaceImplementer(from, TOKENS_SENDER_INTERFACE_HASH);\n        if (implementer != address(0)) {\n            IERC777Sender(implementer).tokensToSend(operator, from, to, amount, userData, operatorData);\n        }\n    }\n\n    /**\n     * @dev Call to.tokensReceived() if the interface is registered. Reverts if the recipient is a contract but\n     * tokensReceived() was not registered for the recipient\n     * @param operator address operator requesting the transfer\n     * @param from address token holder address\n     * @param to address recipient address\n     * @param amount uint256 amount of tokens to transfer\n     * @param userData bytes extra information provided by the token holder (if any)\n     * @param operatorData bytes extra information provided by the operator (if any)\n     * @param requireReceptionAck if true, contract recipients are required to implement ERC777TokensRecipient\n     */\n    function _callTokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData,\n        bool requireReceptionAck\n    )\n        private\n    {\n         address implementer = _erc1820.getInterfaceImplementer(to, TOKENS_RECIPIENT_INTERFACE_HASH);\n        if (implementer != address(0)) {\n            IERC777Recipient(implementer).tokensReceived(operator, from, to, amount, userData, operatorData);\n        } else if (requireReceptionAck) {\n            require(!to.isContract(), \"ERC777: token recipient contract has no implementer for ERC777TokensRecipient\");\n        }\n    }\n}\n"
    },
    "contracts/interface/IERC677Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\npragma abicoder v2;\n\ninterface IERC677Receiver {\n  function onTokenTransfer(address _sender, uint _value, bytes calldata _data) external;\n}"
    },
    "contracts/zeppelin/token/ERC777/IERC777Sender.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\npragma abicoder v2;\n\n/**\n * @dev Interface of the ERC777TokensSender standard as defined in the EIP.\n *\n * `IERC777` Token holders can be notified of operations performed on their\n * tokens by having a contract implement this interface (contract holders can be\n *  their own implementer) and registering it on the\n * [ERC1820 global registry](https://eips.ethereum.org/EIPS/eip-1820).\n *\n * See `IERC1820Registry` and `ERC1820Implementer`.\n */\ninterface IERC777Sender {\n    /**\n     * @dev Called by an `IERC777` token contract whenever a registered holder's\n     * (`from`) tokens are about to be moved or destroyed. The type of operation\n     * is conveyed by `to` being the zero address or not.\n     *\n     * This call occurs _before_ the token contract's state is updated, so\n     * `IERC777.balanceOf`, etc., can be used to query the pre-operation state.\n     *\n     * This function may revert to prevent the operation from being executed.\n     */\n    function tokensToSend(\n        address operator,\n        address from,\n        address to,\n        uint amount,\n        bytes calldata userData,\n        bytes calldata operatorData\n    ) external;\n}\n"
    },
    "contracts/Bridge/BridgeV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n// Import base Initializable contract\nimport \"../zeppelin/upgradable/Initializable.sol\";\n// Import interface and library from OpenZeppelin contracts\nimport \"../zeppelin/upgradable/utils/ReentrancyGuard.sol\";\nimport \"../zeppelin/upgradable/lifecycle/UpgradablePausable.sol\";\nimport \"../zeppelin/upgradable/ownership/UpgradableOwnable.sol\";\n\nimport \"../zeppelin/introspection/IERC1820Registry.sol\";\nimport \"../zeppelin/token/ERC777/IERC777Recipient.sol\";\nimport \"../zeppelin/token/ERC20/IERC20.sol\";\nimport \"../zeppelin/token/ERC20/SafeERC20.sol\";\nimport \"../zeppelin/token/ERC777/IERC777.sol\";\nimport \"../zeppelin/utils/Address.sol\";\nimport \"../zeppelin/math/SafeMath.sol\";\n\nimport \"./IBridgeV2.sol\";\nimport \"../interface/ISideToken.sol\";\nimport \"../interface/ISideTokenFactory.sol\";\nimport \"../AllowTokens/AllowTokensV0.sol\";\nimport \"../Utils/UtilsV1.sol\";\n\ncontract BridgeV2 is Initializable, IBridgeV2, IERC777Recipient, UpgradablePausable, UpgradableOwnable, ReentrancyGuard {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    using Address for address;\n\n    address constant private NULL_ADDRESS = address(0);\n    bytes32 constant private NULL_HASH = bytes32(0);\n    IERC1820Registry constant private ERC_1820 = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\n\n    address private federation;\n    uint256 private feePercentage;\n    string public symbolPrefix;\n    uint256 public lastDay;\n    uint256 public spentToday;\n\n    mapping (address => address) public mappedTokens; // OirignalToken => SideToken\n    mapping (address => address) public originalTokens; // SideToken => OriginalToken\n    mapping (address => bool) public knownTokens; // OriginalToken => true\n    mapping(bytes32 => bool) public processed; // ProcessedHash => true\n    AllowTokensV0 public allowTokens;\n    ISideTokenFactory public sideTokenFactory;\n    //Bridge_v1 variables\n    bool public isUpgrading;\n    uint256 constant public FEE_PERCENTAGE_DIVIDER = 10000; // Percentage with up to 2 decimals\n    bool private alreadyRun;\n\n    event FederationChanged(address _newFederation);\n    event SideTokenFactoryChanged(address _newSideTokenFactory);\n    event Upgrading(bool isUpgrading);\n    function initialize(\n        address _manager,\n        address _federation,\n        address _allowTokens,\n        address _sideTokenFactory,\n        string memory _symbolPrefix\n    ) public initializer {\n        UpgradableOwnable.initialize(_manager);\n        UpgradablePausable.__Pausable_init(_manager);\n        symbolPrefix = _symbolPrefix;\n        allowTokens = AllowTokensV0(_allowTokens);\n        _changeSideTokenFactory(_sideTokenFactory);\n        _changeFederation(_federation);\n        //keccak256(\"ERC777TokensRecipient\")\n        ERC_1820.setInterfaceImplementer(address(this), 0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b, address(this));\n    }\n\n    function version() external pure override returns (string memory) {\n        return \"v2\";\n    }\n\n    modifier onlyFederation() {\n        require(msg.sender == federation, \"Bridge: Sender not Federation\");\n        _;\n    }\n\n    modifier whenNotUpgrading() {\n        require(!isUpgrading, \"Bridge: Upgrading\");\n        _;\n    }\n\n    function acceptTransfer(\n        address tokenAddress,\n        address receiver,\n        uint256 amount,\n        string calldata symbol,\n        bytes32 blockHash,\n        bytes32 transactionHash,\n        uint32 logIndex,\n        uint8 decimals,\n        uint256 granularity\n    ) external onlyFederation whenNotPaused nonReentrant override returns(bool) {\n        require(tokenAddress != NULL_ADDRESS, \"Bridge: Token is null\");\n        require(receiver != NULL_ADDRESS, \"Bridge: Receiver is null\");\n        require(amount > 0, \"Bridge: Amount 0\");\n        require(bytes(symbol).length > 0, \"Bridge: Empty symbol\");\n        require(blockHash != NULL_HASH, \"Bridge: BlockHash is null\");\n        require(transactionHash != NULL_HASH, \"Bridge: Transaction is null\");\n        require(decimals <= 18, \"Bridge: Decimals bigger 18\");\n        require(UtilsV1.granularityToDecimals(granularity) <= 18, \"Bridge: invalid granularity\");\n\n        _processTransaction(blockHash, transactionHash, receiver, amount, logIndex);\n\n        if (knownTokens[tokenAddress]) {\n            _acceptCrossBackToToken(receiver, tokenAddress, decimals, granularity, amount);\n        } else {\n            _acceptCrossToSideToken(receiver, tokenAddress, decimals, granularity, amount, symbol);\n        }\n        return true;\n    }\n\n    function _acceptCrossToSideToken(\n        address receiver,\n        address tokenAddress,\n        uint8 decimals,\n        uint256 granularity,\n        uint256 amount,\n        string memory symbol\n    ) private {\n\n        (uint256 calculatedGranularity,uint256 formattedAmount) = UtilsV1.calculateGranularityAndAmount(decimals, granularity, amount);\n        address sideToken = mappedTokens[tokenAddress];\n        if (sideToken == NULL_ADDRESS) {\n            sideToken = _createSideToken(tokenAddress, symbol, calculatedGranularity);\n        } else {\n            require(calculatedGranularity == IERC777(sideToken).granularity(), \"Bridge: Granularity differ from side token\");\n        }\n        ISideToken(sideToken).mint(receiver, formattedAmount, \"\", \"\");\n        emit AcceptedCrossTransfer(tokenAddress, receiver, amount, decimals, granularity, formattedAmount, 18, calculatedGranularity);\n    }\n\n    function _acceptCrossBackToToken(address receiver, address tokenAddress, uint8 decimals, uint256 granularity, uint256 amount) private {\n        require(decimals == 18, \"Bridge: Invalid decimals cross back\");\n        //As side tokens are ERC777 we need to convert granularity to decimals\n        (uint8 calculatedDecimals, uint256 formattedAmount) = UtilsV1.calculateDecimalsAndAmount(tokenAddress, granularity, amount);\n        IERC20(tokenAddress).safeTransfer(receiver, formattedAmount);\n        emit AcceptedCrossTransfer(tokenAddress, receiver, amount, decimals, granularity, formattedAmount, calculatedDecimals, 1);\n    }\n\n    /**\n     * ERC-20 tokens approve and transferFrom pattern\n     * See https://eips.ethereum.org/EIPS/eip-20#transferfrom\n     */\n    function receiveTokens(address tokenToUse, uint256 amount) override external whenNotUpgrading whenNotPaused nonReentrant returns(bool) {\n        address sender = _msgSender();\n        require(!sender.isContract(), \"Bridge: Sender can't be a contract\");\n        //Transfer the tokens on IERC20, they should be already Approved for the bridge Address to use them\n        IERC20(tokenToUse).safeTransferFrom(sender, address(this), amount);\n        crossTokens(tokenToUse, sender, amount, \"\");\n        return true;\n    }\n\n    /**\n     * ERC-777 tokensReceived hook allows to send tokens to a contract and notify it in a single transaction\n     * See https://eips.ethereum.org/EIPS/eip-777#motivation for details\n     */\n    function tokensReceived (\n        address operator,\n        address from,\n        address to,\n        uint amount,\n        bytes calldata userData,\n        bytes calldata\n    ) external whenNotPaused whenNotUpgrading override(IBridgeV2, IERC777Recipient) {\n        //Hook from ERC777address\n        if(operator == address(this)) return; // Avoid loop from bridge calling to ERC77transferFrom\n        require(to == address(this), \"Bridge: Not to address\");\n        address tokenToUse = _msgSender();\n        //This can only be used with trusted contracts\n        crossTokens(tokenToUse, from, amount, userData);\n    }\n\n    function crossTokens(address tokenToUse, address from, uint256 amount, bytes memory userData) private {\n        bool isASideToken = originalTokens[tokenToUse] != NULL_ADDRESS;\n        //Send the payment to the MultiSig of the Federation\n        uint256 fee = amount.mul(feePercentage).div(FEE_PERCENTAGE_DIVIDER);\n        uint256 amountMinusFees = amount.sub(fee);\n        if (isASideToken) {\n            uint256 modulo = amountMinusFees.mod(IERC777(tokenToUse).granularity());\n            fee = fee.add(modulo);\n            amountMinusFees = amountMinusFees.sub(modulo);\n        }\n        if(fee > 0) {\n            IERC20(tokenToUse).safeTransfer(owner(), fee);\n        }\n        if (isASideToken) {\n            verifyWithAllowTokens(tokenToUse, amount, isASideToken);\n            //Side Token Crossing\n            IERC777(tokenToUse).burn(amountMinusFees, userData);\n            // solium-disable-next-line max-len\n            emit Cross(originalTokens[tokenToUse], from, amountMinusFees, IERC777(tokenToUse).symbol(), userData, IERC777(tokenToUse).decimals(), IERC777(tokenToUse).granularity());\n        } else {\n            //Main Token Crossing\n            knownTokens[tokenToUse] = true;\n            (uint8 decimals, uint256 granularity, string memory symbol) = UtilsV1.getTokenInfo(tokenToUse);\n            uint formattedAmount = amount;\n            if(decimals != 18) {\n                formattedAmount = amount.mul(uint256(10)**(18-decimals));\n            }\n            //We consider the amount before fees converted to 18 decimals to check the limits\n            verifyWithAllowTokens(tokenToUse, formattedAmount, isASideToken);\n            emit Cross(tokenToUse, from, amountMinusFees, symbol, userData, decimals, granularity);\n        }\n    }\n\n    function _createSideToken(address token, string memory symbol, uint256 granularity) private returns (address sideToken){\n        string memory newSymbol = string(abi.encodePacked(symbolPrefix, symbol));\n        address sideTokenAddress = sideTokenFactory.createSideToken(newSymbol, newSymbol, granularity);\n        sideToken = sideTokenAddress;\n        mappedTokens[token] = sideToken;\n        originalTokens[sideTokenAddress] = token;\n        emit NewSideToken(sideTokenAddress, token, newSymbol, granularity);\n        return sideToken;\n    }\n\n    function verifyWithAllowTokens(address tokenToUse, uint256 amount, bool isASideToken) private  {\n        // solium-disable-next-line security/no-block-members\n        if (block.timestamp > lastDay + 24 hours) { // solhint-disable-line not-rely-on-time\n            // solium-disable-next-line security/no-block-members\n            lastDay = block.timestamp; // solhint-disable-line not-rely-on-time\n            spentToday = 0;\n        }\n        require(allowTokens.isValidTokenTransfer(tokenToUse, amount, spentToday, isASideToken), \"Bridge: Bigger than limit\");\n        spentToday = spentToday.add(amount);\n    }\n\n    function getTransactionId(\n        bytes32 _blockHash,\n        bytes32 _transactionHash,\n        address _receiver,\n        uint256 _amount,\n        uint32 _logIndex\n    )\n        public pure returns(bytes32)\n    {\n        return keccak256(abi.encodePacked(_blockHash, _transactionHash, _receiver, _amount, _logIndex));\n    }\n\n    function _processTransaction(\n        bytes32 _blockHash,\n        bytes32 _transactionHash,\n        address _receiver,\n        uint256 _amount,\n        uint32 _logIndex\n    )\n        private\n    {\n        bytes32 compiledId = getTransactionId(_blockHash, _transactionHash, _receiver, _amount, _logIndex);\n        require(!processed[compiledId], \"Bridge: Already processed\");\n        processed[compiledId] = true;\n    }\n\n    function setFeePercentage(uint amount) external onlyOwner whenNotPaused {\n        require(amount < (FEE_PERCENTAGE_DIVIDER/10), \"Bridge: bigger than 10%\");\n        feePercentage = amount;\n        emit FeePercentageChanged(feePercentage);\n    }\n\n    function getFeePercentage() override external view returns(uint) {\n        return feePercentage;\n    }\n\n    function calcMaxWithdraw() override external view returns (uint) {\n        uint spent = spentToday;\n        // solium-disable-next-line security/no-block-members\n        if (block.timestamp > lastDay + 24 hours) // solhint-disable-line not-rely-on-time\n            spent = 0;\n        return allowTokens.calcMaxWithdraw(spent);\n    }\n\n    function changeFederation(address newFederation) external onlyOwner returns(bool) {\n        _changeFederation(newFederation);\n        return true;\n    }\n\n    function _changeFederation(address newFederation) internal {\n        require(newFederation != NULL_ADDRESS, \"Bridge: Federation is empty\");\n        federation = newFederation;\n        emit FederationChanged(federation);\n    }\n\n    function getFederation() external view returns(address) {\n        return federation;\n    }\n\n    function changeSideTokenFactory(address newSideTokenFactory) external onlyOwner returns(bool) {\n        _changeSideTokenFactory(newSideTokenFactory);\n        return true;\n    }\n\n    function _changeSideTokenFactory(address newSideTokenFactory) internal {\n        require(newSideTokenFactory != NULL_ADDRESS, \"Bridge: SideTokenFactory is empty\");\n        sideTokenFactory = ISideTokenFactory(newSideTokenFactory);\n        emit SideTokenFactoryChanged(newSideTokenFactory);\n    }\n\n    function startUpgrade() external onlyOwner {\n        isUpgrading = true;\n        emit Upgrading(isUpgrading);\n    }\n\n    function endUpgrade() external onlyOwner {\n        isUpgrading = false;\n        emit Upgrading(isUpgrading);\n    }\n\n    //This method is only to recreate the USDT and USDC tokens on rsk without granularity restrictions.\n    function clearSideToken() external onlyOwner returns(bool) {\n        require(!alreadyRun, \"already done\");\n        alreadyRun = true;\n        address payable[4] memory sideTokens = [\n            0xe506F698b31a66049BD4653ed934E7a07Cbc5549,\n            0x5a42221D7AaE8e185BC0054Bb036D9757eC18857,\n            0xcdc8ccBbFB6407c53118fE47259e8d00C81F42CD,\n            0x6117C9529F15c52e2d3188d5285C745B757b5825\n        ];\n        for (uint i = 0; i < sideTokens.length; i++) {\n            address originalToken = address(originalTokens[sideTokens[i]]);\n            originalTokens[sideTokens[i]] = NULL_ADDRESS;\n            mappedTokens[originalToken] = address(NULL_ADDRESS);\n        }\n        return true;\n    }\n\n}\n"
    },
    "contracts/Bridge/IBridgeV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\ninterface IBridgeV2 {function version() external pure returns (string memory);\n\n    function getFeePercentage() external view returns(uint);\n\n    function calcMaxWithdraw() external view returns (uint);\n\n    /**\n     * ERC-20 tokens approve and transferFrom pattern\n     * See https://eips.ethereum.org/EIPS/eip-20#transferfrom\n     */\n    function receiveTokens(address tokenToUse, uint256 amount) external returns(bool);\n\n    /**\n     * ERC-777 tokensReceived hook allows to send tokens to a contract and notify it in a single transaction\n     * See https://eips.ethereum.org/EIPS/eip-777#motivation for details\n     */\n    function tokensReceived (\n        address operator,\n        address from,\n        address to,\n        uint amount,\n        bytes calldata userData,\n        bytes calldata operatorData\n    ) external;\n\n    /**\n     * Accepts the transaction from the other chain that was voted and sent by the federation contract\n     */\n    function acceptTransfer(\n        address originalTokenAddress,\n        address receiver,\n        uint256 amount,\n        string calldata symbol,\n        bytes32 blockHash,\n        bytes32 transactionHash,\n        uint32 logIndex,\n        uint8 decimals,\n        uint256 granularity\n    ) external returns(bool);\n\n    event Cross(address indexed _tokenAddress, address indexed _to, uint256 _amount, string _symbol, bytes _userData,\n        uint8 _decimals, uint256 _granularity);\n    event NewSideToken(address indexed _newSideTokenAddress, address indexed _originalTokenAddress, string _newSymbol, uint256 _granularity);\n    event AcceptedCrossTransfer(address indexed _tokenAddress, address indexed _to, uint256 _amount, uint8 _decimals, uint256 _granularity,\n        uint256 _formattedAmount, uint8 _calculatedDecimals, uint256 _calculatedGranularity);\n    event FeePercentageChanged(uint256 _amount);\n}"
    },
    "contracts/AllowTokens/AllowTokensV0.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"../zeppelin/math/SafeMath.sol\";\nimport \"../zeppelin/ownership/Ownable.sol\";\n\ncontract AllowTokensV0 is Ownable {\n    using SafeMath for uint256;\n\n    address constant private NULL_ADDRESS = address(0);\n\n    mapping (address => bool) public allowedTokens;\n    bool private validateAllowedTokens;\n    uint256 private maxTokensAllowed;\n    uint256 private minTokensAllowed;\n    uint256 public dailyLimit;\n\n    event AllowedTokenAdded(address indexed _tokenAddress);\n    event AllowedTokenRemoved(address indexed _tokenAddress);\n    event AllowedTokenValidation(bool _enabled);\n    event MaxTokensAllowedChanged(uint256 _maxTokens);\n    event MinTokensAllowedChanged(uint256 _minTokens);\n    event DailyLimitChanged(uint256 dailyLimit);\n\n    modifier notNull(address _address) {\n        require(_address != NULL_ADDRESS, \"AllowTokens: Address cannot be empty\");\n        _;\n    }\n\n    constructor(address _manager)  {\n        transferOwnership(_manager);\n        validateAllowedTokens = true;\n        maxTokensAllowed = 10000 ether;\n        minTokensAllowed = 1 ether;\n        dailyLimit = 100000 ether;\n    }\n\n    function isValidatingAllowedTokens() external view returns(bool) {\n        return validateAllowedTokens;\n    }\n\n    function getMaxTokensAllowed() external view returns(uint256) {\n        return maxTokensAllowed;\n    }\n\n    function getMinTokensAllowed() external view returns(uint256) {\n        return minTokensAllowed;\n    }\n\n    function allowedTokenExist(address token) private view notNull(token) returns (bool) {\n        return allowedTokens[token];\n    }\n\n    function isTokenAllowed(address token) public view notNull(token) returns (bool) {\n        if (validateAllowedTokens) {\n            return allowedTokenExist(token);\n        }\n        return true;\n    }\n\n    function addAllowedToken(address token) external onlyOwner {\n        require(!allowedTokenExist(token), \"AllowTokens: Token already exists in allowedTokens\");\n        allowedTokens[token] = true;\n        emit AllowedTokenAdded(token);\n    }\n\n    function removeAllowedToken(address token) external onlyOwner {\n        require(allowedTokenExist(token), \"AllowTokens: Token does not exis  in allowedTokenst\");\n        allowedTokens[token] = false;\n        emit AllowedTokenRemoved(token);\n    }\n\n    function enableAllowedTokensValidation() external onlyOwner {\n        validateAllowedTokens = true;\n        emit AllowedTokenValidation(validateAllowedTokens);\n    }\n\n    function disableAllowedTokensValidation() external onlyOwner {\n        // Before disabling Allowed Tokens Validations some kind of contract validation system\n        // should be implemented on the Bridge for the methods receiveTokens, tokenFallback and tokensReceived\n        validateAllowedTokens = false;\n        emit AllowedTokenValidation(validateAllowedTokens);\n    }\n\n    function setMaxTokensAllowed(uint256 maxTokens) external onlyOwner {\n        require(maxTokens >= minTokensAllowed, \"AllowTokens: Max Tokens should be equal or bigger than Min Token\");\n        maxTokensAllowed = maxTokens;\n        emit MaxTokensAllowedChanged(maxTokensAllowed);\n    }\n\n    function setMinTokensAllowed(uint256 minTokens) external onlyOwner {\n        require(maxTokensAllowed >= minTokens, \"AllowTokens: minTokens should be equal or smaller than maxTokens\");\n        minTokensAllowed = minTokens;\n        emit MinTokensAllowedChanged(minTokensAllowed);\n    }\n\n    function changeDailyLimit(uint256 _dailyLimit) external onlyOwner {\n        require(_dailyLimit >= maxTokensAllowed, \"AllowTokens: dailyLimit should be equal or bigger than maxTokens\");\n        dailyLimit = _dailyLimit;\n        emit DailyLimitChanged(_dailyLimit);\n    }\n\n    // solium-disable-next-line max-len\n    function isValidTokenTransfer(address tokenToUse, uint amount, uint spentToday, bool isSideToken) external view returns (bool) {\n        if(amount > maxTokensAllowed)\n            return false;\n        if(amount < minTokensAllowed)\n            return false;\n        if (spentToday + amount > dailyLimit || spentToday + amount < spentToday)\n            return false;\n        if(!isSideToken && !isTokenAllowed(tokenToUse))\n            return false;\n        return true;\n    }\n\n    function calcMaxWithdraw(uint spentToday) external view returns (uint) {\n        uint maxWithrow = dailyLimit - spentToday;\n        if (dailyLimit < spentToday)\n            return 0;\n        if(maxWithrow > maxTokensAllowed)\n            maxWithrow = maxTokensAllowed;\n        return maxWithrow;\n    }\n\n}\n"
    },
    "contracts/Utils/UtilsV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"../zeppelin/math/SafeMath.sol\";\nimport \"../zeppelin/introspection/IERC1820Registry.sol\";\nimport \"../zeppelin/token/ERC777/IERC777.sol\";\n\nlibrary UtilsV1 {\n    using SafeMath for uint256;\n\n    IERC1820Registry constant private ERC_1820 = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\n    // keccak256(\"ERC777Token\")\n    bytes32 constant private TOKENS_ERC777_HASH = 0xac7fbab5f54a3ca8194167523c6753bfeb96a445279294b6125b68cce2177054;\n\n    function getTokenInfo(address tokenToUse) external view returns (uint8 decimals, uint256 granularity, string memory symbol) {\n        decimals = getDecimals(tokenToUse);\n        granularity = getGranularity(tokenToUse);\n        symbol = getSymbol(tokenToUse);\n    }\n\n    function getSymbol(address tokenToUse) public view returns (string memory symbol) {\n        //support 32 bytes or string symbol\n        (bool success, bytes memory data) = tokenToUse.staticcall(abi.encodeWithSignature(\"symbol()\"));\n        require(success, \"Utils: Token hasn't symbol()\");\n        if (data.length == 32) {\n            symbol = bytes32ToString(abi.decode(data, (bytes32)));\n        } else {\n            symbol = abi.decode(data, (string));\n        }\n        require(bytes(symbol).length > 0, \"Utils: Token empty symbol\");\n        return symbol;\n    }\n\n    function getDecimals(address tokenToUse) public view returns (uint8) {\n        //support decimals as uint256 or uint8\n        (bool success, bytes memory data) = tokenToUse.staticcall(abi.encodeWithSignature(\"decimals()\"));\n        require(success, \"Utils: No decimals\");\n        require(data.length == 32, \"Utils: Decimals not uint<M>\");\n        // uint<M>: enc(X) is the big-endian encoding of X,\n        //padded on the higher-order (left) side with zero-bytes such that the length is 32 bytes.\n        uint256 decimalsDecoded = abi.decode(data, (uint256));\n        require(decimalsDecoded <= 18, \"Utils: Decimals not in 0 to 18\");\n        return uint8(decimalsDecoded);\n    }\n\n    function getGranularity(address tokenToUse) public view returns (uint256 granularity) {\n        granularity = 1;\n        //support granularity if ERC777\n        address implementer = ERC_1820.getInterfaceImplementer(tokenToUse, TOKENS_ERC777_HASH);\n        if (implementer != address(0)) {\n            granularity = IERC777(implementer).granularity();\n            //Verify granularity is power of 10 to keep it compatible with ERC20 decimals\n            granularityToDecimals(granularity);\n        }\n        return granularity;\n    }\n\n    /* bytes32 (fixed-size array) to string (dynamically-sized array) */\n    function bytes32ToString(bytes32 _bytes32) internal pure returns (string memory) {\n        uint8 i = 0;\n        while(i < 32 && _bytes32[i] != 0) {\n            i++;\n        }\n        bytes memory bytesArray = new bytes(i);\n        for (i = 0; i < 32 && _bytes32[i] != 0; i++) {\n            bytesArray[i] = _bytes32[i];\n        }\n        return string(bytesArray);\n    }\n\n    function decimalsToGranularity(uint8 decimals) public pure returns (uint256) {\n        require(decimals <= 18, \"Utils: Decimals not in 0 to 18\");\n        return uint256(10)**(18-decimals);\n    }\n\n    function granularityToDecimals(uint256 granularity) public pure returns (uint8) {\n        if(granularity == 1) return 18;\n        if(granularity == 10) return 17;\n        if(granularity == 100) return 16;\n        if(granularity == 1000) return 15;\n        if(granularity == 10000) return 14;\n        if(granularity == 100000) return 13;\n        if(granularity == 1000000) return 12;\n        if(granularity == 10000000) return 11;\n        if(granularity == 100000000) return 10;\n        if(granularity == 1000000000) return 9;\n        if(granularity == 10000000000) return 8;\n        if(granularity == 100000000000) return 7;\n        if(granularity == 1000000000000) return 6;\n        if(granularity == 10000000000000) return 5;\n        if(granularity == 100000000000000) return 4;\n        if(granularity == 1000000000000000) return 3;\n        if(granularity == 10000000000000000) return 2;\n        if(granularity == 100000000000000000) return 1;\n        if(granularity == 1000000000000000000) return 0;\n        require(false, \"Utils: invalid granularity\");\n        return 0;\n    }\n\n    function calculateGranularityAndAmount(uint8 decimals, uint256 granularity, uint256 amount) external pure\n        returns(uint256 calculatedGranularity, uint256 formattedAmount) {\n\n        if(decimals == 18) {\n            //tokenAddress is a ERC20 with 18 decimals should have 1 granularity\n            //tokenAddress is a ERC777 token we give the same granularity\n            calculatedGranularity = granularity;\n            formattedAmount = amount;\n        } else {\n            //tokenAddress is a ERC20 with other than 18 decimals\n            calculatedGranularity = decimalsToGranularity(decimals);\n            formattedAmount = amount.mul(calculatedGranularity);\n        }\n    }\n\n    function calculateDecimalsAndAmount(address tokenAddress, uint256 granularity, uint256 amount)\n        external view returns (uint8 calculatedDecimals, uint256 formattedAmount) {\n        uint8 tokenDecimals = getDecimals(tokenAddress);\n        //As side tokens are ERC777 we need to convert granularity to decimals\n        calculatedDecimals = granularityToDecimals(granularity);\n        require(tokenDecimals == calculatedDecimals, \"Utils: Token decimals differ from decimals - granularity\");\n        formattedAmount = amount.div(granularity);\n    }\n\n}\n"
    },
    "contracts/zeppelin/ownership/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\npragma abicoder v2;\n\nimport \"../GSN/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () {\n        _owner = _msgSender();\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "contracts/test/mockReceiveTokensCall.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"../interface/IBridge.sol\";\nimport \"../zeppelin/token/ERC20/IERC20.sol\";\nimport \"../zeppelin/token/ERC777/IERC777.sol\";\nimport \"../zeppelin/token/ERC777/IERC777Recipient.sol\";\nimport \"../zeppelin/introspection/IERC1820Registry.sol\";\n\ncontract mockReceiveTokensCall is IERC777Recipient {\n    address public bridge;\n    IERC1820Registry constant public erc1820 = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\n\n    constructor(address _bridge) {\n        bridge = _bridge;\n        //keccak256(\"ERC777TokensRecipient\")\n        erc1820.setInterfaceImplementer(address(this), 0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b, address(this));\n    }\n\n    function callReceiveTokens(address tokenToUse, address receiver, uint256 amount) external {\n        IERC20(tokenToUse).approve(bridge, amount);\n        IBridge(bridge).receiveTokensTo(tokenToUse, receiver, amount);\n    }\n\n    function callDepositTo(address receiver) external payable {\n        IBridge(bridge).depositTo{ value: msg.value }(receiver);\n    }\n\n    function callTokensReceived(address tokenToUse, uint256 amount, bytes calldata data) external {\n        IERC777(tokenToUse).send(bridge, amount, data);\n    }\n\n    // Mandatory for IERC777Recipient\n    function tokensReceived(\n        address,\n        address,\n        address,\n        uint,\n        bytes calldata,\n        bytes calldata\n    ) override external view {\n        this;\n    }\n}"
    },
    "contracts/test/mockERC777Recipient.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"../zeppelin/token/ERC777/IERC777Recipient.sol\";\nimport \"../zeppelin/introspection/IERC1820Registry.sol\";\n\ncontract mockERC777Recipient is IERC777Recipient {\n    IERC1820Registry constant private _erc1820 = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\n\n    constructor() {\n        _erc1820.setInterfaceImplementer(address(this), keccak256(\"ERC777TokensRecipient\"), address(this));\n    }\n\n    event Success(\n    address operator,\n    address from,\n    address to,\n    uint amount,\n    bytes userData,\n    bytes operatorData);\n\n    /**\n     * ERC-677's only method implementation\n     * See https://github.com/ethereum/EIPs/issues/677 for details\n     */\n    function tokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint amount,\n        bytes calldata userData,\n        bytes calldata operatorData\n    ) override external {\n        emit Success(operator, from, to, amount, userData, operatorData);\n    }\n}"
    },
    "contracts/SideToken/SideTokenV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"../zeppelin/token/ERC777/ERC777.sol\";\n\ncontract SideTokenV1 is ERC777 {\n    address public minter;\n\n    constructor(string memory _tokenName, string memory _tokenSymbol, address _minterAddr)\n    ERC777(_tokenName, _tokenSymbol, new address[](0)) {\n        require(_minterAddr != address(0), \"SideToken: Minter address is null\");\n        minter = _minterAddr;\n    }\n\n    modifier onlyMinter() {\n        require(_msgSender() == minter, \"SideToken: Caller is not the minter\");\n        _;\n    }\n    function mint(\n        address account,\n        uint256 amount,\n        bytes calldata userData,\n        bytes calldata operatorData\n    )\n    external onlyMinter\n    {\n        _mint(_msgSender(), account, amount, userData, operatorData);\n    }\n\n}"
    },
    "contracts/SideTokenFactory/SideTokenFactoryV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"../zeppelin/ownership/Secondary.sol\";\nimport \"../SideToken/SideTokenV1.sol\";\n\ncontract SideTokenFactoryV1 is Secondary {\n    event CreatedSideToken(address sideToken, string symbol);\n\n    function createSideToken(string calldata name, string calldata symbol) external onlyPrimary returns(SideTokenV1) {\n        SideTokenV1 sideToken = new SideTokenV1(name, symbol, primary());\n        emit CreatedSideToken(address(sideToken), symbol);\n        return sideToken;\n    }\n}"
    },
    "contracts/zeppelin/token/ERC1155/ERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"./IERC1155.sol\";\nimport \"./IERC1155MetadataURI.sol\";\nimport \"./IERC1155Receiver.sol\";\nimport \"../../GSN/Context.sol\";\nimport \"../../introspection/ERC165.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n *\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n *\n * _Available since v3.1._\n */\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n    using SafeMath for uint256;\n    using Address for address;\n\n    // Mapping from token ID to account balances\n    mapping (uint256 => mapping(address => uint256)) private _balances;\n\n    // Mapping from account to operator approvals\n    mapping (address => mapping(address => bool)) private _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /*\n     *     bytes4(keccak256('balanceOf(address,uint256)')) == 0x00fdd58e\n     *     bytes4(keccak256('balanceOfBatch(address[],uint256[])')) == 0x4e1273f4\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,uint256,bytes)')) == 0xf242432a\n     *     bytes4(keccak256('safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)')) == 0x2eb2c2d6\n     *\n     *     => 0x00fdd58e ^ 0x4e1273f4 ^ 0xa22cb465 ^\n     *        0xe985e9c5 ^ 0xf242432a ^ 0x2eb2c2d6 == 0xd9b67a26\n     */\n    bytes4 private constant _INTERFACE_ID_ERC1155 = 0xd9b67a26;\n\n    /*\n     *     bytes4(keccak256('uri(uint256)')) == 0x0e89341c\n     */\n    bytes4 private constant _INTERFACE_ID_ERC1155_METADATA_URI = 0x0e89341c;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    constructor (string memory uri_) {\n        _setURI(uri_);\n\n        // register the supported interfaces to conform to ERC1155 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC1155);\n\n        // register the supported interfaces to conform to ERC1155MetadataURI via ERC165\n        _registerInterface(_INTERFACE_ID_ERC1155_METADATA_URI);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) external view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(\n        address[] memory accounts,\n        uint256[] memory ids\n    )\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(_msgSender() != operator, \"ERC1155: setting approval status for self\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    )\n        public\n        virtual\n        override\n    {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        _balances[id][from] = _balances[id][from].sub(amount, \"ERC1155: insufficient balance for transfer\");\n        _balances[id][to] = _balances[id][to].add(amount);\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    )\n        public\n        virtual\n        override\n    {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            _balances[id][from] = _balances[id][from].sub(\n                amount,\n                \"ERC1155: insufficient balance for transfer\"\n            );\n            _balances[id][to] = _balances[id][to].add(amount);\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `account`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - If `account` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(address account, uint256 id, uint256 amount, bytes memory data) internal virtual {\n        require(account != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), account, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        _balances[id][account] = _balances[id][account].add(amount);\n        emit TransferSingle(operator, address(0), account, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), account, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] = amounts[i].add(_balances[ids[i]][to]);\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens of token type `id` from `account`\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens of token type `id`.\n     */\n    function _burn(address account, uint256 id, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, account, address(0), _asSingletonArray(id), _asSingletonArray(amount), \"\");\n\n        _balances[id][account] = _balances[id][account].sub(\n            amount,\n            \"ERC1155: burn amount exceeds balance\"\n        );\n\n        emit TransferSingle(operator, account, address(0), id, amount);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     */\n    function _burnBatch(address account, uint256[] memory ids, uint256[] memory amounts) internal virtual {\n        require(account != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, account, address(0), ids, amounts, \"\");\n\n        for (uint i = 0; i < ids.length; i++) {\n            _balances[ids[i]][account] = _balances[ids[i]][account].sub(\n                amounts[i],\n                \"ERC1155: burn amount exceeds balance\"\n            );\n        }\n\n        emit TransferBatch(operator, account, address(0), ids, amounts);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    )\n        internal\n        virtual\n    { }\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    )\n        private\n    {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver(to).onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    )\n        private\n    {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver(to).onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n}\n"
    },
    "contracts/zeppelin/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"../../introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;\n}\n"
    },
    "contracts/zeppelin/token/ERC1155/IERC1155MetadataURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"./IERC1155.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURI is IERC1155 {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "contracts/zeppelin/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"../../introspection/IERC165.sol\";\n\n/**\n * _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n\n    /**\n        @dev Handles the receipt of a single ERC1155 token type. This function is\n        called at the end of a `safeTransferFrom` after the balance has been updated.\n        To accept the transfer, this must return\n        `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n        (i.e. 0xf23a6e61, or its own function selector).\n        @param operator The address which initiated the transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param id The ID of the token being transferred\n        @param value The amount of tokens being transferred\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n    */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    )\n        external\n        returns(bytes4);\n\n    /**\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\n        is called at the end of a `safeBatchTransferFrom` after the balances have\n        been updated. To accept the transfer(s), this must return\n        `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n        (i.e. 0xbc197c81, or its own function selector).\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n    */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    )\n        external\n        returns(bytes4);\n}\n"
    },
    "contracts/zeppelin/token/ERC1155/ERC1155Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"./ERC1155.sol\";\nimport \"../../lifecycle/Pausable.sol\";\n\n/**\n * @dev ERC1155 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n *\n * _Available since v3.1._\n */\nabstract contract ERC1155Pausable is ERC1155, Pausable {\n    /**\n     * @dev See {ERC1155-_beforeTokenTransfer}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    )\n        internal\n        virtual\n        override\n    {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        require(!paused(), \"ERC1155Pausable: token transfer while paused\");\n    }\n}\n"
    },
    "contracts/zeppelin/lifecycle/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\npragma abicoder v2;\n\nimport \"../GSN/Context.sol\";\nimport \"../access/roles/PauserRole.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context, PauserRole {\n    /**\n     * @dev Emitted when the pause is triggered by a pauser (`account`).\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by a pauser (`account`).\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state. Assigns the Pauser role\n     * to the deployer.\n     */\n    constructor () {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     */\n    modifier whenNotPaused() {\n        require(!_paused, \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     */\n    modifier whenPaused() {\n        require(_paused, \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Called by a pauser to pause, triggers stopped state.\n     */\n    function pause() public onlyPauser whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Called by a pauser to unpause, returns to normal state.\n     */\n    function unpause() public onlyPauser whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "contracts/zeppelin/access/roles/PauserRole.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\npragma abicoder v2;\n\nimport \"../../GSN/Context.sol\";\nimport \"../Roles.sol\";\n\nabstract contract PauserRole is Context {\n    using Roles for Roles.Role;\n\n    event PauserAdded(address indexed account);\n    event PauserRemoved(address indexed account);\n\n    Roles.Role private _pausers;\n\n    constructor () {\n        _addPauser(_msgSender());\n    }\n\n    modifier onlyPauser() {\n        require(isPauser(_msgSender()), \"PauserRole: caller doesn't have the role\");\n        _;\n    }\n\n    function isPauser(address account) public view returns (bool) {\n        return _pausers.has(account);\n    }\n\n    function addPauser(address account) public onlyPauser {\n        _addPauser(account);\n    }\n\n    function renouncePauser() public {\n        _removePauser(_msgSender());\n    }\n\n    function _addPauser(address account) internal {\n        _pausers.add(account);\n        emit PauserAdded(account);\n    }\n\n    function _removePauser(address account) internal {\n        _pausers.remove(account);\n        emit PauserRemoved(account);\n    }\n}\n"
    },
    "contracts/zeppelin/token/ERC721/ERC721Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"./ERC721.sol\";\nimport \"../../lifecycle/Pausable.sol\";\n\n/**\n * @dev ERC721 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n */\nabstract contract ERC721Pausable is ERC721, Pausable {\n    /**\n     * @dev See {ERC721-_beforeTokenTransfer}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        require(!paused(), \"ERC721Pausable: token transfer while paused\");\n    }\n}\n"
    },
    "contracts/test/nftbridge/OpenSea721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n// created using https://github.com/ProjectOpenSea/opensea-creatures/blob/master/contracts/ERC721Tradable.sol\n// and https://github.com/ProjectOpenSea/opensea-creatures/blob/master/contracts/Creature.sol\nimport \"../../zeppelin/token/ERC721/ERC721.sol\";\nimport \"../../zeppelin/ownership/Ownable.sol\";\nimport \"../../zeppelin/math/SafeMath.sol\";\nimport \"../../zeppelin/utils/Strings.sol\";\nimport \"./OpenSeaEIP712Base.sol\";\n\n\n/**\n * @title OpenSea721\n * OpenSea721 - ERC721 contract that whitelists a trading address, and has minting functionality.\n */\ncontract OpenSea721 is ERC721, OpenSeaEIP712Base, Ownable {\n    using SafeMath for uint256;\n\n    uint256 private _currentTokenId = 0;\n\n    constructor(\n        string memory _name,\n        string memory _symbol\n    ) ERC721(_name, _symbol) {\n        _initializeEIP712(_name);\n    }\n\n    function baseTokenURI() public pure returns (string memory) {\n        return \"https://creatures-api.opensea.io/api/creature/\";\n    }\n\n    function contractURI() public pure returns (string memory) {\n        return \"https://creatures-api.opensea.io/contract/opensea-creatures\";\n    }\n\n    /**\n     * @dev Mints a token to an address with a tokenURI.\n     * @param _to address of the future owner of the token\n     */\n    function mintTo(address _to) public onlyOwner {\n        uint256 newTokenId = _getNextTokenId();\n        _mint(_to, newTokenId);\n        _incrementTokenId();\n    }\n\n    /**\n     * @dev calculates the next token ID based on value of _currentTokenId\n     * @return uint256 for the next token ID\n     */\n    function _getNextTokenId() private view returns (uint256) {\n        return _currentTokenId.add(1);\n    }\n\n    /**\n     * @dev increments the value of _currentTokenId\n     */\n    function _incrementTokenId() private {\n        _currentTokenId++;\n    }\n\n    function tokenURI(uint256 _tokenId) override public pure returns (string memory) {\n        return string(abi.encodePacked(baseTokenURI(), Strings.toString(_tokenId)));\n    }\n\n}"
    },
    "contracts/test/nftbridge/OpenSeaEIP712Base.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"../../zeppelin/upgradable/Initializable.sol\";\n\ncontract OpenSeaEIP712Base is Initializable {\n    struct EIP712Domain {\n        string name;\n        string version;\n        address verifyingContract;\n        bytes32 salt;\n    }\n\n    string constant public ERC712_VERSION = \"1\";\n\n    bytes32 internal constant EIP712_DOMAIN_TYPEHASH = keccak256(\n        bytes(\n            \"EIP712Domain(string name,string version,address verifyingContract,bytes32 salt)\"\n        )\n    );\n    bytes32 internal domainSeperator;\n\n    // supposed to be called once while initializing.\n    // one of the contracts that inherits this contract follows proxy pattern\n    // so it is not possible to do this in a constructor\n    function _initializeEIP712(\n        string memory name\n    )\n        internal\n        initializer\n    {\n        _setDomainSeperator(name);\n    }\n\n    function _setDomainSeperator(string memory name) internal {\n        domainSeperator = keccak256(\n            abi.encode(\n                EIP712_DOMAIN_TYPEHASH,\n                keccak256(bytes(name)),\n                keccak256(bytes(ERC712_VERSION)),\n                address(this),\n                bytes32(getChainId())\n            )\n        );\n    }\n\n    function getDomainSeperator() public view returns (bytes32) {\n        return domainSeperator;\n    }\n\n    function getChainId() public pure returns (uint256) {\n        uint256 id;\n        assembly {\n            id := chainid()\n        }\n        return id;\n    }\n\n    /**\n     * Accept message hash and returns hash message in EIP712 compatible form\n     * So that it can be used to recover signer from signature signed using EIP712 formatted data\n     * https://eips.ethereum.org/EIPS/eip-712\n     * \"\\\\x19\" makes the encoding deterministic\n     * \"\\\\x01\" is the version byte to make it compatible to EIP-191\n     */\n    function toTypedMessageHash(bytes32 messageHash)\n        internal\n        view\n        returns (bytes32)\n    {\n        return\n            keccak256(\n                abi.encodePacked(\"\\x19\\x01\", getDomainSeperator(), messageHash)\n            );\n    }\n}\n"
    },
    "contracts/Federation/FederationV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\npragma abicoder v2;\n\n// Upgradables\nimport \"../zeppelin/upgradable/Initializable.sol\";\nimport \"../zeppelin/upgradable/ownership/UpgradableOwnable.sol\";\n\nimport \"../interface/IBridge.sol\";\n\ncontract FederationV2 is Initializable, UpgradableOwnable {\n    uint constant public MAX_MEMBER_COUNT = 50;\n    address constant private NULL_ADDRESS = address(0);\n\n    IBridge public bridge;\n    address[] public members;\n    uint public required;\n\n    mapping (address => bool) public isMember;\n    mapping (bytes32 => mapping (address => bool)) public votes;\n    mapping(bytes32 => bool) public processed;\n\n    event Executed(\n        address indexed federator,\n        bytes32 indexed transactionHash,\n        bytes32 indexed transactionId,\n        address originalTokenAddress,\n        address sender,\n        address receiver,\n        uint256 amount,\n        bytes32 blockHash,\n        uint32 logIndex\n    );\n    event MemberAddition(address indexed member);\n    event MemberRemoval(address indexed member);\n    event RequirementChange(uint required);\n    event BridgeChanged(address bridge);\n    event Voted(\n        address indexed federator,\n        bytes32 indexed transactionHash,\n        bytes32 indexed transactionId,\n        address originalTokenAddress,\n        address sender,\n        address receiver,\n        uint256 amount,\n        bytes32 blockHash,\n        uint32 logIndex\n    );\n    event HeartBeat(\n        address indexed sender,\n        uint256 fedRskBlock,\n        uint256 fedEthBlock,\n        string federatorVersion,\n        string nodeRskInfo,\n        string nodeEthInfo\n    );\n\n    modifier onlyMember() {\n        require(isMember[_msgSender()], \"Federation: Not Federator\");\n        _;\n    }\n\n    modifier validRequirement(uint membersCount, uint _required) {\n        // solium-disable-next-line max-len\n        require(_required <= membersCount && _required != 0 && membersCount != 0, \"Federation: Invalid requirements\");\n        _;\n    }\n\n    function initialize(address[] memory _members, uint _required, address _bridge, address owner)\n    public validRequirement(_members.length, _required) initializer {\n        UpgradableOwnable.initialize(owner);\n        require(_members.length <= MAX_MEMBER_COUNT, \"Federation: Too many members\");\n        members = _members;\n        for (uint i = 0; i < _members.length; i++) {\n            require(!isMember[_members[i]] && _members[i] != NULL_ADDRESS, \"Federation: Invalid members\");\n            isMember[_members[i]] = true;\n            emit MemberAddition(_members[i]);\n        }\n        required = _required;\n        emit RequirementChange(required);\n        _setBridge(_bridge);\n    }\n\n    function version() external pure returns (string memory) {\n        return \"v2\";\n    }\n\n    function setBridge(address _bridge) external onlyOwner {\n        _setBridge(_bridge);\n    }\n\n    function _setBridge(address _bridge) internal {\n        require(_bridge != NULL_ADDRESS, \"Federation: Empty bridge\");\n        bridge = IBridge(_bridge);\n        emit BridgeChanged(_bridge);\n    }\n\n    function voteTransaction(\n        address originalTokenAddress,\n        address payable sender,\n        address payable receiver,\n        uint256 amount,\n        bytes32 blockHash,\n        bytes32 transactionHash,\n        uint32 logIndex\n    )\n    public onlyMember returns(bool)\n    {\n        bytes32 transactionId = getTransactionId(\n            originalTokenAddress,\n            sender,\n            receiver,\n            amount,\n            blockHash,\n            transactionHash,\n            logIndex\n        );\n        if (processed[transactionId])\n            return true;\n\n        if (votes[transactionId][_msgSender()])\n            return true;\n\n        votes[transactionId][_msgSender()] = true;\n        emit Voted(\n            _msgSender(),\n            transactionHash,\n            transactionId,\n            originalTokenAddress,\n            sender,\n            receiver,\n            amount,\n            blockHash,\n            logIndex\n        );\n\n        uint transactionCount = getTransactionCount(transactionId);\n        if (transactionCount >= required && transactionCount >= members.length / 2 + 1) {\n            processed[transactionId] = true;\n            bridge.acceptTransfer(\n                originalTokenAddress,\n                sender,\n                receiver,\n                amount,\n                blockHash,\n                transactionHash,\n                logIndex\n            );\n            emit Executed(\n                _msgSender(),\n                transactionHash,\n                transactionId,\n                originalTokenAddress,\n                sender,\n                receiver,\n                amount,\n                blockHash,\n                logIndex\n            );\n            return true;\n        }\n\n        return true;\n    }\n\n    function getTransactionCount(bytes32 transactionId) public view returns(uint) {\n        uint count = 0;\n        for (uint i = 0; i < members.length; i++) {\n            if (votes[transactionId][members[i]])\n                count += 1;\n        }\n        return count;\n    }\n\n    function hasVoted(bytes32 transactionId) external view returns(bool)\n    {\n        return votes[transactionId][_msgSender()];\n    }\n\n    function transactionWasProcessed(bytes32 transactionId) external view returns(bool)\n    {\n        return processed[transactionId];\n    }\n\n    function getTransactionId(\n        address originalTokenAddress,\n        address sender,\n        address receiver,\n        uint256 amount,\n        bytes32 blockHash,\n        bytes32 transactionHash,\n        uint32 logIndex\n    ) public pure returns(bytes32)\n    {\n        return keccak256(\n            abi.encodePacked(\n            originalTokenAddress,\n            sender,\n            receiver,\n            amount,\n            blockHash,\n            transactionHash,\n            logIndex\n            )\n        );\n    }\n\n    function addMember(address _newMember) external onlyOwner\n    {\n        require(_newMember != NULL_ADDRESS, \"Federation: Empty member\");\n        require(!isMember[_newMember], \"Federation: Member already exists\");\n        require(members.length < MAX_MEMBER_COUNT, \"Federation: Max members reached\");\n\n        isMember[_newMember] = true;\n        members.push(_newMember);\n        emit MemberAddition(_newMember);\n    }\n\n    function removeMember(address _oldMember) external onlyOwner\n    {\n        require(_oldMember != NULL_ADDRESS, \"Federation: Empty member\");\n        require(isMember[_oldMember], \"Federation: Member doesn't exists\");\n        require(members.length > 1, \"Federation: Can't remove all the members\");\n        require(members.length - 1 >= required, \"Federation: Can't have less than required members\");\n\n        isMember[_oldMember] = false;\n        for (uint i = 0; i < members.length - 1; i++) {\n            if (members[i] == _oldMember) {\n                members[i] = members[members.length - 1];\n                break;\n            }\n        }\n        members.pop(); // remove an element from the end of the array.\n        emit MemberRemoval(_oldMember);\n    }\n\n    function getMembers() external view returns (address[] memory)\n    {\n        return members;\n    }\n\n    function changeRequirement(uint _required) external onlyOwner validRequirement(members.length, _required)\n    {\n        require(_required >= 2, \"Federation: Requires at least 2\");\n        required = _required;\n        emit RequirementChange(_required);\n    }\n\n    function emitHeartbeat(\n        uint256 fedRskBlock,\n        uint256 fedEthBlock,\n        string calldata federatorVersion,\n        string calldata nodeRskInfo,\n        string calldata nodeEthInfo\n    ) external onlyMember {\n        emit HeartBeat(\n            _msgSender(),\n            fedRskBlock,\n            fedEthBlock,\n            federatorVersion,\n            nodeRskInfo,\n            nodeEthInfo\n        );\n    }\n}"
    },
    "contracts/Federation/Federation.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\npragma abicoder v2;\n\n// Upgradables\nimport \"../zeppelin/upgradable/Initializable.sol\";\nimport \"../zeppelin/upgradable/ownership/UpgradableOwnable.sol\";\n\nimport \"../nftbridge/INFTBridge.sol\";\nimport \"../interface/IBridge.sol\";\nimport \"../interface/IFederation.sol\";\n\ncontract Federation is Initializable, UpgradableOwnable, IFederation {\n    uint constant public MAX_MEMBER_COUNT = 50;\n    address constant private NULL_ADDRESS = address(0);\n\n    IBridge public bridge;\n    address[] public members;\n\n    /**\n      @notice The minimum amount of votes to approve a transaction\n      @dev It should have more members than the required amount\n     */\n    uint public required;\n\n    /**\n      @notice All the addresses that are members of the federation\n      @dev The address should be a member to vote in transactions\n     */\n    mapping (address => bool) public isMember;\n\n    /**\n      (bytes32) transactionId = keccak256(\n        abi.encodePacked(\n          originalTokenAddress,\n          sender,\n          receiver,\n          amount,\n          blockHash,\n          transactionHash,\n          logIndex\n        )\n      ) => (\n        (address) members => (bool) voted\n      )\n      @notice Votes by members by the transaction ID\n      @dev usually the members should approve the transaction by 50% + 1\n     */\n    mapping (bytes32 => mapping (address => bool)) public votes;\n\n    /**\n      (bytes32) transactionId => (bool) voted\n      @notice Check if that transaction was already processed\n     */\n    mapping(bytes32 => bool) public processed;\n\n    /** Federator v3 variables */\n    INFTBridge public bridgeNFT;\n\n    modifier onlyMember() {\n        require(isMember[_msgSender()], \"Federation: Not Federator\");\n        _;\n    }\n\n    modifier validRequirement(uint membersCount, uint _required) {\n        // solium-disable-next-line max-len\n        require(_required <= membersCount && _required != 0 && membersCount != 0, \"Federation: Invalid requirements\");\n        _;\n    }\n\n    function initialize(address[] memory _members, uint _required, address _bridge, address owner, address _bridgeNFT) public\n    validRequirement(_members.length, _required) initializer {\n        UpgradableOwnable.initialize(owner);\n        require(_members.length <= MAX_MEMBER_COUNT, \"Federation: Too many members\");\n        members = _members;\n        for (uint i = 0; i < _members.length; i++) {\n            require(!isMember[_members[i]] && _members[i] != NULL_ADDRESS, \"Federation: Invalid members\");\n            isMember[_members[i]] = true;\n            emit MemberAddition(_members[i]);\n        }\n        required = _required;\n        emit RequirementChange(required);\n        _setBridge(_bridge);\n        _setNFTBridge(_bridgeNFT);\n    }\n\n    /**\n      @notice Current version of the contract\n      @return version in v{Number}\n     */\n    function version() external pure override returns (string memory) {\n      return \"v3\";\n    }\n\n    /**\n      @notice Sets a new bridge contract\n      @dev Emits BridgeChanged event\n      @param _bridge the new bridge contract address that should implement the IBridge interface\n     */\n    function setBridge(address _bridge) external onlyOwner override {\n        _setBridge(_bridge);\n    }\n\n    function _setBridge(address _bridge) internal {\n        require(_bridge != NULL_ADDRESS, \"Federation: Empty bridge\");\n        bridge = IBridge(_bridge);\n        emit BridgeChanged(_bridge);\n    }\n\n    /**\n      @notice Sets a new NFT bridge contract\n      @dev Emits NFTBridgeChanged event\n      @param _bridgeNFT the new NFT bridge contract address that should implement the INFTBridge interface\n     */\n    function setNFTBridge(address _bridgeNFT) external onlyOwner override {\n      _setNFTBridge(_bridgeNFT);\n    }\n\n    function _setNFTBridge(address _bridgeNFT) internal {\n      require(_bridgeNFT != NULL_ADDRESS, \"Federation: Empty NFT bridge\");\n      bridgeNFT = INFTBridge(_bridgeNFT);\n      emit NFTBridgeChanged(_bridgeNFT);\n    }\n\n    function validateTransaction(bytes32 transactionId) internal view returns(bool) {\n      uint transactionCount = getTransactionCount(transactionId);\n      return transactionCount >= required && transactionCount >= members.length / 2 + 1;\n    }\n\n    /**\n      @notice Vote in a transaction, if it has enough votes it accepts the transfer\n      @param originalTokenAddress The address of the token in the origin (main) chain\n      @param sender The address who solicited the cross token\n      @param receiver Who is going to receive the token in the opposite chain\n      @param value Could be the amount if tokenType == COIN or the tokenId if tokenType == NFT\n      @param blockHash The block hash in which the transaction with the cross event occurred\n      @param transactionHash The transaction in which the cross event occurred\n      @param logIndex Index of the event in the logs\n      @param tokenType Is the type of bridge to be used\n     */\n    function voteTransaction(\n      address originalTokenAddress,\n      address payable sender,\n      address payable receiver,\n      uint256 value,\n      bytes32 blockHash,\n      bytes32 transactionHash,\n      uint32 logIndex,\n      TokenType tokenType\n    ) external onlyMember override {\n        bytes32 transactionId = getTransactionId(\n            originalTokenAddress,\n            sender,\n            receiver,\n            value,\n            blockHash,\n            transactionHash,\n            logIndex\n        );\n        if (processed[transactionId])\n            return;\n\n        if (votes[transactionId][_msgSender()])\n            return;\n\n        votes[transactionId][_msgSender()] = true;\n        emit Voted(\n            _msgSender(),\n            transactionHash,\n            transactionId,\n            originalTokenAddress,\n            sender,\n            receiver,\n            value,\n            blockHash,\n            logIndex\n        );\n\n        if (validateTransaction(transactionId)) {\n            processed[transactionId] = true;\n            acceptTransfer(\n              originalTokenAddress,\n              sender,\n              receiver,\n              value,\n              blockHash,\n              transactionHash,\n              logIndex,\n              tokenType\n            );\n\n            emit Executed(\n                _msgSender(),\n                transactionHash,\n                transactionId,\n                originalTokenAddress,\n                sender,\n                receiver,\n                value,\n                blockHash,\n                logIndex\n            );\n            return;\n        }\n    }\n\n  function acceptTransfer(\n    address originalTokenAddress,\n    address payable sender,\n    address payable receiver,\n    uint256 value,\n    bytes32 blockHash,\n    bytes32 transactionHash,\n    uint32 logIndex,\n    TokenType tokenType\n  ) internal {\n    if (tokenType == TokenType.NFT) {\n      require(address(bridgeNFT) != NULL_ADDRESS, \"Federation: Empty NFTBridge\");\n      bridgeNFT.acceptTransfer(\n        originalTokenAddress,\n        sender,\n        receiver,\n        value,\n        blockHash,\n        transactionHash,\n        logIndex\n      );\n      return;\n    }\n\n    bridge.acceptTransfer(\n      originalTokenAddress,\n      sender,\n      receiver,\n      value,\n      blockHash,\n      transactionHash,\n      logIndex\n    );\n  }\n\n  /**\n    @notice Get the amount of approved votes for that transactionId\n    @param transactionId The transaction hashed from getTransactionId function\n   */\n  function getTransactionCount(bytes32 transactionId) public view returns(uint) {\n    uint count = 0;\n    for (uint i = 0; i < members.length; i++) {\n      if (votes[transactionId][members[i]])\n        count += 1;\n    }\n    return count;\n  }\n\n    function hasVoted(bytes32 transactionId) external view returns(bool)\n    {\n        return votes[transactionId][_msgSender()];\n    }\n\n    function transactionWasProcessed(bytes32 transactionId) external view returns(bool)\n    {\n        return processed[transactionId];\n    }\n\n    /**\n      @notice Gets the hash of transaction from the following parameters encoded and keccaked\n      @dev It encodes and applies keccak256 to the parameters received in the same order\n      @param originalTokenAddress The address of the token in the origin (main) chain\n      @param sender The address who solicited the cross token\n      @param receiver Who is going to receive the token in the opposite chain\n      @param amount Could be the amount or the tokenId\n      @param blockHash The block hash in which the transaction with the cross event occurred\n      @param transactionHash The transaction in which the cross event occurred\n      @param logIndex Index of the event in the logs\n      @return The hash generated by the parameters.\n    */\n    function getTransactionId(\n        address originalTokenAddress,\n        address sender,\n        address receiver,\n        uint256 amount,\n        bytes32 blockHash,\n        bytes32 transactionHash,\n        uint32 logIndex\n    ) public pure returns(bytes32) {\n      return keccak256(\n        abi.encodePacked(\n          originalTokenAddress,\n          sender,\n          receiver,\n          amount,\n          blockHash,\n          transactionHash,\n          logIndex\n        )\n      );\n    }\n\n    function addMember(address _newMember) external onlyOwner override\n    {\n        require(_newMember != NULL_ADDRESS, \"Federation: Empty member\");\n        require(!isMember[_newMember], \"Federation: Member already exists\");\n        require(members.length < MAX_MEMBER_COUNT, \"Federation: Max members reached\");\n\n        isMember[_newMember] = true;\n        members.push(_newMember);\n        emit MemberAddition(_newMember);\n    }\n\n    function removeMember(address _oldMember) external onlyOwner override\n    {\n        require(_oldMember != NULL_ADDRESS, \"Federation: Empty member\");\n        require(isMember[_oldMember], \"Federation: Member doesn't exists\");\n        require(members.length > 1, \"Federation: Can't remove all the members\");\n        require(members.length - 1 >= required, \"Federation: Can't have less than required members\");\n\n        isMember[_oldMember] = false;\n        for (uint i = 0; i < members.length - 1; i++) {\n            if (members[i] == _oldMember) {\n                members[i] = members[members.length - 1];\n                break;\n            }\n        }\n        members.pop(); // remove an element from the end of the array.\n        emit MemberRemoval(_oldMember);\n    }\n\n    /**\n      @notice Return all the current members of the federation\n      @return Current members\n     */\n    function getMembers() external view override returns (address[] memory) {\n      return members;\n    }\n\n    /**\n      @notice Changes the number of required members to vote and approve an transaction\n      @dev Emits the RequirementChange event\n      @param _required the number of minimum members to approve an transaction, it has to be bigger than 1\n     */\n    function changeRequirement(uint _required) external onlyOwner validRequirement(members.length, _required) override {\n      require(_required >= 2, \"Federation: Requires at least 2\");\n      required = _required;\n      emit RequirementChange(_required);\n    }\n\n    /**\n      @notice It emits an HeartBeat like an health check\n      @dev Emits HeartBeat event\n     */\n    function emitHeartbeat(\n      uint256 fedRskBlock,\n      uint256 fedEthBlock,\n      string calldata federatorVersion,\n      string calldata nodeRskInfo,\n      string calldata nodeEthInfo\n    ) external onlyMember override {\n      emit HeartBeat(\n        _msgSender(),\n        fedRskBlock,\n        fedEthBlock,\n        federatorVersion,\n        nodeRskInfo,\n        nodeEthInfo\n      );\n    }\n}\n"
    },
    "contracts/interface/IFederation.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\npragma abicoder v2;\n\ninterface IFederation {\n  enum TokenType{ COIN, NFT }\n\n  /**\n    @notice Current version of the contract\n    @return version in v{Number}\n    */\n  function version() external pure returns (string memory);\n\n  /**\n    @notice Sets a new bridge contract\n    @param _bridge the new bridge contract address that should implement the IBridge interface\n  */\n  function setBridge(address _bridge) external;\n\n  /**\n    @notice Sets a new NFT bridge contract\n    @param _bridgeNFT the new NFT bridge contract address that should implement the INFTBridge interface\n  */\n  function setNFTBridge(address _bridgeNFT) external;\n\n  /**\n    @notice Vote in a transaction, if it has enough votes it accepts the transfer\n    @param originalTokenAddress The address of the token in the origin (main) chain\n    @param sender The address who solicited the cross token\n    @param receiver Who is going to receive the token in the opposite chain\n    @param value Could be the amount if tokenType == COIN or the tokenId if tokenType == NFT\n    @param blockHash The block hash in which the transaction with the cross event occurred\n    @param transactionHash The transaction in which the cross event occurred\n    @param logIndex Index of the event in the logs\n    @param tokenType Is the type of bridge to be used\n  */\n  function voteTransaction(\n    address originalTokenAddress,\n    address payable sender,\n    address payable receiver,\n    uint256 value,\n    bytes32 blockHash,\n    bytes32 transactionHash,\n    uint32 logIndex,\n    TokenType tokenType\n  ) external;\n\n  /**\n    @notice Add a new member to the federation\n    @param _newMember address of the new member\n  */\n  function addMember(address _newMember) external;\n\n  /**\n    @notice Remove a member of the federation\n    @param _oldMember address of the member to be removed from federation\n  */\n  function removeMember(address _oldMember) external;\n\n  /**\n    @notice Return all the current members of the federation\n    @return Current members\n  */\n  function getMembers() external view returns (address[] memory);\n\n  /**\n    @notice Changes the number of required members to vote and approve an transaction\n    @param _required the number of minimum members to approve an transaction, it has to be bigger than 1\n  */\n  function changeRequirement(uint _required) external;\n\n  /**\n    @notice It emmits an HeartBeat like an healthy check\n  */\n  function emitHeartbeat(\n    uint256 fedRskBlock,\n    uint256 fedEthBlock,\n    string calldata federatorVersion,\n    string calldata nodeRskInfo,\n    string calldata nodeEthInfo\n  ) external;\n\n  event Executed(\n    address indexed federator,\n    bytes32 indexed transactionHash,\n    bytes32 indexed transactionId,\n    address originalTokenAddress,\n    address sender,\n    address receiver,\n    uint256 amount,\n    bytes32 blockHash,\n    uint32 logIndex\n  );\n  event MemberAddition(address indexed member);\n  event MemberRemoval(address indexed member);\n  event RequirementChange(uint required);\n  event BridgeChanged(address bridge);\n  event NFTBridgeChanged(address bridgeNFT);\n  event Voted(\n    address indexed federator,\n    bytes32 indexed transactionHash,\n    bytes32 indexed transactionId,\n    address originalTokenAddress,\n    address sender,\n    address receiver,\n    uint256 amount,\n    bytes32 blockHash,\n    uint32 logIndex\n  );\n  event HeartBeat(\n    address indexed sender,\n    uint256 fedRskBlock,\n    uint256 fedEthBlock,\n    string federatorVersion,\n    string nodeRskInfo,\n    string nodeEthInfo\n  );\n\n}\n"
    },
    "contracts/zeppelin/access/roles/MinterRole.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\npragma abicoder v2;\n\nimport \"../../GSN/Context.sol\";\nimport \"../Roles.sol\";\n\nabstract contract MinterRole is Context {\n    using Roles for Roles.Role;\n\n    event MinterAdded(address indexed account);\n    event MinterRemoved(address indexed account);\n\n    Roles.Role private _minters;\n\n    constructor () {\n        _addMinter(_msgSender());\n    }\n\n    modifier onlyMinter() {\n        require(isMinter(_msgSender()), \"MinterRole: caller doesn't have the role\");\n        _;\n    }\n\n    function isMinter(address account) public view returns (bool) {\n        return _minters.has(account);\n    }\n\n    function addMinter(address account) public onlyMinter {\n        _addMinter(account);\n    }\n\n    function renounceMinter() public {\n        _removeMinter(_msgSender());\n    }\n\n    function _addMinter(address account) internal {\n        _minters.add(account);\n        emit MinterAdded(account);\n    }\n\n    function _removeMinter(address account) internal {\n        _minters.remove(account);\n        emit MinterRemoved(account);\n    }\n}\n"
    },
    "contracts/zeppelin/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\npragma abicoder v2;\n\nimport \"../../GSN/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20Mintable}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() override public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) override public view returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) override public returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) override public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) override public returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for `sender`'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) override public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from zero address\");\n        require(recipient != address(0), \"ERC20: transfer to zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n     /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: burn from zero address\");\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal {\n        require(owner != address(0), \"ERC20: approve from zero address\");\n        require(spender != address(0), \"ERC20: approve to zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\n     * from the caller's allowance.\n     *\n     * See {_burn} and {_approve}.\n     */\n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"ERC20: burn amount exceeds allowance\"));\n    }\n}\n"
    },
    "contracts/test/mockERC677Reciever.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"../zeppelin/token/ERC20/ERC20Detailed.sol\";\nimport \"../zeppelin/token/ERC20/ERC20.sol\";\nimport \"../interface/IERC677Receiver.sol\";\n\ncontract mockERC677Receiver is IERC677Receiver {\n    event Success(address _sender, uint _value, bytes _data);\n    /**\n     * ERC-677's only method implementation\n     * See https://github.com/ethereum/EIPs/issues/677 for details\n     */\n    function onTokenTransfer(address _sender, uint _value, bytes memory _data) override public {\n        emit Success(_sender, _value, _data);\n    }\n}"
    },
    "contracts/zeppelin/token/ERC20/ERC20Detailed.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\npragma abicoder v2;\n\nimport \"./IERC20.sol\";\n\n/**\n * @dev Optional functions from the ERC20 standard.\n */\nabstract contract ERC20Detailed is IERC20 {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\n     * these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory aName, string memory aSymbol, uint8 theDecimals) {\n        _name = aName;\n        _symbol = aSymbol;\n        _decimals = theDecimals;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n}\n"
    },
    "contracts/zeppelin/upgradable/proxy/UpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\npragma abicoder v2;\n\nimport \"./Proxy.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n *\n * Upgradeability is only provided internally through {_upgradeTo}. For an externally upgradeable proxy see\n * {TransparentUpgradeableProxy}.\n */\ncontract UpgradeableProxy is Proxy {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializating the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n        _setImplementation(_logic);\n        if(_data.length > 0) {\n            Address.functionDelegateCall(_logic, _data);\n        }\n    }\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 private constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        bytes32 slot = _IMPLEMENTATION_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            impl := sload(slot)\n        }\n    }\n\n    /**\n     * @dev Upgrades the proxy to a new implementation.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal virtual {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"UpgradeableProxy: new implementation is not a contract\");\n\n        bytes32 slot = _IMPLEMENTATION_SLOT;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(slot, newImplementation)\n        }\n    }\n}\n"
    },
    "contracts/zeppelin/upgradable/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\npragma abicoder v2;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 { revert(0, returndatasize()) }\n            default { return(0, returndatasize()) }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback () external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive () external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overriden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {\n    }\n}\n"
    },
    "contracts/zeppelin/upgradable/proxy/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\npragma abicoder v2;\n\nimport \"./UpgradeableProxy.sol\";\n\n/**\n * @dev This contract implements a proxy that is upgradeable by an admin.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n * \"admin cannot fallback to proxy target\".\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n */\ncontract TransparentUpgradeableProxy is UpgradeableProxy {\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {UpgradeableProxy-constructor}.\n     */\n    constructor(address _logic, address admin_, bytes memory _data) payable UpgradeableProxy(_logic, _data) {\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n        _setAdmin(admin_);\n    }\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 private constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _admin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function admin() external ifAdmin returns (address admin_) {\n        admin_ = _admin();\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function implementation() external ifAdmin returns (address implementation_) {\n        implementation_ = _implementation();\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\n     */\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\n        require(newAdmin != address(0), \"TransparentUpgradeableProxy: new admin is the zero address\");\n        emit AdminChanged(_admin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\n     */\n    function upgradeTo(address newImplementation) external virtual ifAdmin {\n        _upgradeTo(newImplementation);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable virtual ifAdmin {\n        _upgradeTo(newImplementation);\n        Address.functionDelegateCall(newImplementation, data);\n    }\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _admin() internal view virtual returns (address adm) {\n        bytes32 slot = _ADMIN_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            adm := sload(slot)\n        }\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        bytes32 slot = _ADMIN_SLOT;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(slot, newAdmin)\n        }\n    }\n\n    /**\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\n     */\n    function _beforeFallback() internal virtual override {\n        require(msg.sender != _admin(), \"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");\n        super._beforeFallback();\n    }\n}\n"
    },
    "contracts/zeppelin/upgradable/proxy/ProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\npragma abicoder v2;\n\nimport \"../../ownership/Ownable.sol\";\nimport \"./TransparentUpgradeableProxy.sol\";\n\n/**\n * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an\n * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.\n */\ncontract ProxyAdmin is Ownable {\n\n    /**\n     * @dev Returns the current implementation of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyImplementation(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"implementation()\")) == 0x5c60da1b\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"5c60da1b\");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Returns the current admin of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyAdmin(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"admin()\")) == 0xf851a440\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"f851a440\");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Changes the admin of `proxy` to `newAdmin`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the current admin of `proxy`.\n     */\n    function changeProxyAdmin(TransparentUpgradeableProxy proxy, address newAdmin) public virtual onlyOwner {\n        proxy.changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgrade(TransparentUpgradeableProxy proxy, address implementation) public virtual onlyOwner {\n        proxy.upgradeTo(implementation);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See\n     * {TransparentUpgradeableProxy-upgradeToAndCall}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgradeAndCall(TransparentUpgradeableProxy proxy, address implementation, bytes memory data) public payable virtual onlyOwner {\n        proxy.upgradeToAndCall{value: msg.value}(implementation, data);\n    }\n}\n"
    },
    "contracts/Federation/FederationV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"../Bridge/IBridgeV2.sol\";\nimport \"../zeppelin/ownership/Ownable.sol\";\n\ncontract FederationV1 is Ownable {\n    uint constant public MAX_MEMBER_COUNT = 50;\n    address constant private NULL_ADDRESS = address(0);\n\n    IBridgeV2 public bridge;\n    address[] public members;\n    uint public required;\n\n    mapping (address => bool) public isMember;\n    mapping (bytes32 => mapping (address => bool)) public votes;\n    mapping(bytes32 => bool) public processed;\n    // solium-disable-next-line max-len\n    event Voted(address indexed sender, bytes32 indexed transactionId, address originalTokenAddress, address receiver, uint256 amount, string symbol, bytes32 blockHash, bytes32 indexed transactionHash, uint32 logIndex, uint8 decimals, uint256 granularity);\n    event Executed(bytes32 indexed transactionId);\n    event MemberAddition(address indexed member);\n    event MemberRemoval(address indexed member);\n    event RequirementChange(uint required);\n    event BridgeChanged(address bridge);\n\n    modifier onlyMember() {\n        require(isMember[_msgSender()], \"Federation: Caller not a Federator\");\n        _;\n    }\n\n    modifier validRequirement(uint membersCount, uint _required) {\n        // solium-disable-next-line max-len\n        require(_required <= membersCount && _required != 0 && membersCount != 0, \"Federation: Invalid requirements\");\n        _;\n    }\n\n    constructor(address[] memory _members, uint _required) validRequirement(_members.length, _required) {\n        require(_members.length <= MAX_MEMBER_COUNT, \"Federation: Members larger than max allowed\");\n        members = _members;\n        for (uint i = 0; i < _members.length; i++) {\n            require(!isMember[_members[i]] && _members[i] != NULL_ADDRESS, \"Federation: Invalid members\");\n            isMember[_members[i]] = true;\n            emit MemberAddition(_members[i]);\n        }\n        required = _required;\n        emit RequirementChange(required);\n    }\n\n    function setBridge(address _bridge) external onlyOwner {\n        require(_bridge != NULL_ADDRESS, \"Federation: Empty bridge\");\n        bridge = IBridgeV2(_bridge);\n        emit BridgeChanged(_bridge);\n    }\n\n    function voteTransaction(\n        address originalTokenAddress,\n        address receiver,\n        uint256 amount,\n        string calldata symbol,\n        bytes32 blockHash,\n        bytes32 transactionHash,\n        uint32 logIndex,\n        uint8 decimals,\n        uint256 granularity)\n    external onlyMember returns(bool)\n    {\n        // solium-disable-next-line max-len\n        bytes32 transactionId = getTransactionId(originalTokenAddress, receiver, amount, symbol, blockHash, transactionHash, logIndex, decimals, granularity);\n        if (processed[transactionId])\n            return true;\n\n        if (votes[transactionId][_msgSender()])\n            return true;\n\n        votes[transactionId][_msgSender()] = true;\n        // solium-disable-next-line max-len\n        emit Voted(_msgSender(), transactionId, originalTokenAddress, receiver, amount, symbol, blockHash, transactionHash, logIndex, decimals, granularity);\n\n        uint transactionCount = getTransactionCount(transactionId);\n        if (transactionCount >= required && transactionCount >= members.length / 2 + 1) {\n            processed[transactionId] = true;\n            bool acceptTransfer = bridge.acceptTransfer(originalTokenAddress, receiver, amount, symbol, blockHash, transactionHash, logIndex, decimals, granularity);\n            require(acceptTransfer, \"Federation: Bridge acceptTransfer error\");\n            emit Executed(transactionId);\n            return true;\n        }\n\n        return true;\n    }\n\n    function getTransactionCount(bytes32 transactionId) public view returns(uint) {\n        uint count = 0;\n        for (uint i = 0; i < members.length; i++) {\n            if (votes[transactionId][members[i]])\n                count += 1;\n        }\n        return count;\n    }\n\n    function hasVoted(bytes32 transactionId) external view returns(bool)\n    {\n        return votes[transactionId][_msgSender()];\n    }\n\n    function transactionWasProcessed(bytes32 transactionId) external view returns(bool)\n    {\n        return processed[transactionId];\n    }\n\n    function getTransactionId(\n        address originalTokenAddress,\n        address receiver,\n        uint256 amount,\n        string memory symbol,\n        bytes32 blockHash,\n        bytes32 transactionHash,\n        uint32 logIndex,\n        uint8 decimals,\n        uint256 granularity)\n    public pure returns(bytes32)\n    {\n        // solium-disable-next-line max-len\n        return keccak256(abi.encodePacked(originalTokenAddress, receiver, amount, symbol, blockHash, transactionHash, logIndex, decimals, granularity));\n    }\n\n    function addMember(address _newMember) external onlyOwner\n    {\n        require(_newMember != NULL_ADDRESS, \"Federation: Empty member\");\n        require(!isMember[_newMember], \"Federation: Member already exists\");\n        require(members.length < MAX_MEMBER_COUNT, \"Federation: Max members reached\");\n\n        isMember[_newMember] = true;\n        members.push(_newMember);\n        emit MemberAddition(_newMember);\n    }\n\n    function removeMember(address _oldMember) external onlyOwner\n    {\n        require(_oldMember != NULL_ADDRESS, \"Federation: Empty member\");\n        require(isMember[_oldMember], \"Federation: Member doesn't exists\");\n        require(members.length > 1, \"Federation: Can't remove all the members\");\n        require(members.length - 1 >= required, \"Federation: Can't have less than required members\");\n\n        isMember[_oldMember] = false;\n        for (uint i = 0; i < members.length - 1; i++) {\n            if (members[i] == _oldMember) {\n                members[i] = members[members.length - 1];\n                break;\n            }\n        }\n        members.pop(); // remove last element\n        emit MemberRemoval(_oldMember);\n    }\n\n    function getMembers() external view returns (address[] memory)\n    {\n        return members;\n    }\n\n    function changeRequirement(uint _required) external onlyOwner validRequirement(members.length, _required)\n    {\n        require(_required >= 2, \"Federation: Requires at least 2\");\n        required = _required;\n        emit RequirementChange(_required);\n    }\n\n}"
    },
    "contracts/Proxies.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\npragma abicoder v2;\n\nimport \"./zeppelin/upgradable/proxy/TransparentUpgradeableProxy.sol\";\n\ncontract BridgeProxy is TransparentUpgradeableProxy {\n  // solhint-disable-next-line no-empty-blocks\n  constructor(address _logic, address _admin, bytes memory _data) TransparentUpgradeableProxy(_logic,_admin, _data) payable {}\n}\n\ncontract AllowTokensProxy is TransparentUpgradeableProxy {\n  // solhint-disable-next-line no-empty-blocks\n  constructor(address _logic, address _admin, bytes memory _data) TransparentUpgradeableProxy(_logic,_admin, _data) payable {}\n}\n\ncontract FederationProxy is TransparentUpgradeableProxy {\n  // solhint-disable-next-line no-empty-blocks\n  constructor(address _logic, address _admin, bytes memory _data) TransparentUpgradeableProxy(_logic,_admin, _data) payable {}\n}"
    },
    "contracts/test/MainToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"../zeppelin/token/ERC20/ERC20Detailed.sol\";\nimport \"../zeppelin/token/ERC20/ERC20.sol\";\n\ncontract MainToken is ERC20Detailed, ERC20 {\n    constructor(string memory name, string memory symbol, uint8 decimals, uint totalSupply)\n        ERC20Detailed(name, symbol, decimals)\n    {\n        _mint(msg.sender, totalSupply);\n    }\n\n    /**\n     * ERC-677's only method implementation\n     * See https://github.com/ethereum/EIPs/issues/677 for details\n     */\n    function transferAndCall(address _to, uint _value, bytes memory _data) public returns (bool) {\n        bool result = transfer(_to, _value);\n        if (!result) return false;\n\n        ERC677TransferReceiver receiver = ERC677TransferReceiver(_to);\n        receiver.tokenFallback(msg.sender, _value, _data);\n\n        // IMPORTANT: the ERC-677 specification does not say\n        // anything about the use of the receiver contract's\n        // tokenFallback method return value. Given\n        // its return type matches with this method's return\n        // type, returning it could be a possibility.\n        // We here take the more conservative approach and\n        // ignore the return value, returning true\n        // to signal a succesful transfer despite tokenFallback's\n        // return value -- fact being tokens are transferred\n        // in any case.\n        return true;\n    }\n}\n\ninterface ERC677TransferReceiver {\n    function tokenFallback(address from, uint256 amount, bytes calldata data) external returns (bool);\n}"
    },
    "contracts/test/AlternativeERC20Detailed.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"../zeppelin/token/ERC20/ERC20.sol\";\n\ncontract AlternativeERC20Detailed is ERC20 {\n    string private _name;\n    bytes32 private _symbol;\n    uint256 private _decimals;\n\n    constructor(string memory aName, bytes32 aSymbol, uint256 someDecimals, uint256 aTotalSupply)\n    {\n        _name = aName;\n        _symbol = aSymbol;\n        _decimals = someDecimals;\n        _mint(msg.sender, aTotalSupply);\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (bytes32) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint256) {\n        return _decimals;\n    }\n}"
    },
    "contracts/test/nftbridge/NFTERC721TestToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.6;\n\nimport \"../../zeppelin/token/ERC721/ERC721.sol\";\n\ncontract NFTERC721TestToken is ERC721 {\n\n  string private _contractURI;\n\n  constructor(string memory name_, string memory symbol_) ERC721(name_, symbol_) {}\n\n  function safeMint(address to, uint256 tokenId) public {\n    _safeMint(to, tokenId);\n  }\n\n  function setBaseURI(string memory baseURI) public {\n    _setBaseURI(baseURI);\n  }\n\n  function setContractURI(string memory contractURI_) public {\n    _contractURI = contractURI_;\n  }\n\n  function contractURI() public view returns (string memory) {\n    return _contractURI;\n  }\n\n  function setTokenURI(uint256 tokenId, string memory _tokenURI) public {\n    _setTokenURI(tokenId, _tokenURI);\n  }\n\n}\n"
    },
    "contracts/nftbridge/SideNFTToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"./ISideNFTToken.sol\";\nimport \"../zeppelin/token/ERC721/ERC721.sol\";\nimport \"../zeppelin/token/ERC721/ERC721Burnable.sol\";\n\ncontract SideNFTToken is ISideNFTToken, ERC721, ERC721Burnable {\n  address public minter;\n  string private _contractURI;\n\n  constructor(string memory _name, string memory _symbol, address _minter, string memory _baseURI, string memory contractURI_) ERC721(_name, _symbol) {\n    require(_minter != address(0), \"SideToken: Empty Minter\");\n    minter = _minter;\n    _setBaseURI(_baseURI);\n    _setContractURI(contractURI_);\n  }\n\n  function _setContractURI(string memory contractURI_) internal {\n    _contractURI = contractURI_;\n  }\n\n  function contractURI() public view returns (string memory) {\n    return _contractURI;\n  }\n\n  modifier onlyMinter() {\n    require(_msgSender() == minter, \"SideToken: Caller is not the minter\");\n    _;\n  }\n\n  function mint(address account, uint256 tokenId) external onlyMinter override {\n    _mint(account, tokenId);\n  }\n}"
    },
    "contracts/nftbridge/SideNFTTokenFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"../zeppelin/ownership/Secondary.sol\";\nimport \"./ISideNFTTokenFactory.sol\";\nimport \"./SideNFTToken.sol\";\n\ncontract SideNFTTokenFactory is ISideNFTTokenFactory, Secondary {\n\n    function createSideNFTToken(string calldata name, string calldata symbol, string calldata baseURI,\n        string calldata contractURI) external onlyPrimary override returns(address) {\n        address sideTokenAddress = address(new SideNFTToken(name, symbol, primary(), baseURI, contractURI));\n        emit SideNFTTokenCreated(sideTokenAddress, symbol, baseURI, contractURI);\n        return sideTokenAddress;\n    }\n}"
    },
    "contracts/zeppelin/token/ERC1155/ERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"./IERC1155Receiver.sol\";\nimport \"../../introspection/ERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\n    constructor() {\n        _registerInterface(\n            ERC1155Receiver(address(0)).onERC1155Received.selector ^\n            ERC1155Receiver(address(0)).onERC1155BatchReceived.selector\n        );\n    }\n}\n"
    },
    "contracts/zeppelin/token/ERC1155/ERC1155Holder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"./ERC1155Receiver.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ncontract ERC1155Holder is ERC1155Receiver {\n    function onERC1155Received(address, address, uint256, uint256, bytes memory) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n}\n"
    },
    "contracts/zeppelin/token/ERC721/ERC721Holder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"./IERC721Receiver.sol\";\n\n  /**\n   * @dev Implementation of the {IERC721Receiver} interface.\n   *\n   * Accepts all token transfers. \n   * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\n   */\ncontract ERC721Holder is IERC721Receiver {\n\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     *\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n}\n"
    },
    "contracts/zeppelin/token/ERC1155/ERC1155Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"./ERC1155.sol\";\n\n/**\n * @dev Extension of {ERC1155} that allows token holders to destroy both their\n * own tokens and those that they have been approved to use.\n *\n * _Available since v3.1._\n */\nabstract contract ERC1155Burnable is ERC1155 {\n    function burn(address account, uint256 id, uint256 value) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        _burn(account, id, value);\n    }\n\n    function burnBatch(address account, uint256[] memory ids, uint256[] memory values) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        _burnBatch(account, ids, values);\n    }\n}\n"
    },
    "contracts/test/LibUtilsHarness.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"../lib/LibUtils.sol\";\n\ncontract LibUtilsHarness {\n\n    function decimalsToGranularity(uint8 decimals) external pure returns (uint256) {\n        return LibUtils.decimalsToGranularity(decimals);\n    }\n\n    function getDecimals(address tokenToUse) external view returns (uint8) {\n        return LibUtils.getDecimals(tokenToUse);\n    }\n\n    function getGranularity(address tokenToUse) external view returns (uint256) {\n        return LibUtils.getGranularity(tokenToUse);\n    }\n\n    function bytesToAddress(bytes memory bys) external pure returns (address addr) {\n        return LibUtils.bytesToAddress(bys);\n    }\n\n}\n"
    }
  },
  "settings": {
    "evmVersion": "istanbul",
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}